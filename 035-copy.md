# コピー

クラスにコピーを正しく実装するためには、まずコピーが何であるかを理解しなければならない。

## 普通のコピーの意味

C++を書くユーザーは、クラス型のオブジェクトを使うとき、クラスが普通に振る舞うことを期待している。この「普通」には様々な意味がある。

`int`型の変数をコピーするとき、コピー先の変数はコピー元の変数と等しくなる。

~~~c++
int source = 42 ;
int destination = x ;
~~~

この例では変数`destination`は変数`source`と等しくなる。`source == destination`は`true`となり、`destination`の値は`42`になる。

コピーの結果、コピー先の変数は値が書き換えられる。コピー元の変数は変わらない。上の例で、変数`source`が勝手に別の値になることは「普通」はない。

我々がコピーと認識しているものは、コピー構築とコピー代入に分けることができる。

~~~c++
int source = 42 ;
// コピー構築
int b = source ;
int c(source) ;
int d{source}

// 変数e
int e ;
// コピー代入
e = source ;
~~~

ユーザーは普通、コピー構築とコピー代入のコピーが両方とも同じ挙動をすると期待している。コピー構築とコピー代入のどちらか片方が使えるならば、もう片方も使えるべきで、そのコピーの挙動は同じであるべきだ。

コピー代入にはコピーの普通さらにユーザーが代入に期待する普通がある。

代入式を評価した結果は、代入されるオブジェクトへのlvalueリファレンスになる。

~~~cpp
int main()
{
    int x, y, z ;
    // x, y, zに0を代入
    x = y = z = 0 ;
}
~~~

これはまず`z = 0`が評価される。変数`z`の値は`0`になり、式を評価した結果の値は`z`へのlvalueリファレンスだ。なので、`y = z = 0`というのは、`y = (z=0)`となる。`z=0`については`z`であるので、`y = z`となる。ここでの`z`は`0`を代入された後の`z`なので、値は`0`だ。その結果変数`y`の値は`0`になる。変数`x`の場合も同様だ。

以下のような例も見てみよう。

~~~cpp
int main()
{
    int x ;
    (x = 0) = 1 ;
}
~~~

これは`(x = 0)`の結果に`1`を代入している。`x=0`の結果は`x`なので、`x`には`0`が代入された後に`1`が代入される。結果として`x`の値は`1`になる。

## コピーコンストラクター

コピー構築の場合、コピーコンストラクターが呼ばれる。

~~~c++
struct Value
{
    // コピーコンストラクター
    X( const X & source )
    { }
} ;

int main()
{
    Value source ;
    // コピーコンストラクターを呼ぶ
    Value b = source ;
    Value c(source) ;
    Value d{source} ;
}
~~~

コピーコンストラクターは`クラス型へのlvalueリファレンス型`を引数にとる`コンストラクター`だ。

~~~cpp
struct X
{
    X( const X & source ) { }
} ;
~~~

引数は通常は`constなlvalueリファレンス型`だが、`非constなlvalueリファレンス型`を引数に取るコンストラクターも`コピーコンストラクター`となる。

~~~cpp
struct X
{
    X( X & source ) { }
} ;
~~~

ただし、非constなlvalueリファレンス型を引数に取るコピーコンストラクターは通常は使わない。なぜならば、コピーの結果、コピー元が書き換えられるような挙動は不自然だからだ。

~~~cpp
struct funny_number
{
    int n ;
    funny_number( int n = 0 )
        : n(n) { }
    funny_number( funny_number & source )
        : n( source.n )
    {
        source.n = 0 ;
    }
} ;

int main()
{
    funny_number a = 1 ;
    // コピー
    funny_number b = a ;
    // a == 1
    // b == 0
}
~~~

このおかしな`funny_number`のコピーコンストラクターはコピー元を0に書き換えてしまう。このコードは完全に合法なC++のコードだが、このようにコピーコンストラクターを実装するのはおすすめできない。なぜならば、ユーザーはコピーについて上で示したような意味を普通だと想定しているため、普通から外れるような型はユーザーのあてが外れてしまうからだ。

## コピー代入演算子

コピー代入演算子は`クラス型へのlvalueリファレンス型`を引数に取る`operator =`のオーバーロードだ。

~~~cpp
struct X
{
    X & operator = ( const X & source )
    {
        return *this ;
    }
} ;
~~~

コピーコンストラクターと同じく、コピー代入演算子の引数は非constなlvalueリファレンスでもよい。ただし、ユーザーの期待する普通にはそぐわない結果になる。

コピー代入演算子の戻り値の型はクラス型への非constなlvalueリファレンスでなくてもよい。ただし、その場合もユーザーの期待にそぐわないことになる。

~~~c++
struct X
{
    void operator = ( const X & source ) { }
} ;

int main()
{
    X a, b, c ;
    // OK
    a = b ;
    // エラー
    a = b = c ;
}
~~~

`a = b = c`は、クラス`X`のコピー代入演算子の戻り値の型が`void`なので動かない。ユーザーは普通、これが動くことを期待している。ユーザーの期待に答えるためにはクラスへの非constなlvalueリファレンスを返さなければならない。


