# 傲慢なエラー処理: 例外

`std::array`の実装方法はほとんど解説した。読者は`std::array`の実装方法を知り、確固たる自信のもとに`std::array`を使えるようになった。ただし、ひとつだけ問題がある。

"std::array"のユーザーはあらかじめ設定した要素数を超える範囲の要素にアクセスすることができてしまう。

~~~c++
int main()
{
    // 妥当な要素はa[0]のみ
    std::array<int, 1> a = {1} ;

    // エラー、範囲外
    a[1000] = 0 ;
}
~~~

`array`を自力で実装できる傲慢な読者としては、ユーザーごときが間違った使い方をできるのが許せない。間違いを起こした時点でエラーを発生させ、問題を知らしめ、対処できるようにしたい。

`operator []`に範囲外チェックを入れるのは簡単だ。問題は、エラーをユーザーに通知する方法がない。

~~~c++
reference array::operator [] ( std::size_t i )
{
    // 範囲外チェック
    if ( i >= N )
    {
        // エラー検出
        // しかし何をreturnすればいいのだろう。
    }

    return storage[i] ;
}
~~~

`operator []`は伝統的にエラーチェックをしない要素アクセスをするものだ。

`vector`で一番最初に説明した要素アクセスの方法であるメンバー関数`at`を覚えているだろうか。実はメンバー関数`at`はエラーチェックをする。試してみよう。

~~~c++
int main()
{
    std::array<int, 1> a = {1} ;

    std::cout << a.at(1000) = 0 ;
}
~~~

以下が実行結果だ。

~~~
terminate called after throwing an instance of 'std::out_of_range'
  what():  array::at: __n (which is 1000) >= _Nm (which is 1)
~~~

何やらよくわからないがエラーのようだ。以下のような意味であることがわかる。

~~~
`std::out_of_range`がthrowされたあとにterminateが呼ばれた
  what(): array_at: __n(値は1000) >= _Nm (値は1)
~~~

どうやらエラーメッセージのようだ。わかりづらいメッセージだが、なんとなく言わんとすることはわかる。`_Nm`がarrayの要素数で、`__n`がメンバー関数`at`に渡した実引数だ。要素数`_Nm`よりも`__n`が大きい。

このエラー処理は、「例外」を使って行われる。


