<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="江添 亮" />
  <meta name="date" content="2018-02-27" />
  <title>江添亮のプログラマーのためのC++入門</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <style>
  pre > code
  {
      display : block ;
      font-family : monospace ;
      font-size : x-large ;
      border-style : solid ;
      border-width : medium ;
      border-color : black ;
      border-radius : 0.4em ;
      padding : 0.5em ;
      word-wrap : break-word ;
      white-space : pre-wrap ;
  }
  
  h1,h2,h3,h4,h5,h6
  {
      font-size : 2em ;
      font-weight : bold ;
  }
  
  table, th, td {
      border: 1px solid black;
      border-collapse: collapse;
      padding : 0.5em ;
  }
  </style>
</head>
<body>
<div id="header">
<h1 class="title">江添亮のプログラマーのためのC++入門</h1>
<h2 class="author">江添 亮</h2>
<h3 class="date">2018-02-27</h3>
</div>
<div id="TOC">
<ul>
<li><a href="#序">序</a></li>
<li><a href="#cの概要">C++の概要</a></li>
<li><a href="#cの実行">C++の実行</a><ul>
<li><a href="#cの実行の仕組み">C++の実行の仕組み</a></li>
<li><a href="#簡単な一つのソースファイルからなるプログラムの実行">簡単な一つのソースファイルからなるプログラムの実行</a><ul>
<li><a href="#サンプルコード">サンプルコード</a></li>
<li><a href="#コンパイル">コンパイル</a></li>
<li><a href="#実行">実行</a></li>
</ul></li>
<li><a href="#gcc-cコンパイラー">GCC: C++コンパイラー</a><ul>
<li><a href="#コンパイラーオプション">コンパイラーオプション</a></li>
<li><a href="#ヘッダーファイルの省略">ヘッダーファイルの省略</a></li>
<li><a href="#コンパイル済みヘッダーprecompiled-header">コンパイル済みヘッダー(precompiled header)</a></li>
</ul></li>
<li><a href="#make-ビルドシステム">Make: ビルドシステム</a><ul>
<li><a href="#コンパイルと実行のまとめ">コンパイルと実行のまとめ</a></li>
<li><a href="#依存関係を解決するビルドシステム">依存関係を解決するビルドシステム</a></li>
<li><a href="#依存関係を記述するルール">依存関係を記述するルール</a></li>
<li><a href="#コメント">コメント</a></li>
<li><a href="#変数">変数</a></li>
<li><a href="#自動変数">自動変数</a><ul>
<li><a href="#ターゲット"><code>$@</code> ターゲット</a></li>
<li><a href="#最初の事前要件"><code>$&lt;</code> 最初の事前要件</a></li>
<li><a href="#すべての事前要件"><code>$^</code> すべての事前要件</a></li>
<li><a href="#自動変数の組み合わせ">自動変数の組み合わせ</a></li>
</ul></li>
<li><a href="#phonyターゲット">PHONYターゲット</a></li>
</ul></li>
<li><a href="#入門用の環境構築">入門用の環境構築</a></li>
</ul></li>
<li><a href="#c観光案内">C++観光案内</a><ul>
<li><a href="#最小のコード">最小のコード</a></li>
<li><a href="#標準出力">標準出力</a></li>
<li><a href="#文字列">文字列</a></li>
<li><a href="#整数と浮動小数点数">整数と浮動小数点数</a></li>
<li><a href="#変数variable">変数(variable)</a></li>
<li><a href="#関数function">関数(function)</a></li>
<li><a href="#本当の関数">本当の関数</a></li>
</ul></li>
<li><a href="#デバッグコンパイルエラー">デバッグ：コンパイルエラー</a><ul>
<li><a href="#文法エラー">文法エラー</a></li>
</ul></li>
<li><a href="#cプリプロセッサー">Cプリプロセッサー</a><ul>
<li><a href="#includeディレクティブ">#includeディレクティブ</a></li>
<li><a href="#define">#define</a><ul>
<li><a href="#オブジェクト風マクロ">オブジェクト風マクロ</a></li>
<li><a href="#関数風マクロ">関数風マクロ</a></li>
<li><a href="#va_args__可変長引数マクロ"><code>__VA_ARGS__</code>(可変長引数マクロ)</a></li>
<li><a href="#va_opt__"><code>__VA_OPT__</code></a></li>
<li><a href="#演算子">#演算子</a></li>
<li><a href="#演算子-1">##演算子</a></li>
<li><a href="#複数行の置換リスト">複数行の置換リスト</a></li>
<li><a href="#undefディレクティブ">#undefディレクティブ</a></li>
</ul></li>
<li><a href="#条件付きソースファイル選択">条件付きソースファイル選択</a><ul>
<li><a href="#プリプロセッサーの定数式">プリプロセッサーの定数式</a></li>
<li><a href="#ifディレクティブ">#ifディレクティブ</a></li>
<li><a href="#elifディレクティブ">#elifディレクティブ</a></li>
<li><a href="#elseディレクティブ">#elseディレクティブ</a></li>
<li><a href="#ifdef-ifndefディレクティブ">#ifdef, #ifndefディレクティブ</a></li>
</ul></li>
<li><a href="#lineディレクティブ">#lineディレクティブ</a></li>
<li><a href="#errorディレクティブ">#errorディレクティブ</a></li>
<li><a href="#pragmra">#pragmra</a></li>
<li><a href="#nullディレクティブ">Nullディレクティブ</a></li>
<li><a href="#定義済みマクロ名">定義済みマクロ名</a></li>
</ul></li>
</ul>
</div>
<h1 id="序">序</h1>
<p>本書はプログラミング経験者向けのC++入門書である。</p>
<p>本書の対象読者は、すでに何らかの実用的なプログラミング言語を習得していることを想定し、プログラミングの初歩的な概念はすべて理解しているものとして説明しない。そのため、本書には、「変数は箱のようなものである」といったような説明は出てこない。ただし、主要な他の言語とC++として特別に注意が必要な差は解説している。</p>
<h1 id="cの概要">C++の概要</h1>
<p>C++とは何か。C++の原作者にして最初の実装者であるBjarne Stroustrupは、以下のように簡潔にまとめている。</p>
<blockquote>
<p>C++は、Simulaのプログラム構造化のための機構と、Cのシステムプログラミング用の効率性と柔軟性を提供するために設計された。C++は半年ほどで現場で使えることを見込んでいた。結果として成功した。</p>
<p>Bjarne Stroustrup, A Hisotory of C++: 1979-1991, HOPL2</p>
</blockquote>
<p>プログラミング言語史に詳しくない読者は、Simulaというプログラミング言語について知らないことだろう。Simulaというのは、初めてオブジェクト指向プログラミングを取り入れたプログラミング言語だ。当時と言えばまだ高級なプログラミング言語はほとんどなく、if else, whileなどのIBMの提唱した構造化プログラミングを可能にする文法を提供しているプログラミング言語すら、多くは研究段階であった。いわんやオブジェクト指向など、当時はまだアカデミックにおいて可能性の一つとして研究されている程度の地に足のついていない夢の機能であった。そのような粗野な時代において、Simulaは先進的なオブジェクト指向プログラミングを実現していた。</p>
<p>問題は、Simulaの設計と実装では実行速度が遅く、大規模なプログラムを開発するには適さなかった。</p>
<p>Cの効率性と柔軟性というのは、要するに実行速度が速いとかメモリ消費量が少ないということだ。なぜCは他の言語に比べて効率と柔軟に優れているのか。これには2つの理由がある。</p>
<p>ひとつ、Cのコードは直接ハードウェアがサポートする命令にまでマッピング可能であるということ。現実のハードウェアにはストレージがあり、メモリがあり、キャッシュがあり、レジスターがあり、命令は投機的に並列実行される泥臭い計算機能を提供している。</p>
<p>ひとつ、使わない機能のコストを支払う必要がないというゼロオーバーヘッドの原則。例えばあらゆるメモリ利用がGCによって管理されている言語では、たとえメモリをすべて明示的に管理していたとしても、GCのコストを支払わなければならない。実行時にメモリレイアウトを判定して実行時に分岐処理ができる言語では、たとえコンパイル時にメモリレイアウトが決定されていたとしても、実行時にメモリレイアウトを判定して条件分岐するコストを支払わなければならない。</p>
<p>C++は、「アセンブリ言語をおいて、C++より下に言語を置かない」と宣言するほど、ハードウェア機能への直接マッピングとゼロオーバーヘッドの原則を重視している。</p>
<p>C++の他の特徴としては、委員会方式による国際標準規格を定めていることがある。特定の一個人や一法人が所有する言語は、個人や法人の意思で簡単に仕様が変わってしまう。短期的な利益を追求するために長期的に問題となる変更をしたり、単一の実装が仕様だと言わんばかりの振る舞いをする。特定の個人や法人に所有されていないこと、実装が従うべき標準規格があること、独立した実装が複数あること、言語に利害関係を持つ関係者が議論して投票で変更を可決すること、これがC++が長期に渡って使われてきた理由でもある。</p>
<p>委員会方式の規格制定では、下位互換性の破壊は忌避される。なぜならば、既存の動いているコードを壊すということは、それまで存在していた資産の価値を毀損することであり、利害関係を持つ委員が反対するからだ。</p>
<p>下位互換性を壊した結果何が起こるかと言うと、単に言語が新旧2つに分断される。Python 2とPython 3がその最たる例だ。</p>
<p>C++には今日の最新で高級な言語からみれば古風な制約が数多く残っているが、いずれも理由がある。下位互換性を壊すことができないという理由。効率的な実装方法が存在しないという理由。仮に効率的な実装が存在するにしても、様々な環境で実装可能でなければ規格化はできないという理由。</p>
<p>C++には良し悪しがある。Bjarne StroustrupはC++への批判にこう答えている。</p>
<blockquote>
<p>言語には2種類ある。文句を言われる言語と、誰も使わない言語。</p>
</blockquote>
<p>C++は文句を言われる方の言語だ。</p>
<h1 id="cの実行">C++の実行</h1>
<p>プログラミング言語を学ぶには、まず書いたソースコードをプログラムとして実行できるようになることが重要だ。自分が正しく理解しているかどうかを確認するために書いたコードが期待通りに動くことを確かめてこそ、正しい理解が確認できる。</p>
<h2 id="cの実行の仕組み">C++の実行の仕組み</h2>
<p>C++は慣習的に、ソースファイルをコンパイルしてオブジェクトファイルを生成し、オブジェクトファイルをリンクして実行可能ファイルを生成し、実行可能ファイルを直接実行することで実行する言語だ。</p>
<p>他の言語では、ソースファイルをそのままパースし、解釈して実行するインタープリター形式の言語が多い。もっとも、今となってはソースファイルから中間言語に変換してVMで実行するとか、JITコンパイルしてネイティブコードを生成して実行するといった実装もあるため、昔のように単純にインタープリター型の言語ということはできなくなっている事情はある。ただし、最終的にJITコンパイルされてネイティブコードが実行される言語でも、コンパイルやコード生成はプログラマーが意識しない形で行われるため、プログラマーはコンパイラーを直接使う必要のない言語も多い。</p>
<p>C++はプログラマーが直接コンパイラーを使い、ソースファイルをプログラムに変換する言語だ。</p>
<h2 id="簡単な一つのソースファイルからなるプログラムの実行">簡単な一つのソースファイルからなるプログラムの実行</h2>
<p>ここでは、典型的なC++のソースファイルをどのようにコンパイルし実行するか、一連の流れを学ぶ。</p>
<h3 id="サンプルコード">サンプルコード</h3>
<p>以下のC++のソースファイルは標準出力にhelloと出力するものだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span>

<span class="dt">int</span> main()
{
    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;hello&quot;</span> ;
}</code></pre></div>
<p>コードの詳細な意味はさておくとして、このサンプルコードを使ってC++の実行までの流れを見ていこう。</p>
<p>まずは端末から作業用の適当な名前のディレクトリーを作る。ここでは<code>cpp</code>としておこう。ディレクトリーの作成は<code>mkdir</code>コマンドで行える。</p>
<pre><code>$ mkdir cpp
$ cd cpp</code></pre>
<p>好きなテキストエディターを使って上のサンプルコードをテキストファイルとして記述する。ファイル名は<code>hello.cpp</code>としておこう。</p>
<pre><code>$ vim hello.cpp</code></pre>
<p>C++のソースファイルの名前は何でもよいが、慣習で使われている拡張子がいくつかある。本書では<code>.cpp</code>を使う。</p>
<p>無事にソースファイルが作成できたかどうか確認してみよう。</p>
<pre><code>$ ls
hello.cpp
$ cat hello.cpp
#include &lt;iostream&gt;

int main()
{
    std::cout &lt;&lt; &quot;hello&quot; ;
}</code></pre>
<h3 id="コンパイル">コンパイル</h3>
<p>さて、ソースファイルが用意できたならば、いよいよコンパイルだ。</p>
<p>C++のソースファイルから、実行可能ファイルを生成するソフトウェアをC++コンパイラーという。C++コンパイラーとしては、GCC(GNU Compiler Collection)とClang(クラン)がある。使い方はどちらもほぼ同じだ。</p>
<p>GCCを使って先程の<code>hello.cpp</code>をコンパイルするには以下のようにする。</p>
<pre><code>$ g++ -o hello hello.cpp</code></pre>
<p>GCCという名前のC++コンパイラーなのに<code>g++</code>なのは、<code>gcc</code>はC言語コンパイラーの名前としてすでに使われているからだ。この慣習はClangも引き継いでいて、ClangのC++コンパイラーは<code>clang++</code>だ。</p>
<p>サンプルコードを間違いなくタイプしていれば、カレントディレクトリに<code>hello</code>とぃう実行可能ファイルが作成されるはずだ。確認してみよう。</p>
<pre><code>$ ls
hello hello.cpp</code></pre>
<h3 id="実行">実行</h3>
<p>さて、いよいよ実行だ。通常のOSではカレントディレクトリがPATHに含まれていないため、実行するにはカレントディレクトリからパスを指定する必要がある。</p>
<pre><code>$ ./hello
hello</code></pre>
<p>上出来だ。初めてのC++プログラムが実行できた。さっそくC++を学んでいきたいところだが、その前にC++プログラミングに必要なツールの使い方を学ぶ必要がある。</p>
<h2 id="gcc-cコンパイラー">GCC: C++コンパイラー</h2>
<p>GCCはC++のソースファイルからプログラムを生成するC++コンパイラーだ。</p>
<p>GCCの基本的な使い方は以下の通り。</p>
<pre><code>g++ その他のオプション -o 出力するファイル名 ソースファイル名</code></pre>
<p>ソースファイル名は複数指定することができる。</p>
<pre><code>g++ -o abc a.cpp b.cpp c.cpp</code></pre>
<p>これについては分割コンパイルの章で詳しく解説する。</p>
<p>コンパイラーはメッセージを出力することがある。コンパイルメッセージには、エラーメッセージと警告メッセージとがある。</p>
<p>エラーメッセージというのは、ソースコードに文法上、意味上の誤りがあるため、コンパイルできない場合に生成される。エラーメッセージはエラーの箇所も教えてくれる。ただし、文法エラーは往々にして適切な誤りの箇所を指摘できないこともある。これは、C++の文法としては正しくないテキストファイルから、妥当なC++であればどういう間違いなのかを推測する必要があるためだ。</p>
<p>警告メッセージというのは、ソースコードにコンパイルを妨げる文法上、意味上の誤りは存在しないが、誤りの可能性が疑われる場合に出力される。</p>
<h3 id="コンパイラーオプション">コンパイラーオプション</h3>
<p>GCCのコンパイラーオプションをいくつか学んでいこう。</p>
<p><code>-std=</code>はC++の規格を選択するオプションだ。C++17に準拠したいのであれば<code>-std=c++17</code>を指定する。読者が本書を読む頃には、C++20や、あるいはもっと未来の規格が発行されているかもしれない。常に最新のC++規格を選択するオプションを指定するべきだ。</p>
<p><code>-Wall</code>はコンパイラーの便利な警告メッセージのほとんどすべてを有効にするオプションだ。コンパイラーによる警告メッセージはプログラムの不具合を未然に発見できるので、このオプションは指定すべきだ。</p>
<p><code>--pedantic-errors</code>はC++の規格を厳格に守るオプションだ。規格に違反しているコードがコンパイルエラー扱いになる。</p>
<p>これをまとめると、GCCは以下のように使う。</p>
<pre><code>g++ -std=c++17 -Wall --pedantic-errors -o 出力ファイル名 入力ファイル名</code></pre>
<p>ところで、GCCのオプションはとても多い。すべてを知りたい読者は、gccのマニュアルを読むとよい。</p>
<pre><code>$ man gcc</code></pre>
<h3 id="ヘッダーファイルの省略">ヘッダーファイルの省略</h3>
<p>先程のソースコードをもう一度見てみよう。冒頭に以下のような行がある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></code></pre></div>
<p>これは<code>#includeディレクティブ</code>(#include directive)といい、プリプロセッサー(preprocessor)の一部だ。プリプロセッサーについて詳しくは煩雑になるので巻末資料を参照してもらうとして、このコードは<code>iostream</code>ライブラリを使うために必要で、その意味としてはヘッダーファイル<code>iostream</code>を取り込みだ。</p>
<p>C++の標準ライブラリを使うには、ライブラリごとに対応した<code>#includeディレクティブ</code>を書かなければならない。それはあまりにも煩雑なので、本書では標準ライブラリのヘッダーファイルをすべて<code>#include</code>した<code>ヘッダーファイル</code>(header file)を作成し、それを<code>#include</code>することで、<code>#include</code>を書かなくてすむようにする。</p>
<p>そのためにはまず標準ライブラリのヘッダーファイルのほとんどすべてを<code>#include</code>したヘッダーファイル、<code>all.h</code>を作成する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&lt;cstddef&gt;</span>
<span class="pp">#include </span><span class="im">&lt;limits&gt;</span>
<span class="pp">#include </span><span class="im">&lt;climits&gt;</span>
<span class="pp">#include </span><span class="im">&lt;cfloat&gt;</span>
<span class="pp">#include </span><span class="im">&lt;cstdint&gt;</span>
<span class="pp">#include </span><span class="im">&lt;cstdlib&gt;</span>
<span class="pp">#include </span><span class="im">&lt;new&gt;</span>
<span class="pp">#include </span><span class="im">&lt;typeinfo&gt;</span>
<span class="pp">#include </span><span class="im">&lt;exception&gt;</span>
<span class="pp">#include </span><span class="im">&lt;initializer_list&gt;</span>
<span class="pp">#include </span><span class="im">&lt;cstdalign&gt;</span>
<span class="pp">#include </span><span class="im">&lt;stdexcept&gt;</span>
<span class="pp">#include </span><span class="im">&lt;cassert&gt;</span>
<span class="pp">#include </span><span class="im">&lt;cerrno&gt;</span>
<span class="pp">#include </span><span class="im">&lt;system_error&gt;</span>
<span class="pp">#include </span><span class="im">&lt;string&gt;</span>

<span class="pp">#if __has_include(&lt;string_view&gt;)</span>
<span class="pp">#   include </span><span class="im">&lt;string_view&gt;</span>
<span class="pp">#endif</span>

<span class="pp">#include </span><span class="im">&lt;array&gt;</span>
<span class="pp">#include </span><span class="im">&lt;deque&gt;</span>
<span class="pp">#include </span><span class="im">&lt;forward_list&gt;</span>
<span class="pp">#include </span><span class="im">&lt;list&gt;</span>
<span class="pp">#include </span><span class="im">&lt;vector&gt;</span>
<span class="pp">#include </span><span class="im">&lt;map&gt;</span>
<span class="pp">#include </span><span class="im">&lt;set&gt;</span>
<span class="pp">#include </span><span class="im">&lt;unordered_map&gt;</span>
<span class="pp">#include </span><span class="im">&lt;unordered_set&gt;</span>
<span class="pp">#include </span><span class="im">&lt;queue&gt;</span>
<span class="pp">#include </span><span class="im">&lt;stack&gt;</span>
<span class="pp">#include </span><span class="im">&lt;iterator&gt;</span>
<span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span>
<span class="pp">#include </span><span class="im">&lt;cfenv&gt;</span>
<span class="pp">#include </span><span class="im">&lt;random&gt;</span>
<span class="pp">#include </span><span class="im">&lt;numeric&gt;</span>
<span class="pp">#include </span><span class="im">&lt;cmath&gt;</span>
<span class="pp">#include </span><span class="im">&lt;iosfwd&gt;</span>
<span class="pp">#include </span><span class="im">&lt;iostream&gt;</span>
<span class="pp">#include </span><span class="im">&lt;ios&gt;</span>
<span class="pp">#include </span><span class="im">&lt;streambuf&gt;</span>
<span class="pp">#include </span><span class="im">&lt;istream&gt;</span>
<span class="pp">#include </span><span class="im">&lt;ostream&gt;</span>
<span class="pp">#include </span><span class="im">&lt;iomanip&gt;</span>
<span class="pp">#include </span><span class="im">&lt;sstream&gt;</span>
<span class="pp">#include </span><span class="im">&lt;fstream&gt;</span>

<span class="pp">#if __has_include(&lt;filesystem&gt;)</span>
<span class="pp">#   include </span><span class="im">&lt;filesystem&gt;</span>
<span class="pp">#endif</span>

<span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span>
<span class="pp">#include </span><span class="im">&lt;cinttypes&gt;</span>


<span class="pp">#include </span><span class="im">&lt;regex&gt;</span>
<span class="pp">#include </span><span class="im">&lt;atomic&gt;</span>
<span class="pp">#include </span><span class="im">&lt;thread&gt;</span>
<span class="pp">#include </span><span class="im">&lt;mutex&gt;</span>
<span class="pp">#include </span><span class="im">&lt;shared_mutex&gt;</span>
<span class="pp">#include </span><span class="im">&lt;condition_variable&gt;</span>
<span class="pp">#include </span><span class="im">&lt;future&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>literals ;</code></pre></div>
<p>このようなヘッダーファイル<code>all.h</code>を作成した後に、ソースファイルで以下のように書けば、他のヘッダーファイルを<code>#include</code>する必要がなくなる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&quot;all.h&quot;</span>

<span class="co">// その他のコード</span></code></pre></div>
<p><code>//</code>から行末まではコメントで、好きなテキストを書くことができる。</p>
<p>しかし、この最初の一行の<code>#include</code>も面倒だ。そこでGCCのオプション<code>-include</code>を使い、<code>all.h</code>を常に<code>#include</code>した扱いにする。</p>
<pre><code>$ g++ -include all.h -o program main.cpp</code></pre>
<p>このようにすると、<code>main.cpp</code>が以下のコードでもコンパイルできるようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// main.cpp</span>
<span class="co">// 面倒な#includeなどなし</span>

<span class="dt">int</span> main()
{
    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;hello&quot;</span> ;
}</code></pre></div>
<p>これでヘッダーファイルが省略できるようになった。</p>
<h3 id="コンパイル済みヘッダーprecompiled-header">コンパイル済みヘッダー(precompiled header)</h3>
<p>C++はソースファイルをコンパイルする必要がある言語だ。コンパイルには時間がかかる。コンパイルにどれだけ時間がかかっているかを計測するには、以下のようにするとよい。</p>
<pre><code>$ time g++ -std=c++17 -Wall --pedantic-errors -include all.h -o program main.cpp</code></pre>
<p>どうだろうか。読者の環境にもよるが、近くできるぐらいの時間がかかっているのではないだろうか。プログラミングの習得にはコードを書いてから実行までの時間が短い方がよい。そこで本格的にC++を学ぶ前に、コンパイル時間を短縮する方法を学ぶ。</p>
<p>プログラムで変更しないファイルを事前にコンパイルしておくと、変更した部分だけコンパイルすれば良いので、コンパイル時間の短縮になる。GCCでは、ヘッダーファイルを事前にコンパイルする特別な機能がある。標準ライブラリのヘッダーファイルは変更しないので、事前にコンパイルしておけばコンパイル時間の短縮になる。</p>
<p>事前にコンパイルしたヘッダーファイルのことをコンパイル済みヘッダー(precompiled header)という。</p>
<p>すでに作成した<code>all.h</code>はコンパイル済みヘッダーとするのに適切なヘッダーファイルだ。</p>
<p>コンパイル済みヘッダーファイルを作成するには、ヘッダーファイル単体をGCCに与え、出力するファイルを<code>ヘッダーファイル名.gch</code>とする。ヘッダーファイル名が<code>all.h</code>の場合、<code>all.h.gch</code>となる。</p>
<p>GCCのオプションには他のソースファイルをコンパイルするときと同じオプションを与えるほか、ヘッダーファイルがC++で書かれていることを示すオプション<code>-x c++-header</code>を与える。</p>
<pre><code>g++ -std=c++17 -Wall --pedantic-errors -x c++-header -o all.h.gch all.h</code></pre>
<p>こうすると、コンパイル済みヘッダーファイル<code>all.h.gch</code>が生成できる。</p>
<p>GCCはヘッダーファイルを使うときに、同名の.gchファイルが存在する場合は、そちらをコンパイル済みヘッダーファイルとして使うことで、ヘッダーファイルの処理を省略する。</p>
<pre><code>g++ -std=c++17 -Wall --pedantic-errors -include all.h -o program main.cpp</code></pre>
<p>コンパイル済みヘッダーは一回のコンパイルにつき一つしか使うことができない。そのため、コンパイル済みヘッダーとするヘッダーファイルを定め、そのヘッダーファイル内に他のヘッダーをすべて記述する。本書ではコンパイル済みヘッダーファイルとする元のヘッダーファイルの名前を<code>all.h</code>とする。</p>
<p>さっそくコンパイル時間の短縮効果を確かめてみよう。</p>
<pre><code>$ ls
all.h main.cpp
$ g++ -std=c++17 -Wall --pedantic-errors -x c++-header -o all.h.gch all.h
$ ls
all.h all.h.gch main.cpp
$ time g++ -std=c++17 -Wall --pedantic-errors -include all.h -o program main.cpp</code></pre>
<h2 id="make-ビルドシステム">Make: ビルドシステム</h2>
<h3 id="コンパイルと実行のまとめ">コンパイルと実行のまとめ</h3>
<p>ここまで、我々はソースファイルをコンパイルして実行可能ファイルを生成し、プログラムを実行する方法について学んできた。これまでに学んできたことを一連のコマンドで振り返ってみよう。</p>
<pre><code>$ ls
all.h main.cpp
$ cat all.h
#include &lt;iostream&gt;
$ cat main.cpp
int main() { std::cout &lt;&lt; &quot;hello&quot;s ; }</code></pre>
<p>まず、カレントディレクトリには<code>all.h</code>と<code>main.cpp</code>がある。この2つのファイルは実行可能ファイルを生成するために必要なファイルだ。今回、その中身は最小限にしてある。本当の<code>all.h</code>は、実際には前回書いたように長い内容になる。</p>
<pre><code>$ g++ -std=c++17 -Wall --pedantic-errors -x c++-header -o all.h.gch all.h
$ ls
all.h all.h.gch main.cpp</code></pre>
<p>次に、ソースファイルのコンパイルを高速化するために、ヘッダーファイル<code>all.h</code>から、コンパイル済みヘッダーファイル<code>all.h.gch</code>を生成する。</p>
<pre><code>$ g++ -std=c++17 -Wall --pedantic-errors -include all.h -o program main.cpp
$ ls
all.h all.h.gch main.cpp program</code></pre>
<p>プリコンパイル済みヘッダーファイル<code>all.h.gch</code>とC++ソースファイル<code>main.cpp</code>から、実行可能ファイル<code>program</code>を生成する。</p>
<pre><code>$ ./program
hello</code></pre>
<p>実行可能ファイル<code>program</code>を実行する。</p>
<p>これで読者はC++のプログラミングを学び始めるに当たって必要なことは全て学んだ。さっそくC++を学んでいきたいところだが、その前にもう一つ、ビルドシステムを学ぶ必要がある。</p>
<h3 id="依存関係を解決するビルドシステム">依存関係を解決するビルドシステム</h3>
<p>以上のC++のソースファイルからプログラムを実行するまでの流れは、C++のプログラムとしてはとても単純なものだが、それでも依存関係が複雑だ。</p>
<p>プログラムの実行にあたって最終的に必要なのはファイル<code>program</code>だが、このファイルはGCCで生成しなければならない。ところでGCCでファイル<code>program</code>を生成するには、事前に<code>all.h</code>, <code>all.h.gch</code>, <code>main.cpp</code>が必要だ。<code>all.h.gch</code>は<code>all.h</code>からGCCで生成しなければならない。</p>
<p>一度コンパイルしたプログラムのソースファイルを書き換えて再びコンパイルする場合はどうすればいいだろう。<code>main.cpp</code>だけを書き換えた場合、<code>all.h</code>は何も変更されていないので、コンパイル済みヘッダーファイル<code>all.h.gch</code>の再生性は必要ない。<code>all.h</code>だけを書き換えた場合は、<code>all.h.gch</code>を生成するだけでなく、<code>program</code>も再生成しなければならない。</p>
<p>プログラムのコンパイルには、このような複雑な依存関係の解決が必要になる。依存関係の解決を人間の手で行うのは大変だ。例えば読者が他人によって書かれた何千ものソースファイルと、プログラムをコンパイルする手順書だけを渡されたとしよう。手順書に従ってコンパイルをしたとして、ソースファイルの一部だけを変更した場合、一体どの手順は省略できるのか、手順書から導き出すのは難しい。するとコンパイルを最初からやり直すべきだろうか。しかし、一つのソースファイルのコンパイルに1秒かかるとして、何千ものソースファイルがある場合、何千秒もかかってしまう。たった一つのソースファイルを変更しただけですべてをコンパイルし直すのは時間と計算資源の無駄だ。</p>
<p>この依存関係の問題は、ビルドシステムによって解決できる。本書ではGNU Makeというビルドシステムを学ぶ。読者がこれから学ぶビルドシステムによって、以下のような簡単なコマンドだけで、他人の書いた何千ものソースファイルからなるプログラムがコンパイル可能になる。</p>
<p>何千ものソースファイルから実行可能ファイルを生成したい。</p>
<pre><code>$ make</code></pre>
<p>これだけだ。<code>make</code>というコマンド一つでプログラムのコンパイルは自動的に行われる。</p>
<p>何千ものソースファイルのうち、一つのソースファイルだけを変更し、必要な部分だけを効率よく再コンパイルしたい。</p>
<pre><code>$ make</code></pre>
<p>これだけだ。<code>make</code>というコマンド一つでプログラムの再コンパイルは自動的に行われる。</p>
<p>ところで、生成される実行可能ファイルの名前はプログラムごとに様々だ。プログラムの開発中は、共通の方法でプログラムを実行したい。</p>
<pre><code>$ make run</code></pre>
<p>これでどんなプログラム名でも共通の方法で実行できる。</p>
<p>ソースファイルから生成されたプログラムなどのファイルをすべて削除したい。</p>
<pre><code>$ make clean</code></pre>
<p>これで生成されたファイルをすべて削除できる</p>
<p>テキストエディターにはVimを使っているがわざわざVimからターミナルに戻るのが面倒だ。</p>
<pre><code>:make</code></pre>
<p>VimはノーマルモードからMakeを呼び出すことができる。もちろん、<code>:make run</code>や<code>:make clean</code>もできる</p>
<h3 id="依存関係を記述するルール">依存関係を記述するルール</h3>
<p>依存関係はどのように表現したらいいのだろうか。GNU makeでは<code>Makefile</code>という名前のファイルの中に、<code>ターゲット'(targets)、</code>事前要件<code>(prerequisites)、</code>レシピ<code>(recipes)という3つの概念で依存関係を</code>ルール<code>(rules)として記述する。</code>ルール`は以下の文法だ。</p>
<pre><code>ターゲット : 事前要件
[TAB文字]レシピ</code></pre>
<p>レシピは必ず<code>TAB文字</code>を直前に書かなければならない。スペース文字ではだめだ。これは<code>make</code>の初心者を混乱させる落とし穴の一つとなっている。忘れずに<code>TAB文字</code>を打とう。</p>
<p>問題を簡単に理解するために、以下のような状況を考えよう。</p>
<pre><code>$ ls
source
$ cat source &gt; program</code></pre>
<p>この例では、ファイル<code>program</code>を生成するためにはファイル<code>source</code>が必要だ。ファイル<code>source</code>はすでに存在している。</p>
<p><code>ターゲット</code>は生成されるファイル名だ。この場合<code>program</code>となる。</p>
<pre><code>program : 事前要件
    レシピ</code></pre>
<p><code>事前要件</code>は<code>ターゲット</code>を生成するために必要なファイル名だ。この場合<code>source</code>となる。</p>
<pre><code>program : source
    レシピ</code></pre>
<p><code>レシピ</code>は<code>ターゲット</code>を生成するために必要な動作だ。この場合、<code>cat source &gt; program</code>となる</p>
<div class="sourceCode"><pre class="sourceCode makefile"><code class="sourceCode makefile"><span class="dv">program :</span><span class="dt"> source</span>
    cat source &gt; program</code></pre></div>
<p>さっそくこのルールを、ファイル<code>Makefile</code>に書き込み、makeを呼び出してみよう。</p>
<pre><code>$ ls
Makefile source 
$ cat Makefile
program : source
    cat source &gt; program
$ make
cat source &gt; program
$ ls
Makefile program source</code></pre>
<p>これがMakeの仕組みだ。<code>ターゲット</code>の生成に必要な<code>事前要件</code>と、<code>ターゲット</code>を生成する<code>レシピ</code>を組み合わせた<code>ルール</code>で依存関係を記述する。makeを実行すると、実行した<code>レシピ</code>が表示される。</p>
<p>もうすこしMakeの<code>ルール</code>を追加してみよう。例えばファイル<code>source</code>は予め存在するのではなく、ファイル<code>source01</code>, <code>source02</code>, <code>source03</code>の中身をこの順番で連結して生成するとしよう。以下のように書ける。</p>
<div class="sourceCode"><pre class="sourceCode makefile"><code class="sourceCode makefile"><span class="dv">program :</span><span class="dt"> source</span>
    cat source &gt; program

<span class="dv">source :</span><span class="dt"> source01 source02 source03</span>
    cat source01 source02 source03 &gt; source</code></pre></div>
<p>GNU Makeはカレントディレクトリにあるファイル<code>Makefile</code>の一番上に書かれたルールを実行しようとする。<code>program</code>を生成するには<code>source</code>が必要だが、<code>source</code>の生成には別のルールの実行が必要だ。Makefileはこの依存関係を自動で解決してくれる。</p>
<pre><code>$ touch source01 source02 source03
$ ls
Makefile source01 source03 source03
$ make
cat source01 source02 source03 &gt; source
cat source &gt; program
$ ls
Makefile program source source01 source02 source03</code></pre>
<p>すでに<code>make</code>を実行した後で、もう一度<code>make</code>を実行するとどうなるだろうか。</p>
<pre><code>$make
make: &#39;program&#39; is up to date.</code></pre>
<p>このメッセージの意味は「programは最新だ」という意味だ。<code>make</code>はファイルのタイムスタンプを調べ、もしファイル<code>program</code>より<code>source</code>のタイムスタンプの方が若い場合、つまり<code>program</code>が変更されたよりも後に<code>source</code>が変更された場合、<code>ルール</code>を実行する。</p>
<p>ためしにファイル<code>source02</code>のタイムスタンプを更新してみよう。</p>
<pre><code>$ touch source02
$ make
cat source01 source02 source03 &gt; source
cat source &gt; program</code></pre>
<p>ファイル<code>source</code>は<code>事前要件</code>に<code>source02</code>を含む。<code>source02</code>のタイムスタンプが<code>source</code>より若いので、<code>source</code>が再び生成される。すると、<code>source</code>のタイムスタンプが<code>program</code>のタイムスタンプよりも若くなったので、<code>program</code>も生成される。</p>
<p>もう一つ例を見てみよう。</p>
<pre><code>$ touch a b c
$ ls
a b c Makefile</code></pre>
<p>あるディレクトリにファイル<code>a</code>, <code>b</code>, <code>c</code>がある。</p>
<p><code>Makefile</code>は以下の内容になっている。</p>
<pre><code>D : A B C
    cat A B C &gt; D

A : a
    cat a &gt; A

B : b
    cat b &gt; B

C : c
    cat c &gt; C</code></pre>
<p>この<code>Makefile</code>を呼び出したときに作られるのはファイル<code>D</code>だ。ファイル<code>D</code>を作るにはファイル<code>A</code>, <code>B</code>, <code>C</code>が必要だ。このファイルはそれぞれファイル<code>a</code>, <code>b</code>, <code>c</code>から生成されるルールが記述してある。</p>
<p>これを<code>make</code>すると以下のようにファイル<code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>が作られる。</p>
<pre><code>$ ls
a b c Makefile
$ make
cat a &gt; A
cat b &gt; B
cat c &gt; C
cat A B C &gt; D</code></pre>
<p>ここで、ファイル<code>b</code>のタイムスタンプだけを更新して<code>make</code>してみよう。</p>
<pre><code>$ touch b
$ make
cat b &gt; B
cat A B C &gt; D</code></pre>
<p>ファイル<code>b</code>のタイムスタンプがファイル<code>B</code>より若くなったので、ファイル<code>B</code>がターゲットとなったルールが再び実行される。ファイル<code>A</code>, <code>C</code>のルールは実行されない。そしてファイル<code>B</code>のタイムスタンプがファイル<code>D</code>より若くなったので、ファイル<code>D</code>がターゲットとなったルールが再び実行される。</p>
<p><code>make</code>により、処理する必要のあるルールだけが部分的に処理されていることがわかる。</p>
<p><code>make</code>は適切な<code>ルール</code>さえ書けば、依存関係の解決を自動的に行ってくれる。</p>
<h3 id="コメント">コメント</h3>
<p><code>Makefile</code>にはコメントを書くことができる。<code>#</code>で始まる行はコメント扱いされる。</p>
<div class="sourceCode"><pre class="sourceCode makefile"><code class="sourceCode makefile"><span class="co"># programを生成するルール</span>
<span class="dv">program :</span><span class="dt"> source</span>
    cat source &gt; program

<span class="co"># sourceを生成するルール</span>
<span class="dv">source :</span><span class="dt"> source01 source02 source03</span>
    cat source01 source02 source03 &gt; source</code></pre></div>
<h3 id="変数">変数</h3>
<p><code>Makefile</code>には<code>変数</code>を書くことができる。</p>
<p>変数の文法は以下の通り</p>
<pre><code>variable = foobar

target : $(variable)</code></pre>
<p>これは、</p>
<pre><code>target : foobar</code></pre>
<p>と書いたものと同じように扱われる。</p>
<p>変数は<code>=</code>の左側に変数名、右側に変数の内容を書く。</p>
<p>変数を使うときは、<code>$(変数名)</code>のように、<code>$()</code>で変数名を包む。</p>
<h3 id="自動変数">自動変数</h3>
<p>GNU Makeは便利なことに、いくつかの変数を自動で作ってくれる。</p>
<h4 id="ターゲット"><code>$@</code> ターゲット</h4>
<p><code>$@</code>はルールのターゲットのファイル名になる。</p>
<div class="sourceCode"><pre class="sourceCode makefile"><code class="sourceCode makefile"><span class="dv">target :</span>
    echo <span class="ch">$@</span></code></pre></div>
<p>このMakefileを実行すると以下のように出力される。</p>
<pre><code>$ make
echo target</code></pre>
<h4 id="最初の事前要件"><code>$&lt;</code> 最初の事前要件</h4>
<p><code>$&lt;</code>はルールの最初の事前要件のファイル名になる。</p>
<div class="sourceCode"><pre class="sourceCode makefile"><code class="sourceCode makefile"><span class="dv">target :</span><span class="dt"> A B C</span>
    echo <span class="ch">$&lt;</span></code></pre></div>
<p>このMakefileを実行すると以下のように出力される。</p>
<pre><code>$ make
echo A</code></pre>
<h4 id="すべての事前要件"><code>$^</code> すべての事前要件</h4>
<p><code>$^</code>はすべての事前要件のファイル名が空白区切りされたものになる</p>
<div class="sourceCode"><pre class="sourceCode makefile"><code class="sourceCode makefile"><span class="dv">target :</span><span class="dt"> A B C</span>
    echo <span class="ch">$^</span></code></pre></div>
<p>このMakefileを実行すると以下のように出力される。</p>
<pre><code>$ make
echo A B C</code></pre>
<h4 id="自動変数の組み合わせ">自動変数の組み合わせ</h4>
<p>例えば<code>ターゲット</code>を生成するために<code>事前要件</code>と<code>ターゲット</code>のファイル名をレシピに書く場合、</p>
<div class="sourceCode"><pre class="sourceCode makefile"><code class="sourceCode makefile"><span class="dv">target :</span><span class="dt"> prerequisite</span>
    cat prerequisite &gt; target</code></pre></div>
<p>と書く代わりに、</p>
<div class="sourceCode"><pre class="sourceCode makefile"><code class="sourceCode makefile"><span class="dv">target :</span><span class="dt"> prerequisite</span>
    cat <span class="ch">$&lt;</span> &gt; <span class="ch">$@</span></code></pre></div>
<p>と書ける。</p>
<h3 id="phonyターゲット">PHONYターゲット</h3>
<p>PHONYターゲットとは、ファイル名を意味せず、単にレシピを実行するターゲット名としてのみ機能するターゲットのことだ。</p>
<div class="sourceCode"><pre class="sourceCode makefile"><code class="sourceCode makefile"><span class="dv">hi :</span>
    echo hi

<span class="dv">hello :</span>
    echo hello</code></pre></div>
<p>これを実行すると以下のようになる。</p>
<pre><code>$ make
echo hi
hi
$make hi
echo hi
hi
$ make hello
echo hello
hello</code></pre>
<p><code>make</code>を引数を付けずに実行すると、一番上に書かれたルールが実行される。引数としてターゲットを指定すると、そのターゲットのルールと、依存するルールが実行される。</p>
<p>ただし、ターゲットと同じファイル名が存在すると、ルールは実行されない。</p>
<pre><code>$ touch hello
$ make hello
make: &#39;hello&#39; is up to date.</code></pre>
<p>GNU makeはこの問題に対処するため、<code>.PHONY</code>ターゲットという特殊な機能がある。これはPHONYターゲットを<code>.PHONY</code>ターゲットの事前要件とすることで、ターゲットと同じファイル名の存在の有無にかかわらずルールを実行させられる。</p>
<div class="sourceCode"><pre class="sourceCode makefile"><code class="sourceCode makefile"><span class="dv">hello :</span>
    echo hello

<span class="ot">.PHONY</span> <span class="ot">:</span><span class="dt"> hello</span></code></pre></div>
<p>PHONYターゲットはコンパイルしたプログラムの実行や削除に使うことができる。</p>
<div class="sourceCode"><pre class="sourceCode makefile"><code class="sourceCode makefile"><span class="dv">hello :</span><span class="dt"> hello.cpp</span>
    g++ -o <span class="ch">$@</span> <span class="ch">$&lt;</span>

<span class="dv">run :</span><span class="dt"> hello</span>
    ./hello

<span class="dv">clean :</span>
    rm -rf ./hello

<span class="ot">.PHONY</span> <span class="ot">:</span><span class="dt"> run clean</span></code></pre></div>
<h2 id="入門用の環境構築">入門用の環境構築</h2>
<p>以上を踏まえて、C++入門用の環境構築をしてこの章のまとめとする。</p>
<p>今回構築する環境のファイル名とその意味は以下の通り。</p>
<dl>
<dt>main.cpp</dt>
<dd>C++のコードを書く all.h
</dd>
<dd>標準ライブラリのヘッダーファイルを書く all.h.gch
</dd>
<dd>コンパイル済みヘッダー program
</dd>
<dd>実行可能ファイル Makefile
</dd>
<dd>GNU makeのルールを書く
</dd>
</dl>
<p>使い方は以下の通り。</p>
<dl>
<dt>make</dt>
<dd>コンパイルする make run
</dd>
<dd>コンパイルして実行 make clean
</dd>
<dd>コンパイル結果を削除
</dd>
</dl>
<p>GCCに与えるコンパイラーオプションを変数にまとめる。</p>
<div class="sourceCode"><pre class="sourceCode makefile"><code class="sourceCode makefile"><span class="dt">gcc_options </span><span class="ch">=</span><span class="st"> -std=c++17 -Wall --pedantic-error</span></code></pre></div>
<p>言語はC++17、すべての警告を有効にし、企画準拠ではないコードはエラーとする。</p>
<p>プログラムをコンパイルする部分は以下の通り。</p>
<div class="sourceCode"><pre class="sourceCode makefile"><code class="sourceCode makefile"><span class="dv">program :</span><span class="dt"> main.cpp all.h all.h.gch</span>
    g++ <span class="ch">$(</span><span class="dt">gcc_options</span><span class="ch">)</span> -include all.h <span class="ch">$&lt;</span> -o <span class="ch">$@</span>

<span class="dv">all.h.gch :</span><span class="dt"> all.h</span>
    g++ <span class="ch">$(</span><span class="dt">gcc_options</span><span class="ch">)</span> -x c++-header -o <span class="ch">$@</span> <span class="ch">$&lt;</span></code></pre></div>
<p>実行可能ファイル<code>program</code>と、コンパイル済みヘッダー<code>all.h.gch</code>をコンパイルするルールだ。</p>
<p>PHONYターゲットは以下の通り。</p>
<div class="sourceCode"><pre class="sourceCode makefile"><code class="sourceCode makefile"><span class="dv">run :</span><span class="dt"> program</span>
    ./program

<span class="dv">clean :</span>
    rm -f ./program
    rm -f ./all.h.gch

<span class="ot">.PHONY</span> <span class="ot">:</span><span class="dt"> run clean</span></code></pre></div>
<p><code>make</code>でコンパイル。<code>make run</code>で実行。<code>make clean</code>でコンパイル結果の削除。</p>
<p>Makefile全体は以下のようになる。</p>
<p><sub>~</sub>makefile gcc_options = -std=c++17 -Wall --pedantic-error</p>
<p>program : main.cpp all.h all.h.gch g++ $(gcc_options) -include all.h $&lt; -o $@</p>
<p>all.h.gch : all.h g++ $(gcc_options) -x c++-header -o $@ $&lt;</p>
<p>run : program ./program</p>
<p>clean : rm -f ./program rm -f ./all.h.gch</p>
<p>.PHONY : run clean ~~</p>
<h1 id="c観光案内">C++観光案内</h1>
<p>プログラミング言語の個々の機能の解説を理解するためには、まず言語の全体像を掴まなければならない。この章ではC++の様々なコードを一通り観光していく。ここではコードの詳細な解説はしない。</p>
<h2 id="最小のコード">最小のコード</h2>
<p>以下はC++の最小のコードだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main(){}</code></pre></div>
<p>暗号のようなコードで訳がわからないが、これが最小のコードだ。<code>main</code>というのは<code>main関数</code>のことだ。C++ではプログラムの実行はmain関数から始まる。</p>
<p>ソースコードにコメントを記述して、もう少しわかりやすく書いてみよう。</p>
<pre><code>int     // 関数の戻り値の型
main    // 関数名
()      // 関数の引数
{       // 関数の始まり
    // 実行される処理
}       // 関数の終わり</code></pre>
<p><code>//</code>から行末まではコメントだ。コメントには好きなことを書くことができる。</p>
<p>このコードと一つ前のコードは、コメントの有無を別にすれば何の違いもない。このコードで使っている、<code>int</code>とか<code>main</code>とか記号文字の一つ一つをトークン(token)と呼ぶ。C++ではトークンの間に空白文字や改行文字をいくら使ってもよい。</p>
<p>なので、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main(){ }</code></pre></div>
<p>と書くこともできるし、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span>    main    (    )    {   }</code></pre></div>
<p>と書くこともできるし、紙に印刷するととても読みづらくなるかもしれないが</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span>
main
(
)
{
}</code></pre></div>
<p>と書くこともできる。</p>
<p>ただし、トークンの途中で空白文字や改行文字を使うことはできない。以下のコードは間違っている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">i
nt ma in(){}</code></pre></div>
<h2 id="標準出力">標準出力</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// helloと改行を出力するプログラム</span>
<span class="dt">int</span> main()
{
    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;hello&quot;</span>s ;
}</code></pre></div>
<p>標準出力はプログラムの基本だ。C++で標準出力する方法はいくつもあるが、&lt;iostream&gt;ライブラリを利用するものが最も簡単だ。</p>
<p><code>std::cout</code>は標準出力を使うためのライブラリだ。</p>
<p><code>&lt;&lt;</code>は<code>operator &lt;&lt;</code>という演算子だ。C++では演算子にも名前がついていて、例えば<code>+</code>は<code>operator +</code>となる。<code>&lt;&lt;</code>も演算子の一種だ。</p>
<p><code>&quot;hello&quot;s</code>というのは文字列で、二重引用符で囲まれた中の文字列が標準出力に出力される。</p>
<p>セミコロン<code>;</code>は文の区切り文字だ。C++では文の区切りは明示的にセミコロンを書く必要がある。他の言語では改行文字を文脈から判断して文の区切りとみなすこともあるが、C++では明示的に文の区切り文字としてセミコロンを書かなければならない。</p>
<p>セミコロンを書き忘れるとエラーとなる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// エラー！　セミコロンがない</span>
    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;error&quot;</span>s
}</code></pre></div>
<p>複数の文を書いてみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;one &quot;</span>s ;
    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;two &quot;</span>s ;
    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;three &quot;</span>s ;
}</code></pre></div>
<p>C++は他の多くの言語と同じように、逐次実行される。つまり、コードは書いた順番に実行される。そして標準出力のような外部への副作用は、実行された順番で出力される。このコードを実行した結果は以下の通り。</p>
<pre><code>one two three </code></pre>
<p>&quot;three two one &quot;や&quot;two one three &quot;のような出力結果にはならない。</p>
<p>C++を含む多くの言語で<code>a + b + c</code>と書けるように、<code>opeartor &lt;&lt;</code>も<code>a &lt;&lt; b &lt;&lt; c</code>と書ける。<code>operator &lt;&lt;</code>で標準出力をするには、左端は<code>std::cout</code>でなければならない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;aaa&quot;</span>s &lt;&lt; <span class="st">&quot;bbb&quot;</span>s &lt;&lt; <span class="st">&quot;ccc&quot;</span>s ;
}</code></pre></div>
<p>出力は<code>aaabbbccc</code>となる。</p>
<h2 id="文字列">文字列</h2>
<p>二重引用符で囲まれた文字列を、文字通り<code>文字列</code>という。文字列には末尾にsがつくものとつかないものがある。これには違いがあるのだが、わからないうちはsを付けておいたほうが便利だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// これは文字列</span>
    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;hello&quot;</span>s ;
    <span class="co">// これも文字列、ただし不便</span>
    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;hello&quot;</span> ;
}</code></pre></div>
<p>文字列リテラルの中にバックスラッシュを書くと、エスケープシーケンスとして扱われる。最もよく使われるのは改行文字を表す<code>\n</code>だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;aaa</span><span class="sc">\n</span><span class="st">bbb</span><span class="sc">\n</span><span class="st">ccc&quot;</span>s ;
}</code></pre></div>
<p>これは以下のように出力される。</p>
<pre><code>aaa
bbb
ccc</code></pre>
<p>バックスラッシュを文字列で使いたい場合は<code>\\</code>と書かなければならない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// </span>
    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;</span><span class="sc">\\</span><span class="st">n is a new-line.</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
}</code></pre></div>
<p>文字列は演算子<code>operator +</code>で「足す」ことができる。「文字列を足す」というのは、「文字列を結合する」という意味だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;hello&quot;</span>s + <span class="st">&quot;world&quot;</span>s ;
}</code></pre></div>
<h2 id="整数と浮動小数点数">整数と浮動小数点数</h2>
<p>iostreamは文字列の他にも、整数や浮動小数点数を出力できる。早速試してみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>cout
        &lt;&lt; <span class="st">&quot;Integer: &quot;</span>s &lt;&lt; <span class="dv">42</span> &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s
        &lt;&lt; <span class="st">&quot;Floating Point: &quot;</span>s &lt;&lt; <span class="fl">3.14</span> ;
}</code></pre></div>
<p><code>-123</code>や<code>0</code>や<code>123</code>といった数値を整数という。<code>3.14</code>のような数値を浮動小数点数という。</p>
<p>数値を扱えるのだから、計算をしてみたいところだ。C++は整数同士の演算子として、四則演算(<code>+-*/</code>)や剰余(<code>%</code>)をサポートしている</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>cout
        &lt;&lt; <span class="dv">3</span> + <span class="dv">5</span> &lt;&lt; <span class="st">&quot; &quot;</span>s &lt;&lt; <span class="dv">3</span> - <span class="dv">5</span> &lt;&lt; <span class="st">&quot; &quot;</span>s
        &lt;&lt; <span class="dv">3</span> * <span class="dv">5</span> &lt;&lt; <span class="st">&quot; &quot;</span>s &lt;&lt; <span class="dv">3</span> / <span class="dv">5</span> &lt;&lt; <span class="st">&quot; &quot;</span>s
        &lt;&lt; <span class="dv">3</span> % <span class="dv">5</span> ;
}</code></pre></div>
<p>演算子は組み合わせて使うこともできる。その場合、演算子<code>*/%</code>は演算子<code>+-</code>よりも優先される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 7</span>
    <span class="bu">std::</span>cout &lt;&lt; <span class="dv">1</span> + <span class="dv">2</span> * <span class="dv">3</span> ;
}</code></pre></div>
<p>この場合、まず<code>2*3</code>が計算され6となり、<code>1+6</code>が計算され<code>7</code>となる。</p>
<p><code>1+2</code>の法を先に計算したい場合、括弧<code>()</code>で囲むことにより、計算の優先度を帰ることができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 9</span>
    <span class="bu">std::</span>cout &lt;&lt; (<span class="dv">1</span> + <span class="dv">2</span>) * <span class="dv">3</span> ;
}</code></pre></div>
<p>これは<code>1+2</code>が先に計算され<code>3</code>となり、<code>3*3</code>が計算され<code>9</code>となる。</p>
<p>浮動小数点数同士でも四則演算ができる。剰余はできない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>cout
        &lt;&lt; <span class="fl">3.5</span> + <span class="fl">7.11</span> &lt;&lt; <span class="st">&quot; &quot;</span>s &lt;&lt; <span class="fl">3.5</span> - <span class="fl">7.11</span> &lt;&lt; <span class="st">&quot; &quot;</span>s
        &lt;&lt; <span class="fl">3.5</span> * <span class="fl">7.11</span> &lt;&lt; <span class="st">&quot; &quot;</span>s &lt;&lt; <span class="fl">3.5</span> / <span class="fl">7.11</span> ;
}</code></pre></div>
<p>では整数と浮動小数点数を演算した場合どうなるのだろう。さっそく試してみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>cout &lt;&lt; <span class="dv">1</span> + <span class="fl">0.1</span> ;
}</code></pre></div>
<p>結果は<code>1.1</code>だ。整数と浮動小数点数を演算した結果は浮動小数点数になる。</p>
<p>そういえばC++には文字列もあるのだった。文字列と文字列は足すことができる。数値と数値も足すことができる。では数値と文字列を足すとどうなるのだろう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>cout &lt;&lt; <span class="dv">1</span> + <span class="st">&quot;234&quot;</span>s ;
}</code></pre></div>
<p>この結果はエラーになる。</p>
<p>いやまて、C++には末尾にsをつけない文字列もあるのだった。これも試してみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>cout &lt;&lt; <span class="dv">1</span> + <span class="st">&quot;234&quot;</span> ;
}</code></pre></div>
<p>結果はなんと<code>34</code>になるではないか。C++では謎の数学により<code>1 + &quot;234&quot; = &quot;34&quot;</code>であることが判明した。この謎はいずれ解き明かすとして、今は文字列には必ず末尾にsをつけることにしよう。そのほうが安全だ。</p>
<h2 id="変数variable">変数(variable)</h2>
<p>さあどんどんプログラミング言語によくある機能を見ていこう。次は変数だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 整数の変数</span>
    <span class="kw">auto</span> answer = <span class="dv">42</span> ;
    <span class="bu">std::</span>cout &lt;&lt; answer &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
    <span class="co">// 浮動小数点数の変数</span>
    <span class="kw">auto</span> pi = <span class="fl">3.14</span> ;
    <span class="bu">std::</span>cout &lt;&lt; pi &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;

    <span class="co">// 文字列の変数</span>
    <span class="kw">auto</span> question = <span class="st">&quot;Life, The Universe, and Everything.&quot;</span>s ;
    <span class="bu">std::</span>cout &lt;&lt; question ;
}</code></pre></div>
<p>変数はキーワード<code>auto</code>に続いて変数名を書き、<code>=</code>に続いて値を書くことで宣言できる。変数の宣言は文なので、文末にはセミコロンが必要だ。</p>
<pre><code>auto 変数名 = 値 ;</code></pre>
<p><code>変数名</code>はキーワード、アンダースコア(_)で始まる名前、アンダースコア2つ(__)を含む名前以外は自由に名付けることができる。</p>
<p>変数の最初の値は、<code>= 値</code>のかわりに<code>(値)</code>や<code>{値}</code>と書いてもよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> a = <span class="dv">1</span> ;
    <span class="kw">auto</span> b(<span class="dv">2</span>) ;
    <span class="kw">auto</span> c{<span class="dv">3</span>} ;
}</code></pre></div>
<p>この<code>=</code>, <code>()</code>, <code>{}</code>による変数の初期値の指定を、<code>初期化</code>という。</p>
<p>変数は使う前に宣言しなければならない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// エラー、名前xは宣言されていない</span>
    <span class="bu">std::</span>cout &lt;&lt; x ;
    <span class="kw">auto</span> x = <span class="dv">123</span> ;
}</code></pre></div>
<p>変数の値は初期化した後にも演算子<code>=</code>で変更できる。これを<code>代入</code>という。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 変数の宣言</span>
    <span class="kw">auto</span> x
    <span class="co">// 初期化</span>
    = <span class="dv">123</span> ;

    <span class="co">// 123</span>
    <span class="bu">std::</span>cout &lt;&lt; x ;

    <span class="co">// 代入</span>
    x = <span class="dv">456</span> ;

    <span class="co">// 456</span>
    <span class="bu">std::</span>cout &lt;&lt; x ;

    <span class="co">// もう一度代入</span>
    x = <span class="dv">789</span> ;
    <span class="co">// 789</span>
    <span class="bu">std::</span>cout &lt;&lt; x ;
}</code></pre></div>
<p>代入演算子<code>operator =</code>は左辺に変数名を、右辺に代入する値を書く。面白いこととして、右辺には代入する変数名そのものを書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> x = <span class="dv">10</span> ;
    x = x + <span class="dv">5</span> ;

    <span class="co">// 15</span>
    <span class="bu">std::</span>cout &lt;&lt; c ;
}</code></pre></div>
<p><code>operator =</code>は「代入」という意味で、「等号」という意味ではないからだ。<code>x=x+5</code>は、「<code>x</code>と<code>x+5</code>は等しい」という独創的な数学上の定義ではなく、「変数xに代入前の変数xの値に5を加えた数を代入する」という意味だ。</p>
<p>変数の今の値に対して演算した結果を変数に代入するという処理はとても良く使うので、C++には<code>x = x + a</code>と同じ意味で使える演算子、<code>operator +=</code>もある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> x = <span class="dv">1</span> ;
    <span class="co">// x = x + 5と同じ</span>
    x += <span class="dv">5</span> ;
}</code></pre></div>
<p><code>operator +=</code>と同様に、<code>operator -=</code>, <code>operator *=</code>, <code>operator /=</code>, <code>operator %=</code>もある。</p>
<p>C++の変数は、専門用語を使うと「静的型付け」になる。静的型付けと対比されるのが「動的型付け」だ。もっと難しく書くと、動的型付け言語の変数は、C++で言えば型情報付きの<code>void *</code>型の変数のような扱いを受ける。</p>
<p>C++の変数には<code>型</code>がある。<code>型</code>というのは値の種類を表す情報のことだ。</p>
<p>例えば、以下は変数が動的型付けの言語JavaScriptのコードだ。</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> x <span class="op">=</span> <span class="dv">1</span> <span class="op">;</span>
x <span class="op">=</span> <span class="st">&quot;hello&quot;</span> <span class="op">;</span>
x <span class="op">=</span> <span class="dv">2</span> <span class="op">;</span></code></pre></div>
<p>JavaScriptではこのコードは正しい。変数<code>x</code>は数値型であり、文字列型に代わり、また数値型に戻る。</p>
<p>C++ではこのようなコードは書けない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> x = <span class="dv">1</span> ;
    <span class="co">// エラー</span>
    x = <span class="st">&quot;hello&quot;</span>s ;
    x = <span class="dv">2</span> ;
}</code></pre></div>
<p>C++では、変数<code>x</code>は整数型であり、文字列型に変わることはない。整数型の変数に文字列型を代入しようとするとエラーとなる。</p>
<p>C++では型に名前がついている。整数型はint、浮動小数点数型はdouble、文字列型はstd::stringだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// iはint型</span>
    <span class="kw">auto</span> i = <span class="dv">123</span> ;
    <span class="co">// dはdouble型</span>
    <span class="kw">auto</span> d = <span class="fl">1.23</span> ;
    <span class="co">// sはstd::string型</span>
    <span class="kw">auto</span> s = <span class="st">&quot;123&quot;</span>s ;
}</code></pre></div>
<p>実は変数の宣言で<code>auto</code>と書くかわりに、具体的な型を書いてもよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">
<span class="dt">int</span> main()
{
    <span class="dt">int</span> i           = <span class="dv">123</span> ;
    <span class="dt">double</span> d        = <span class="fl">1.23</span> ;
    <span class="bu">std::</span>string s   = <span class="st">&quot;123&quot;</span>s ;
}</code></pre></div>
<p>整数型(int)と浮動小数点数型(double)はそれぞれお互いの型の変数に代入できる。ただし、変数の型は変わらない。単に一方の型の値がもう一方の型の値に変換されるだけだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 浮動小数点数型を整数型に変換</span>
    <span class="dt">int</span> a = <span class="fl">3.14</span> ;
    <span class="co">// 3</span>
    <span class="bu">std::</span>cout &lt;&lt; a &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;

    <span class="co">// 整数型を浮動小数点数型に変換</span>
    <span class="dt">double</span> d = <span class="dv">1</span> ;
    <span class="co">// 123</span>
    <span class="bu">std::</span>cout &lt;&lt; d ;
}</code></pre></div>
<p>浮動小数点数型を整数型に変換すると、小数部が切り捨てられる。この場合、<code>3.14</code>の小数部<code>0.14</code>が切り捨てられ<code>3</code>となる。<code>0.9999</code>も小数部が切り捨てられ<code>0</code>になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> i = <span class="fl">0.9999</span> ;
    <span class="co">// 0</span>
    <span class="bu">std::</span>cout &lt;&lt; i ;
}</code></pre></div>
<p>整数型を浮動小数点数型に変換すると、値を正確に表現できる場合はその値になる。正確に表現できない場合は近い値になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">double</span> d = <span class="dv">1234567890</span> ;
    <span class="co">// 正確に表現できるかどうかわからない</span>
    <span class="bu">std::</span>cout &lt;&lt; d ;
}</code></pre></div>
<p>整数型と浮動小数点数型の挙動については後の章で詳しく解説する。また、これ以外にも型はいくらでもあるし、読者が新しい型を作り出すこともできる。これも後の章で詳しく解説する。</p>
<h2 id="関数function">関数(function)</h2>
<p>「変数ぐらい知っている。さっさと教えてもらいたい。どうせC++の関数は書きづらいのだろう」と考える読者の皆さん、おまたせしました。こちらがC++の関数でございます。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 関数</span>
    <span class="kw">auto</span> print = [](<span class="kw">auto</span> x)
    {
        <span class="bu">std::</span>cout &lt;&lt; x &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
    } ;

    <span class="co">// 関数呼び出し</span>
    print(<span class="dv">123</span>) ;
    print(<span class="fl">3.14</span>) ;
    print(<span class="st">&quot;hello&quot;</span>) ;
}</code></pre></div>
<p>C++では関数も変数として扱える。<code>auto print =</code>までは変数だ。変数の初期化として関数を書いている。より正確にはラムダ式と呼ばれる関数を値として書くための文法だ。</p>
<p>ラムダ式は以下のような文法を持つ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">[] <span class="co">// ラムダ式導入部</span>
() <span class="co">// 引数</span>
{} <span class="co">// 本体</span></code></pre></div>
<p>ラムダ式は<code>[]</code>で始まり、<code>()</code>の中に引数を書き、<code>{}</code>の中の文が実行される。</p>
<p>例えば以下は引数を2回標準出力する関数だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> twice = [](<span class="kw">auto</span> x)
    {
        <span class="bu">std::</span>cout &lt;&lt; x &lt;&lt; <span class="st">&quot; &quot;</span>s &lt;&lt; x &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
    } ;

    twice(<span class="dv">5</span>) ;
}</code></pre></div>
<p>引数は<code>auto 引数名</code>で受け取れる。引数を複数取る場合は、カンマ<code>,</code>で区切る。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> print_two = []( <span class="kw">auto</span> x, <span class="kw">auto</span> y )
    {
        <span class="bu">std::</span>cout &lt;&lt; x &lt;&lt; <span class="st">&quot; &quot;</span>s &lt;&lt; y &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
    } ;

    print_two( <span class="dv">1</span>, <span class="dv">2</span> ) ;
    print_two( <span class="st">&quot;Pi is&quot;</span>, <span class="fl">3.14</span> ) ;
}</code></pre></div>
<p>引数を取らないラムダ式を書く場合は、単に<code>()</code>と書く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> no_args = []()
    {
        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Nothing.</span><span class="sc">\n</span><span class="st">&quot;</span> ;
    } ;

    no_args() ;
}</code></pre></div>
<p>関数は演算子<code>operator ()</code>を関数の直後に書いて呼び出す。これが演算子であるというのは少し不思議な感じがするが、C++では紛れもなく演算子だ。<code>operator +</code>とか<code>operator -</code>などと同じ演算子だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 何もしない関数</span>
    <span class="kw">auto</span> func = [](){} ;

    <span class="co">// operator ()の適用</span>
    func() ;
    <span class="co">// これもoperator ()</span>
    func    (   ) ;
}</code></pre></div>
<p>演算子<code>operator ()</code>は、ラムダ式そのものに対して適用することもできる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 変数fをラムダ式で初期化</span>
    <span class="kw">auto</span> f = [](){} ;
    <span class="co">// 変数fを関数呼び出し</span>
    f() ;

    <span class="co">// ラムダ式を関数呼び出し</span>
    [](){}() ;
}</code></pre></div>
<p>このコードを見ると、<code>operator ()</code>が単なる演算子であることがよくわかるだろう。<code>[](){}</code>がラムダ式でその直後の<code>()</code>が関数呼び出し演算子だ。</p>
<p>関数は値を返すことができる。関数から値を返すには、<code>return文</code>を使う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> plus = []( <span class="kw">auto</span> x, <span class="kw">auto</span> y )
        { <span class="cf">return</span> x + y ; } ;

    <span class="bu">std::</span>cout
        &lt;&lt; plus( <span class="dv">1</span>, <span class="dv">2</span> ) &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s
        &lt;&lt; plus( <span class="fl">1.5</span>, <span class="fl">0.5</span> ) &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s
        &lt;&lt; plus( <span class="st">&quot;123&quot;</span>, <span class="st">&quot;456&quot;</span>) ;
}</code></pre></div>
<p>関数はreturn文を実行すると処理を関数の呼び出し元に返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> f = []()
    {
        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;f is called.</span><span class="sc">\n</span><span class="st">&quot;</span> ;
        <span class="cf">return</span> <span class="dv">0</span> ; <span class="co">// ここで処理が戻る</span>
        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;f returned zero.</span><span class="sc">\n</span><span class="st">&quot;</span> ;
    } ;

    <span class="kw">auto</span> result = f() ;
}</code></pre></div>
<p>これを実行すると以下のようになる。</p>
<pre><code>$ make
f is called.</code></pre>
<p>return文以降の文が実行されていないことがわかる。</p>
<h2 id="本当の関数">本当の関数</h2>
<p>実はラムダ式は本当のC++の<code>関数</code>ではない。本当の<code>関数</code>はとても書きづらいので心して読むべきだ。</p>
<p>読者は本書の冒頭で使った<code>main関数</code>という言葉を覚えているだろうか。覚えていないとしても、サンプルコードに必ずと行っていいほど出てくる<code>main</code>という名前は気になっていたことだろう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main(){}</code></pre></div>
<p>これをみると、聡明な読者はラムダ式と似通ったところがあることに気づくだろう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">[](){}</code></pre></div>
<p>末尾の<code>(){}</code>が同じだ。これは同じ意味だ。<code>()</code>は関数の引数で、<code>{}</code>は関数の本体だ。</p>
<p>では残りの部分はどうだろうか。<code>int</code>は関数の戻り値の型、<code>main</code>は関数の名前だ。</p>
<p>C++の本当の関数は以下のような文法で定義される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span>     <span class="co">// 戻り値の型</span>
main    <span class="co">// 関数名</span>
()      <span class="co">// 関数の引数</span>
{}      <span class="co">// 関数の本体</span></code></pre></div>
<p>ためしに、int型の引数を2つ取り足して返す関数`plus'を書いてみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> plus( <span class="dt">int</span> x, <span class="dt">int</span> y )
{
    <span class="cf">return</span> x + y ;
}

<span class="dt">int</span> main()
{
    <span class="kw">auto</span> x = plus( <span class="dv">1</span>, <span class="dv">2</span> ) ;
}</code></pre></div>
<p>では次に、double型の引数を2つ取り足して返す関数<code>plus</code>を書いてみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span> plus( <span class="dt">double</span> x, <span class="dt">double</span> y )
{
    <span class="cf">return</span> x + y ;
}

<span class="dt">int</span> main()
{
    <span class="kw">auto</span> x = plus( <span class="fl">1.0</span>, <span class="fl">2.0</span> ) ;
}</code></pre></div>
<p>最後のstd::string型の引数を2つ取り足して返す関数<code>plus</code>は読者への課題とする。</p>
<p>これがC++の本当の関数だ。C++の関数では、型をすべて明示的に書かなければならない。型を間違えるとエラーだ。</p>
<p>しかも、C++の関数は、戻り値の型を正しく返さなければならない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> f()
{
    <span class="co">// エラー、return文がない</span>
}</code></pre></div>
<p>もし、何も値を返さない関数を書く場合は、どの値でもないという特別な型、<code>void</code>型を関数の戻り値の型として書かなければならないという特別なルールまである。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f()
{
    <span class="co">// OK</span>
}</code></pre></div>
<p>ただし、戻り値の型については、具体的な型の代わりに<code>auto</code>を書くこともできる。その場合、return文で同じ型さえ返していれば、気にする必要はない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// void</span>
<span class="kw">auto</span> a() { }
<span class="co">// int</span>
<span class="kw">auto</span> b() { <span class="cf">return</span> <span class="dv">0</span> ; }
<span class="co">// double</span>
<span class="kw">auto</span> c() { <span class="cf">return</span> <span class="fl">0.0</span> ; }
<span class="co">// std::string</span>
<span class="kw">auto</span> d() { <span class="cf">return</span> <span class="st">&quot;&quot;</span>s ; }

<span class="co">// エラー</span>
<span class="co">// return文の型が一致しない。</span>
<span class="kw">auto</span> e()
{
    <span class="cf">return</span> <span class="dv">0</span> ;
    <span class="cf">return</span> <span class="fl">0.0</span> ;
}</code></pre></div>
<h1 id="デバッグコンパイルエラー">デバッグ：コンパイルエラー</h1>
<p>やれやれ疲れた。この辺で一休みして、デバッグについて考えよう。まずはコンパイルエラーについてだ。</p>
<p>プログラムには様々なバグがあるが、コンパイルエラーは最も簡単なバグだ。というのも、プログラムのバグの存在が実行前に発覚したわけだから、手間が省ける。もしコンパイルエラーにならない場合、実行した結果から、バグがあるかどうかを判断しなければならない。</p>
<p>読者の中には、せっかく書いたソースコードをコンパイルしたらコンパイルエラーが出たので、運が悪かったとか、失敗したとか、怒られてつらい気持ちになったなどと感じることがあるかもしれない。しかしそれは大違いだ。コンパイラーによって読者はプログラムを実行することなくバグが発見できたのだから、読者は運が良かった、大成功した、褒められて最高の気持ちになったと感じるべきなのだ。</p>
<p>さあ皆さんご一緒に、</p>
<ul>
<li>コンパイルエラーは普通</li>
<li>コンパイルエラーが出たらありがとう</li>
<li>コンパイルエラーがでたら大喜び</li>
</ul>
<p>熟練のプログラマーは自分の書いたコードがコンパイルエラーを出さずに一発でコンパイルが通った場合、逆に不安になるくらいだ。</p>
<p>もしバグがあるのにコンパイルエラーが出なければ、バグの存在に気が付かないまま、読者の書いたソフトウェアは広く世の中に使われ、10年後、20年後に最もバグが発見されてほしくない方法で発見されてしまうかもしれない。すなわち、セキュリティ上問題となる脆弱性という形での発覚だ。しかし安心してほしい。今読者が出したコンパイルエラーによって、そのような悲しい未来の可能性は永久に排除されたのだ。コンパイルエラーはどんどん出すとよい。</p>
<p>コンパイルエラーの原因は2つ。</p>
<ol style="list-style-type: decimal">
<li>文法エラー</li>
<li>意味エラー</li>
<li>コンパイラーのバグ</li>
</ol>
<p>3つだった。コンパイルエラーの原因は3つ。</p>
<ol style="list-style-type: decimal">
<li>文法エラー</li>
<li>意味エラー</li>
<li>コンパイラーのバグ</li>
<li>コンピューターの故障</li>
</ol>
<p>4つだった。ただ、3.と4.はめったにないから無視してよい。</p>
<h2 id="文法エラー">文法エラー</h2>
<p>文法エラーとは、C++というプログラミング言語の文法に従っていないエラーのことだ。これはC++として解釈できないので、当然エラーになる。</p>
<p>よくある文法エラーとしては、文末のセミコロンを打ち忘れたものがある。例えば以下のコードには間違いがある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> x = <span class="dv">1</span> + <span class="dv">1</span> 
    <span class="kw">auto</span> y = x + <span class="dv">1</span> ;
}</code></pre></div>
<p>これをコンパイルすると以下のようにコンパイルエラーメッセージが出力される。</p>
<pre><code>$ make
g++ -std=c++17 -Wall --pedantic-error -include all.h main.cpp -o program
main.cpp: In function ‘int main()’:
main.cpp:4:5: error: expected ‘,’ or ‘;’ before ‘auto’
     auto y = x + 1 ;
     ^~~~
main.cpp:3:10: warning: unused variable ‘x’ [-Wunused-variable]
     auto x = 1 + 1
          ^
Makefile:4: recipe for target &#39;program&#39; failed
make: *** [program] Error 1</code></pre>
<p>コンパイラーのメッセージを読み慣れていない読者はここで考えることを放棄してコンピューターの電源を落とし家を出て街を徘徊し夕日を見つめて人生、宇宙、すべてについての究極の質問への答えを模索してしまうことだろう。</p>
<p>しかし恐れるなかれ。コンパイラーのエラーメッセージを読み解くのは難しくない。</p>
<p>まず最初の2行を見てみよう。</p>
<pre><code>$ make
g++ -std=c++17 -Wall --pedantic-error -include all.h main.cpp -o program</code></pre>
<p>1行目はシェルにmakeを実行させるためのコマンド、二行目はmakeが実行したレシピの中身だ。これはコンパイラーによるメッセージではない。</p>
<p>3行目からはコンパイラーによる出力だ。</p>
<pre><code>main.cpp: In function ‘int main()’:</code></pre>
<p>コンパイラーはソースファイル<code>main.cpp</code>の中の、<code>int main()</code>という関数について、特に言うべきことがあると主張している。</p>
<p>言うべきこととは以下だ。</p>
<pre><code>main.cpp:4:5: error: expected ‘,’ or ‘;’ before ‘auto’
     auto y = x + 1 ;
     ^~~~</code></pre>
<p>GCCというコンパイラーのエラーメッセージは、以下のフォーマットを採用している。</p>
<pre><code>ソースファイル名:行番号:列番号: メッセージの種類: メッセージの内容</code></pre>
<p>ここでのメッセージの種類は<code>error</code>、つまりこのメッセージはエラーを伝えるものだ。</p>
<p>ソースファイル名は<code>main.cpp</code>、つまりエラーは<code>main.cpp</code>の中にあるということだ。</p>
<p>行番号というのは、最初の行を1行目とし、改行ごとにインクリメントされていく。今回のソースファイルの場合、以下のようになる。</p>
<pre><code>1 int main()
2 {
3     auto x = 1 + 1 
4     auto y = x + 1 ;
5 }</code></pre>
<p>もし読者が素晴らしいテキストエディターであるVimを使っている場合、<code>:set nu</code>すると行番号を表示できる。</p>
<p>その上でエラーメッセージの行番号を確認すると<code>4</code>とある。つまりコンパイラーは4行目に問題があると考えているわけだ。</p>
<p>4行目を確認してみよう。</p>
<pre><code>    auto y = x + 1 ;</code></pre>
<p>何の問題もないように見える。更にエラーメッセージを読んでみよう。</p>
<p>列番号が<code>5</code>となっている。列番号というのは、行頭からの文字数だ。最初の文字を1文字目とし、文字ごとにインクリメントされていく。</p>
<pre><code>123456789...
    auto y = x + 1 ;</code></pre>
<p>4行目は空白文字を4つ使ってインデントしているので、autoのaの列番号は5だ。ここに問題があるのだろうか。何も問題がないように見える。</p>
<p>この謎を解くためには、メッセージの内容を読まなければならない。</p>
<pre><code>expected ‘,’ or ‘;’ before ‘auto’
     auto y = x + 1 ;
     ^~~</code></pre>
<p>これは日本語に翻訳すると以下のようになる。</p>
<pre><code>‘auto’の前に&#39;,&#39;か&#39;;&#39;があるべき
     auto y = x + 1 ;
     ^~~</code></pre>
<p>1行目はエラー内容をテキストで表現したものだ。これによると、'auto'の前に','か';'があるべきとあるが、やはりまだわからない。</p>
<p>2行目は問題のある箇所のソースコードを部分的に抜粋したもので、3行目はそのソースコードの問題のある文字を視覚的にわかりやすく示しているものだ。</p>
<p>ともかく、コンパイラーの支持に従って'auto'の前に','を付けてみよう。</p>
<pre><code>    ,auto y = x + 1 ;</code></pre>
<p>これをコンパイルすると、また違ったエラーメッセージが表示される。</p>
<pre><code>main.cpp: In function ‘int main()’:
main.cpp:4:6: error: expected unqualified-id before ‘auto’
     ,auto y = x + 1 ;
      ^~~~</code></pre>
<p>では';'ならばどうか。</p>
<pre><code>    ;auto y = x + 1 ;</code></pre>
<p>これはコンパイルが通るようだ。</p>
<p>しかしなぜこれでコンパイルが通るのだろう。そのためには、コンパイラーが問題だとした行の一つ上の行を見る必要がある。</p>
<pre><code>    auto x = 1 + 1
    auto y = x + 1 ;</code></pre>
<p>コンパイラーにとって、改行は空白文字と同じくソースファイル中の意味のあるトークン(キーワードや名前や記号)を区切る文字でしかない。コンパイラーにとって、このコードは実質以下のように見えてる。</p>
<pre><code>auto x=1+1 auto y=x+1;</code></pre>
<p>&quot;1 auto&quot;というのは文法エラーだ。なのでコンパイラーは文法エラーが発覚する最初の文字である'auto'の'a'を指摘したのだ。</p>
<p>人間にとって自然になるように修正すると、コンパイラーが指摘した行の一つ上の行の行末に';'を追加すべきだ。</p>
<pre><code>    auto x = 1 + 1 ;
    auto y = x + 1 ;</code></pre>
<p>文法エラーというのは厄介なバグだ。というのも、コンパイラーというのは正しい文法のソースファイルを処理するように作られている。文法を間違えた場合、ソースファイル全体が正しくないということになる。コンパイラーは文法違反に遭遇した場合、なるべく人間がよく間違えそうなパターンをヒューリスティックに指摘することもしている。そのため、エラーメッセージに指摘された行番号と列番号は、必ずしも人間にとっての問題の箇所と一致しない。</p>
<p>もうひとつ例を見てみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 引数を3つとって足して返す関数</span>
    <span class="kw">auto</span> f = [](<span class="kw">auto</span> a, <span class="kw">auto</span> b, <span class="kw">auto</span> c)
    { <span class="cf">return</span> a + b + c ; } ;

    <span class="bu">std::</span>cout &lt;&lt; f(<span class="dv">1</span>+(<span class="dv">2</span>*<span class="dv">3</span>),<span class="dv">4-5</span>,<span class="dv">6</span>/(<span class="dv">7-8</span>))) ;
}</code></pre></div>
<h1 id="cプリプロセッサー">Cプリプロセッサー</h1>
<p>CプリプロセッサーはC++がC言語から受け継いだ機能だ。CプリプロセッサーはソースコードをC++としてパースする前に、テキストをトークン単位で変形する処理のことだ。この処理はソースファイルをC++としてパースする前処理として行われる。CプリプロセッサーはC++ではなく別言語として認識すべきで、そもそもプログラミング言語ではなくマクロ言語だ。</p>
<p>C++ではCプリプロセッサーが広く使われており、今後もしばらくは使われるだろう。読者がC++で書かれた既存のコードを読む時、Cプリプロセッサーは避けて通れない。Cプリプロセッサーはいずれ廃止したい機能ではあるが、C++は未だに廃止できていない。</p>
<p>Cプリプロセッサーはプリプロセッシングディレクティブ(preprocessing directive)を認識し、トークン列を処理する。ディレクティブはソースファイルの文頭に文字<code>#</code>から始まり、改行文字で終わる。<code>#</code>とディレクティブの間に空白文字を入れてもよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#define NOSPACE</span>
<span class="pp">#    define SPACE</span></code></pre></div>
<h2 id="includeディレクティブ">#includeディレクティブ</h2>
<p><code>#include</code>は指定したファイルの内容をその場に挿入する。本質的にはコピペだ。C++では<code>#include</code>はライブラリを利用するのに使われる。</p>
<p><code>#include</code>は以下のいずれかの文法を持つ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&lt;ヘッダーファイルパス&gt;</span><span class="pp"> 改行文字</span>
<span class="pp">#include </span><span class="im">&quot;ヘッダーファイルパス&quot;</span><span class="pp"> 改行文字</span></code></pre></div>
<p><code>#include</code>は指定したファイルパスのファイルの内容をその場所に挿入する。このファイルをヘッダーファイルという。<code>&lt;&gt;</code>によるファイルパスは、標準ライブラリやシステムのヘッダーファイルを格納したディレクトリーからヘッダーファイルを探す。<code>&quot;&quot;</code>によるファイルパスは、システム以外のディレクトリーからもヘッダーファイルを探す。例えばカレントディレクトリーなどだ。</p>
<p>例えば、以下のようなヘッダーファイル<code>foo.h</code>があり、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// foo.h</span>
foo foo foo</code></pre></div>
<p>以下のようなソースファイル<code>bar.cpp</code>がある場合、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// bar.cpp</span>

<span class="pp">#include </span><span class="im">&quot;foo.h&quot;</span>

<span class="co">// end bar.cpp</span></code></pre></div>
<p><code>bar.cpp</code>をCプリプロセッサーにかけると、以下のようなソースファイルが出力される</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// bar.cpp</span>

<span class="co">// foo.h</span>
foo foo foo

<span class="co">// end bar.h</span></code></pre></div>
<p>このソースファイルはC++のソースファイルとしてはエラーとなるが、Cプリプロセッサーは単純にトークン列で分割したテキストファイルとしてソースファイルを処理するため、Cプリプロセッサーとしてはエラーにはならない。</p>
<p>冒頭で述べたように、<code>#include</code>の本質はコンパイラーによるコピペである。あるテキストファイルの内容をその場に挿入するコピペ機能を提供する。</p>
<p><code>#include</code>は、他の言語でモジュール、importなどと呼ばれている機能を簡易的に提供する。C++の標準ライブラリを使うには、<code>&lt;iostream&gt;</code>や<code>&lt;string&gt;</code>や<code>&lt;vector&gt;</code>のようなヘッダーファイルを<code>#include</code>する必要がある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// iostreamライブラリを使う</span>
<span class="pp">#include </span><span class="im">&lt;iostream&gt;</span>
<span class="co">// stringライブラリを使う</span>
<span class="pp">#include </span><span class="im">&lt;string&gt;</span>

<span class="dt">int</span> main()
{
    <span class="co">// &lt;string&gt;のライブラリ</span>
    <span class="bu">std::</span>string s(<span class="st">&quot;hello&quot;</span>) ;
    <span class="co">// iostreamのライブラリ</span>
    <span class="bu">std::</span>cout &lt;&lt; s ;
}</code></pre></div>
<p>すでに述べたように<code>#include</code>はファイルの内容をその場に挿入するだけであり、他の言語にあるモジュールのための高級な機能ではない。本書を執筆時点で規格策定中のC++20では、より高級なモジュール機能を追加する予定がある。</p>
<p>同じヘッダーファイルを複数回<code>#include</code>すると、当然複数回挿入される。</p>
<p>以下のような<code>val.h</code>を、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// val.h</span>
<span class="kw">inline</span> <span class="dt">int</span> val ;</code></pre></div>
<p>以下のように複数回<code>#include</code>すると、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&quot;val.h&quot;</span>
<span class="pp">#include </span><span class="im">&quot;val.h&quot;</span></code></pre></div>
<p>以下のように置換される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// val.h</span>
<span class="kw">inline</span> <span class="dt">int</span> val ;
<span class="co">// val.h</span>
<span class="kw">inline</span> <span class="dt">int</span> val ;</code></pre></div>
<p>これはvalの定義が重複しているためエラーとなる。</p>
<p>しかし、ヘッダーファイルを一度しか<code>#include</code>しないようにするのは困難だ。なぜならば、ヘッダーファイルは他のヘッダーファイルから間接的に<code>#include</code>されることもあるからだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// lib_f.h</span>

<span class="pp">#include </span><span class="im">&quot;val.h&quot;</span>

<span class="dt">int</span> f() ;</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// lib_g.h</span>

<span class="pp">#include </span><span class="im">&quot;val.h&quot;</span>

<span class="dt">int</span> g() ;</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// main.cpp</span>

<span class="pp">#include </span><span class="im">&quot;lib_f.h&quot;</span>
<span class="pp">#include </span><span class="im">&quot;lib_g.h&quot;</span>

<span class="dt">int</span> main()
{
    <span class="dt">int</span> result = f() + g() ;
}</code></pre></div>
<p>この<code>main.cpp</code>をCプリプロセッサーにかけると以下のように置換される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// main.cpp</span>

<span class="co">// lib_f.h</span>

<span class="co">// val.h</span>
<span class="kw">inline</span> <span class="dt">int</span> val ;

<span class="dt">int</span> f() ;

<span class="co">// lib_g.h</span>

<span class="co">// val.h</span>
<span class="kw">inline</span> <span class="dt">int</span> val ;

<span class="dt">int</span> g() ;


<span class="dt">int</span> main()
{
    <span class="dt">int</span> result = f() + g() ;
}</code></pre></div>
<p>これはvalの定義が重複しているためエラーとなる。</p>
<p>この問題に対処するためには、複数回<code>#include</code>されると困るヘッダーファイルでは、インクルードガード(include guard)と呼ばれている方法を使う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// val.h</span>

<span class="pp">#ifdef INCLUDE_GUARD_HEADER_VAL_H</span>
<span class="pp">#define INCLUDE_GUARD_HEADER_VAL_H</span>

<span class="kw">inline</span> <span class="dt">int</span> val ;

<span class="pp">#endif</span></code></pre></div>
<p>このように記述した<code>val.h</code>を複数回<code>#include</code>しても、最初のifdefのみがコンパイル対象になるため、問題は起こらない。</p>
<p>インクルードガードは以下の様式を持つ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#ifdef 十分にユニークなマクロ名</span>
<span class="pp">#define 十分にユニークなマクロ名 </span>

<span class="co">// 重複してコンパイルされたくないコードをここに書く</span>

<span class="pp">#endif</span></code></pre></div>
<p><code>十分にユニークなマクロ名</code>は全ソースファイル中で衝突しないそのヘッダーに固有のマクロ名を使う。慣習的に推奨される方法としてはすべて大文字を使い、十分に長いマクロ名にすることだ。</p>
<h2 id="define">#define</h2>
<p><code>#define</code>はマクロ置換を行う。マクロにはオブジェクト風マクロ(object-like macro)と関数風マクロ(function-like macro)がある。風というのは、マクロはオブジェクトでも関数でもないからだ。ただ、文法上オブジェクトや関数の似ているだけで、実態はトークン列の愚直な置換だ。</p>
<h3 id="オブジェクト風マクロ">オブジェクト風マクロ</h3>
<p>オブジェクト風マクロの文法は以下の通り</p>
<pre><code>#define マクロ名 置換リスト　改行文字</code></pre>
<p><code>#define</code>以降の行では、マクロ名が置換リストに置き換わる</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#define ONE             1</span>
<span class="pp">#define ONE_PLUS_ONE    ONE + ONE</span>
<span class="pp">#define GNU GNU&#39;s is NOT UNIX</span>

ONE
ONE_PLUS_ONE</code></pre></div>
<p>これをプリプロセスすると以下のソースコードになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dv">1</span>
<span class="dv">1</span> + <span class="dv">1</span></code></pre></div>
<p>マクロ名<code>ONE</code>は<code>1</code>に置換される。</p>
<p>マクロ名<code>ONE_PLUS_ONE</code>は<code>ONE + ONE</code>に置換される。置換された結果に別のマクロ名があれば、そのマクロ名も置換される。</p>
<p>あるマクロ名を置換した結果、そのマクロ名が現れても再帰的に置換されることはない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#define GNU GNU&#39;s NOT UNIX!</span>

GNU</code></pre></div>
<p>これは以下のように置換される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">GNU<span class="st">&#39;s NOT UNIX!</span></code></pre></div>
<p>マクロ名<code>GNU</code>を展開するとトークン`GNU'が現れるが、これは置換されたマクロ名と同じなので、再帰的に置換されることはない。</p>
<h3 id="関数風マクロ">関数風マクロ</h3>
<p>関数風マクロの文法は以下の通り。</p>
<pre><code>#define マクロ名( 識別子リスト ) 置換リスト 改行文字</code></pre>
<p>関数風マクロはあたかも関数のように記述できる。関数風マクロに実引数として渡したトークン列は、置換リスト内で仮引数としての識別子で参照できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#define NO_ARGUMENT()           No argument</span>
<span class="pp">#define ONE_ARGUMENT( ARG )     begin ARG end</span>
<span class="pp">#define MAKE_IT_DOUBLE( ARG )   ONE_ARGUMENT( ARG ARG )</span>

NO_ARGUMENT()
ONE_ARGUMENT( foo bar )
MAKE_IT_DOUBLE( foo bar )</code></pre></div>
<p>これは以下のように置換される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">No argument
begin foo bar end
begin foo bar foo bar end</code></pre></div>
<p>複数の引数を取るマクロへの実引数は、カンマで区切られたトークン列を渡す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#define TWO( A, B ) A B</span>
<span class="pp">#define THREE( A, B, C ) C B A</span>

TWO( <span class="dv">1</span> <span class="dv">2</span>, <span class="dv">3</span> <span class="dv">4</span> )
THREE( <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span> )</code></pre></div>
<p>これは以下のように置換される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>
<span class="dv">3</span> <span class="dv">2</span> <span class="dv">1</span></code></pre></div>
<p>ただし、括弧で囲まれたトークン列の中にあるカンマは、マクロの実引数の区切りとはみなされない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#define MACRO( A ) A</span>

MACRO( (a,b) )</code></pre></div>
<p>これは以下のように置換される。</p>
<pre><code>(a,b)</code></pre>
<h3 id="va_args__可変長引数マクロ"><code>__VA_ARGS__</code>(可変長引数マクロ)</h3>
<p><code>#define</code>の識別子リストを<code>...</code>だけにしたマクロは、可変長引数マクロになる。このときマクロの実引数のトークン列は、置換リストのなかで<code>__VA_ARGS__</code>として参照できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#define MACRO(...) </span><span class="ot">__VA_ARGS__</span>

MACRO( You can write , <span class="kw">and</span> ,, <span class="kw">or</span> even ,,,, )</code></pre></div>
<p>これは以下のように置換される。</p>
<pre><code>You can write , and ,, or even ,,,,</code></pre>
<p>カンマも含めてすべてのトークン列がそのまま<code>__VA_ARGS__</code>で参照できる。</p>
<p>可変長引数マクロの識別子リストに仮引数と<code>...</code>を書いたマクロの置換リストでは、仮引数の数だけの実引数は仮引数で参照され、残りが<code>__VA_ARGS__</code>で参照される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#define MACRO( X, Y, Z, ... ) X Y Z and </span><span class="ot">__VA_ARGS__</span>

MACRO( <span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span> )</code></pre></div>
<p>これは以下のように置換される</p>
<pre><code>1 2 3 and 4,5,6</code></pre>
<p>X, Y, Zにそれぞれ1, 2, 3が入り、<code>__VA_ARGS__</code>には<code>4,5,6</code>が入る。</p>
<h3 id="va_opt__"><code>__VA_OPT__</code></h3>
<p><code>__VA_OPT__</code>は可変長引数マクロで<code>__VA_ARGS__</code>にトークン列が渡されたかどうかで置換結果を変えることができる。</p>
<p><code>__VA_OPT__</code>は可変引数マクロの置換リストでのみ使える。<code>__VA_OPT__(content)</code>は<code>__VA_ARGS__</code>にトークンがない場合はトークンなしに置換され、トークンがある場合はトークン列<code>content</code>に置換される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#define MACRO( X, ... ) f( X __VA_OPT__(,) </span><span class="ot">__VA_ARGS__</span><span class="pp"> )</span>

MACRO(<span class="dv">1</span>)
MACRO(<span class="dv">1</span>,<span class="dv">2</span>)</code></pre></div>
<p>これは以下のように置換される。</p>
<pre><code>f( 1 )
f( 1, 2 )</code></pre>
<p><code>MACRO(1)</code>は<code>X</code>が<code>1</code>になり、<code>__VA_ARGS__</code>にはトークンがないので、<code>__VA_OPT__(,)</code>は空に置換される。結果として<code>f(1)</code>となる。</p>
<p><code>MACRO(1,2)</code>は、Xが1になり、<code>__VA_ARGS__'にはトークン</code>2<code>が入るので、</code><strong>VA_OPT</strong>(,)<code>は</code>,<code>に置換される。結果として</code>f(1,2)`となる。</p>
<p><code>__VA_OPT__</code>は<code>__VA_ARGS__</code>に実引数となるトークン列がなければ空に置換されるので、このようにトークン列の有無によってカンマなどの文法上必須のトークン列の有無を切り替えたい場合に使うことができる。</p>
<h3 id="演算子">#演算子</h3>
<p><code>#</code>はマクロ実引数を文字列リテラルにする。</p>
<p><code>#</code>は関数風マクロの置換リストの中のみで使うことができる。<code>#</code>は関数風マクロの仮引数の識別子の直前に書くことができる。<code>#</code>が直前に書かれた識別子は、マクロ実引数のトークン列の文字列リテラルになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#define STRING( X ) # X</span>

STRING( hello )
STRING( hello world )</code></pre></div>
<p>これは以下のように置換される。</p>
<pre><code>&quot;hello&quot;
&quot;hello world&quot;</code></pre>
<p>また、可変長マクロと組み合わせた場合、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#define STRING( ... ) # </span><span class="ot">__VA_ARGS__</span>

STRING()
STRING( hello,world )</code></pre></div>
<p>以下のように置換される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="st">&quot;&quot;</span>
<span class="st">&quot;hello,world&quot;</span></code></pre></div>
<h3 id="演算子-1">##演算子</h3>
<p><code>##</code>はマクロ実引数の結合を行う。</p>
<p><code>##</code>は関数風マクロの置換リストの中にしか書けない。<code>##</code>は両端にマクロの仮引数の識別子を書かなければならない。<code>##</code>は両端の識別子の参照するマクロ実引数のトークン列を結合した置換を行う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#define CONCAT( A, B ) A ## B</span>

CONCAT( foo, bar )
CONCAT( aaa bbb, ccc ddd)</code></pre></div>
<p>これは以下のように置換される。</p>
<pre><code>foobar
aaa bbbccc ddd</code></pre>
<p>結合した結果のトークンは更にマクロ置換の対象となる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#define CONCAT( A, B ) A ## B</span>
<span class="pp">#define FOOBAR hello</span>

CONCAT( FOO, BAR )</code></pre></div>
<p>これは以下のように置換される。</p>
<pre><code>hello</code></pre>
<p><code>CONCAT(FOO,BAR)</code>は<code>FOOBAR</code>に置換され、FOOBARという名前のマクロ名があるためにさらに<code>hello</code>に置換される。</p>
<h3 id="複数行の置換リスト">複数行の置換リスト</h3>
<p><code>#define</code>ディレクティブの置換リストは複数行に渡って書くことができない。これは文法上の制約によるものだ。<code>#define</code>ディレクティブは改行文字で終端される。</p>
<p>しかし、関数やクラスを生成するような複雑なマクロは、複数行に分けて書きたい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#define LIST_NAME2( PREFIX, TYPE ) PREFIX ## TYPE</span>
<span class="pp">#define LIST_NAME( TYPE ) LIST_NAME2( list_, TYPE )</span>

<span class="pp">#define DEFINE_LIST( TYPE ) struct LIST_NAME(TYPE){TYPE value ;LIST_NAME(TYPE) * prev ;LIST_NAME(TYPE) * next ;} ; </span>

DEFINE_LIST(<span class="dt">int</span>)
DEFINE_LIST(<span class="dt">double</span>)</code></pre></div>
<p>この場合、行末にバックスラッシュに続けて改行を書くと、バックスラッシュと改行がプリプロセッサーによって削除される。</p>
<p>上の例は以下のように、プリプロセッサーとしては比較的わかりやすく書くことができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#define LIST_NAME2( PREFIX, TYPE ) PREFIX ## TYPE</span>
<span class="pp">#define LIST_NAME( TYPE ) LIST_NAME2( list_, TYPE )</span>

<span class="pp">#define DEFINE_LIST( TYPE )</span>\
<span class="pp">struct LIST_NAME(TYPE)</span>\
<span class="pp">{</span>\
<span class="pp">    TYPE value ;</span>\
<span class="pp">    LIST_NAME(TYPE) * prev ;</span>\
<span class="pp">    LIST_NAME(TYPE) * next ;</span>\
<span class="pp">} ; </span>

DEFINE_LIST(<span class="dt">int</span>)
DEFINE_LIST(<span class="dt">double</span>)</code></pre></div>
<p>C++ではテンプレートがあるために、このようなマクロを書く必要はない。</p>
<h3 id="undefディレクティブ">#undefディレクティブ</h3>
<p><code>#undef</code>はそれ以前に定義されたマクロを削除する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#define FOO BAR</span>
FOO
<span class="pp">#undef FOO</span>
FOO</code></pre></div>
<p>これは以下のように置換される。</p>
<pre><code>BAR
FOO</code></pre>
<h2 id="条件付きソースファイル選択">条件付きソースファイル選択</h2>
<p><code>#if</code>, <code>#elif</code>, <code>#else</code>, <code>#endif</code>, <code>#ifdef</code>, <code>#ifndef</code>は条件付きのソースファイルの選択(conditinal inclusion)を行う。これは条件付きコンパイルに近い機能を提供する。</p>
<h3 id="プリプロセッサーの定数式">プリプロセッサーの定数式</h3>
<p>プリプロセッサーで使える条件式は、C++の条件式とは比べてだいぶ制限がある。基本的には整数定数式で、<code>true</code>, <code>false</code>が使える他、<code>123</code>, <code>1+1</code>, <code>1 == 1</code>, <code>1 &lt; 1</code>のような式も使える。ただし、識別子はすべてマクロ名として置換できるものは置換され、置換できない識別子は、<code>true</code>, <code>false</code>以外はキーワードも含めてすべて0に置換される。</p>
<p>したがって、プリプロセッサーで以下のように書くと、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#if UNDEFINED</span>
<span class="pp">#endif</span></code></pre></div>
<p>以下のように書いたものと同じになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#if 0</span>
<span class="pp">#endif</span></code></pre></div>
<p>プリプロセッサーであるので、C++としてのconstexpr変数やconstexpr関数も使えない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">constexpr</span> <span class="dt">int</span> x = <span class="dv">1</span> ;

<span class="pp">#if x</span>
hello
<span class="pp">#endif</span></code></pre></div>
<p>これは以下のように置換される。</p>
<pre><code>constexpr int x = 1 ;</code></pre>
<p>プリプロセッサーはC++の文法と意味を理解しない。単にトークン列として処理する。</p>
<p>以下の例はエラーになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">constexpr</span> <span class="dt">int</span> f() { <span class="cf">return</span> <span class="dv">1</span> ; }

<span class="pp">#if f()</span>
<span class="pp">#endif</span></code></pre></div>
<p>なぜならば、<code>0()</code>は整数定数式として合法なコードではないからだ。何度も言うように、プリプロセッサーはC++の文法と意味を理解しない。</p>
<p>プリプロセッサーの定数式では、特殊なマクロ風の式を使うことができる。<code>defined</code>と<code>__has_include</code>だ。</p>
<p><code>defined</code>は以下の文法を持つ</p>
<pre><code>defined 識別子
defined ( 識別子 )</code></pre>
<p><code>defined</code>は識別子がそれ以前の行で<code>#define</code>でマクロとして定義されていて<code>#undef</code>で取り消されていない場合<code>1</code>になり、それ以外の場合0になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// #if 0</span>
<span class="pp">#if defined MACRO</span>
<span class="pp">#endif</span>

<span class="pp">#define MACRO</span>

<span class="co">// #if 1</span>
<span class="pp">#if defined MACRO</span>
<span class="pp">#endif</span>

<span class="pp">#undef MACRO</span>

<span class="co">// #if 0</span>
<span class="pp">#if defined MACRO</span>
<span class="pp">#endif</span></code></pre></div>
<p><code>__has_include</code>は以下の文法を持つ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">__has_include ( &lt; ヘッダーファイル名 &gt; )
__has_include ( <span class="st">&quot; ヘッダーファイル名 &quot;</span> )
__has_include ( 文字列リテラル )
__has_include ( &lt; マクロ &gt; )</code></pre></div>
<p>1番目と2番目は、指定されたヘッダーファイル名がシステムに存在する場合<code>1</code>に、そうでない場合0になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// &lt;filesystem&gt;の存在を確認してから#includeする</span>
<span class="pp">#if __has_include(&lt;filesystem&gt;)</span>
<span class="pp">#   include </span><span class="im">&lt;filesystem&gt;</span>
<span class="pp">#endif</span>

<span class="co">// &quot;mylibrary.h&quot;の存在を確認してから#includeする</span>
<span class="pp">#if __has_include(&quot;mylibrary.h&quot;)</span>
<span class="pp">#   include </span><span class="im">&quot;mylibrary.h&quot;</span>
<span class="pp">#endif</span></code></pre></div>
<p>3番目と4番目は、1番目と2番目が適用できない場合に初めて考慮される。その場合、まず通常通りにプリプロセッサーのマクロ置換が行われる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#define STDIO &quot;stdio.h&quot;</span>

<span class="pp">#if __has_include( STDIO )</span>
<span class="pp">#endif</span>

<span class="pp">#define STDLIB stdlib.h</span>

<span class="pp">#if __has_include( &lt;STDLIB&gt; )</span>
<span class="pp">#endif</span></code></pre></div>
<h3 id="ifディレクティブ">#ifディレクティブ</h3>
<p><code>#if</code>ディレクティブは以下の文法を持つ。</p>
<pre><code>#if 定数式 改行文字

#endif</code></pre>
<p>もし定数式がゼロの場合、<code>#if</code>と<code>#endif</code>で囲まれたトークン列は処理されない。定数式が非ゼロの場合、処理される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#if 0</span>
<span class="co">This line will be skipped.</span>
<span class="pp">#endif</span>

<span class="pp">#if 1</span>
This line will be processed.
<span class="pp">#endif</span></code></pre></div>
<p>これをプリプロセスすると以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">This line will be processed.</code></pre></div>
<p><code>#if 0</code>は処理されないので、<code>#endif</code>までのトークン列は消える。</p>
<h3 id="elifディレクティブ">#elifディレクティブ</h3>
<p><code>#elif</code>ディレクティブは、C++でいう<code>else if</code>に相当する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">
<span class="pp">#elif 定数式 改行文字</span></code></pre></div>
<p><code>#elif</code>ディレクティブは<code>#if</code>ディレクティブと<code>#endif</code>ディレクティブの間に複数書くことができる。<code>#elif</code>のある<code>#if</code>が処理される場合、<code>#if</code>から<code>#elif</code>の間のトークン列が処理される、<code>#if</code>が処理されない場合、<code>#elif</code>が<code>#if</code>と同じように定数式を評価して処理されるかどうかが判断される。<code>#elif</code>が処理される場合、処理されるトークン列は次の<code>#elif</code>もしくは<code>#endif</code>までの間のトークン列になる。</p>
<p>以下の例は、すべてYESのトークンがある行のみ処理される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#if 1</span>
YES
<span class="pp">#elif</span><span class="co"> 1</span>
<span class="co">NO</span>
<span class="pp">#endif</span>

<span class="pp">#if 0</span>
<span class="co">NO</span>
<span class="pp">#elif</span> <span class="dv">1</span>
YES
<span class="pp">#endif</span>

<span class="pp">#if 0</span>
<span class="co">NO</span>
<span class="pp">#elif</span> <span class="dv">1</span>
YES
<span class="pp">#elif 1</span>
NO
<span class="pp">#endif</span>

<span class="pp">#if 0</span>
<span class="co">NO</span>
<span class="pp">#elif</span> <span class="dv">0</span>
NO
<span class="pp">#elif 1</span>
YES
<span class="pp">#endif</span></code></pre></div>
<p>プリプロセスした結果は以下の通り、</p>
<pre><code>YES
YES
YES
YES</code></pre>
<h3 id="elseディレクティブ">#elseディレクティブ</h3>
<p><code>#else</code>ディレクティブはC++でいう<code>else</code>に相当する。</p>
<p><code>#else</code>ディレクティブは<code>#if</code>ディレクティブと<code>#endif</code>ディレクティブの間に書くことができる。もし<code>#if</code>と<code>#elif</code>ディレクティブが処理されない場合で<code>#else</code>ディレクティブがある場合、<code>#else</code>から<code>#endif</code>までのトークン列が処理される。</p>
<p>以下の例は、YESのトークンがある行のみ処理される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#if 1</span>
YES
<span class="pp">#else</span>
<span class="co">NO</span>
<span class="pp">#endif</span>

<span class="pp">#if 0</span>
<span class="co">NO</span>
<span class="pp">#else</span>
YES
<span class="pp">#endif</span>

<span class="pp">#if 0</span>
<span class="co">NO</span>
<span class="pp">#elif</span> <span class="dv">1</span>
YES
<span class="pp">#else</span>
NO
<span class="pp">#endif</span></code></pre></div>
<h3 id="ifdef-ifndefディレクティブ">#ifdef, #ifndefディレクティブ</h3>
<pre><code>#ifdef 識別子
#ifndef 識別子</code></pre>
<p>は、それぞれ以下と同じ意味になる。</p>
<pre><code>#if defined 識別子
#if !defined 識別子</code></pre>
<p>例、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#ifdef MACRO</span>
<span class="pp">#endif</span>

<span class="co">// 上と同じ</span>
<span class="pp">#if defined MACRO</span>
<span class="pp">#endif</span>


<span class="pp">#ifndef MACRO</span>
<span class="pp">#endif</span>

<span class="co">// 上と同じ</span>
<span class="pp">#if !defined MACRO</span>
<span class="pp">#endif</span></code></pre></div>
<h2 id="lineディレクティブ">#lineディレクティブ</h2>
<p><code>#line</code>ディレクティブはディレクティブの次の行の行番号と、ソースファイル名を変更する。これは人間が使うのではなく、ツールによって生成されることを想定した機能だ。</p>
<p>以下の文法の<code>#line</code>ディレクティブは、<code>#line</code>ディレクティブの次の行の行番号をあたかも数値で指定した行番号であるかのように振る舞わせる。</p>
<pre><code>#line 数値 改行文字</code></pre>
<p>数値として0もしくは2147483647より大きい数を指定した場合の挙動は未定義となる。</p>
<p>以下の例はコンパイルエラーになるが、コンパイルエラーメッセージはあたかも102行目に問題があるかのように表示される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 1行目</span>
<span class="co">// 2行目</span>
<span class="pp">#line 100 </span><span class="co">// 3行目</span>
<span class="co">// 100行目</span>
<span class="co">// 101行目</span>
ill-formed line <span class="co">// 102行目</span></code></pre></div>
<p>以下の例は999を出力するコードだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span>
<span class="dt">int</span> main()
{
<span class="pp">#line 999</span>
    <span class="bu">std::</span>cout &lt;&lt; <span class="ot">__LINE__</span> ;
}</code></pre></div>
<p>以下の文法の<code>#line</code>ディレクティブは、次の行の行番号を数値にした上で、ソースファイル名をソースファイル名にする。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#line 数値 &quot;ソースファイル名&quot; 改行文字</span></code></pre></div>
<p>例、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#line 42 &quot;answer.cpp&quot;</span></code></pre></div>
<p>以下の文法の<code>#line</code>ディレクティブは、プリプロセッサートークン列をプリプロセスし、上の2つの文法のいずれかに合致させる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#line プリプロセッサートークン列 改行文字</span></code></pre></div>
<p>例、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#define LINE_NUMBER 123</span>
<span class="pp">#line LINE_NUMBER</span></code></pre></div>
<h2 id="errorディレクティブ">#errorディレクティブ</h2>
<p><code>#error</code>ディレクティブはコンパイルエラーを引き起こす。</p>
<pre><code>#error 改行文字
#error トークン列 改行文字</code></pre>
<p><code>#error</code>によるコンパイラーのエラーメッセージには<code>#error</code>のトークン列を含む。</p>
<p><code>#error</code>の利用例としては、<code>#if</code>と組み合わせるものがある。以下の例はCHAR_BITが8でなければコンパイルエラーになるソースファイルだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&lt;climits&gt;</span>

<span class="pp">#if CHAR_BIT != 8</span>
<span class="pp">#error CHAR_BIT != 8 implementation is not supported.</span>
<span class="pp">#endif</span></code></pre></div>
<p><code>#if</code>が処理されなければ、その中にある<code>#error</code>も処理されないので、コンパイルエラーにはならない。</p>
<h2 id="pragmra">#pragmra</h2>
<p><code>#pragmra</code>ディレクティブは実装依存の処理を行う。<code>#pragma</code>はコンパイラー独自の拡張機能を追加する文法として使われている。</p>
<p>文法は以下の通り。</p>
<pre><code>#pragma プリプロセッサートークン列 改行文字</code></pre>
<p>C++では属性が追加されたために、<code>#pragma</code>を使う必要はほとんどなくなっている。</p>
<h2 id="nullディレクティブ">Nullディレクティブ</h2>
<p><code>Null</code>ディレクティブとは何もしないプリプロセッサーディレクティブだ。</p>
<pre><code># 改行文字</code></pre>
<p>つまり、単に<code>#</code>とだけ書いた行はエラーにはならない。</p>
<h2 id="定義済みマクロ名">定義済みマクロ名</h2>
<p>いくつかのマクロ名がプリプロセッサーによって予め定義されている。</p>
<table>
<colgroup>
<col width="43%" />
<col width="17%" />
<col width="39%" />
</colgroup>
<thead>
<tr class="header">
<th>マクロ名</th>
<th align="left">値</th>
<th align="left">意味</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>__cplusplus</td>
<td align="left">201703L</td>
<td align="left">C++17時点での値<br />
将来の規格で増やされる</td>
</tr>
<tr class="even">
<td>__DATE__</td>
<td align="left">&quot;Mmm dd yyyy&quot;</td>
<td align="left">ソースファイルがプリプロセスされた日付 Mmmは月、ddは日、yyyyは年<br />
月の文字列はasctimeが生成するものと同じ<br />
日が1桁の場合、ddの最初の文字は空白文字</td>
</tr>
<tr class="odd">
<td>__FILE__</td>
<td align="left">文字列リテラル</td>
<td align="left">ソースファイルの名前の文字列リテラル</td>
</tr>
<tr class="even">
<td>__LINE__</td>
<td align="left">整数リテラル</td>
<td align="left">ソースファイルの現在の行番号</td>
</tr>
<tr class="odd">
<td>__STDC_HOSTED__</td>
<td align="left">整数リテラル</td>
<td align="left">ホスト実装の場合1<br />
フリースタンディング実装の場合0</td>
</tr>
<tr class="even">
<td>__STDCPP_DEFAULT_NEW_ALIGNMENT__</td>
<td align="left">整数リテラル</td>
<td align="left">アライメント</td>
</tr>
</tbody>
</table>
</body>
</html>
