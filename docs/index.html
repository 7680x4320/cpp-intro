<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="江添 亮" />
  <meta name="date" content="2018-02-27" />
  <title>江添亮のC++入門</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  <style>
  pre > code
  {
      display : block ;
      font-family : monospace ;
      font-size : x-large ;
      border-style : solid ;
      border-width : medium ;
      border-color : black ;
      border-radius : 0.4em ;
      padding : 0.5em ;
      word-wrap : break-word ;
      white-space : pre-wrap ;
  }
  
  h1,h2,h3,h4,h5,h6
  {
      font-size : 2em ;
      font-weight : bold ;
  }
  
  table, th, td {
      border: 1px solid black;
      border-collapse: collapse;
      padding : 0.5em ;
  }
  </style>
</head>
<body>
<div id="header">
<h1 class="title">江添亮のC++入門</h1>
<h2 class="author">江添 亮</h2>
<h3 class="date">2018-02-27</h3>
</div>
<div id="TOC">
<ul>
<li><a href="#序">序</a></li>
<li><a href="#cの概要">C++の概要</a></li>
<li><a href="#cの実行">C++の実行</a><ul>
<li><a href="#cの実行の仕組み">C++の実行の仕組み</a></li>
<li><a href="#簡単な一つのソースファイルからなるプログラムの実行">簡単な一つのソースファイルからなるプログラムの実行</a><ul>
<li><a href="#サンプルコード">サンプルコード</a></li>
<li><a href="#コンパイル">コンパイル</a></li>
<li><a href="#実行">実行</a></li>
</ul></li>
<li><a href="#gcc-cコンパイラー">GCC: C++コンパイラー</a><ul>
<li><a href="#コンパイラーオプション">コンパイラーオプション</a></li>
<li><a href="#ヘッダーファイルの省略">ヘッダーファイルの省略</a></li>
<li><a href="#コンパイル済みヘッダーprecompiled-header">コンパイル済みヘッダー(precompiled header)</a></li>
</ul></li>
<li><a href="#make-ビルドシステム">Make: ビルドシステム</a><ul>
<li><a href="#コンパイルと実行のまとめ">コンパイルと実行のまとめ</a></li>
<li><a href="#依存関係を解決するビルドシステム">依存関係を解決するビルドシステム</a></li>
<li><a href="#依存関係を記述するルール">依存関係を記述するルール</a></li>
<li><a href="#コメント">コメント</a></li>
<li><a href="#変数">変数</a></li>
<li><a href="#自動変数">自動変数</a><ul>
<li><a href="#ターゲット"><code>$@</code> ターゲット</a></li>
<li><a href="#最初の事前要件"><code>$&lt;</code> 最初の事前要件</a></li>
<li><a href="#すべての事前要件"><code>$^</code> すべての事前要件</a></li>
<li><a href="#自動変数の組み合わせ">自動変数の組み合わせ</a></li>
</ul></li>
<li><a href="#phonyターゲット">PHONYターゲット</a></li>
</ul></li>
<li><a href="#入門用の環境構築">入門用の環境構築</a></li>
</ul></li>
<li><a href="#cヒッチハイクガイド">C++ヒッチハイクガイド</a><ul>
<li><a href="#最小のコード">最小のコード</a></li>
<li><a href="#標準出力">標準出力</a></li>
<li><a href="#文字列">文字列</a></li>
<li><a href="#整数と浮動小数点数">整数と浮動小数点数</a></li>
<li><a href="#変数variable">変数(variable)</a></li>
<li><a href="#関数function">関数(function)</a></li>
<li><a href="#本当の関数">本当の関数</a></li>
</ul></li>
<li><a href="#デバッグコンパイルエラーメッセージの読み方">デバッグ：コンパイルエラーメッセージの読み方</a><ul>
<li><a href="#文法エラー">文法エラー</a></li>
<li><a href="#意味エラー">意味エラー</a></li>
<li><a href="#コンパイラーのバグ">コンパイラーのバグ</a></li>
</ul></li>
<li><a href="#条件分岐の果てのレストラン">条件分岐の果てのレストラン</a><ul>
<li><a href="#複合文">複合文</a></li>
<li><a href="#条件分岐">条件分岐</a></li>
<li><a href="#条件式">条件式</a><ul>
<li><a href="#条件とは何だろう">条件とは何だろう</a></li>
</ul></li>
<li><a href="#bool型">bool型</a></li>
<li><a href="#bool型の演算">bool型の演算</a><ul>
<li><a href="#論理否定-operator">論理否定: operator !</a></li>
<li><a href="#同値比較-operator">同値比較: operator ==, !=</a></li>
<li><a href="#論理積-operator">論理積: operator &amp;&amp;</a></li>
<li><a href="#論理和-operator">論理和: operator ||</a></li>
<li><a href="#短絡評価">短絡評価</a></li>
</ul></li>
<li><a href="#boolの変換">boolの変換</a></li>
</ul></li>
<li><a href="#デバッグ-コンパイル警告メッセージ">デバッグ: コンパイル警告メッセージ</a></li>
<li><a href="#最近体重が気になるあなたのための標準入力">最近体重が気になるあなたのための標準入力</a><ul>
<li><a href="#これまでのおさらい">これまでのおさらい</a></li>
<li><a href="#標準入力">標準入力</a></li>
<li><a href="#リダイレクト">リダイレクト</a></li>
<li><a href="#パイプ">パイプ</a></li>
<li><a href="#プログラムの組み合わせ">プログラムの組み合わせ</a></li>
</ul></li>
<li><a href="#ループ">ループ</a><ul>
<li><a href="#これまでのおさらい-1">これまでのおさらい</a></li>
<li><a href="#goto文">goto文</a><ul>
<li><a href="#無限ループ">無限ループ</a></li>
<li><a href="#終了条件付きループ">終了条件付きループ</a></li>
<li><a href="#インデックスループ">インデックスループ</a></li>
</ul></li>
<li><a href="#while文">while文</a><ul>
<li><a href="#無限ループ-1">無限ループ</a></li>
</ul></li>
<li><a href="#終了条件付きループ-1">終了条件付きループ</a><ul>
<li><a href="#インデックスループ-1">インデックスループ</a></li>
</ul></li>
<li><a href="#for文">for文</a></li>
<li><a href="#do文">do文</a></li>
<li><a href="#break文">break文</a></li>
<li><a href="#continue文">continue文</a></li>
<li><a href="#再帰関数">再帰関数</a></li>
</ul></li>
<li><a href="#メモリを無限に確保する">メモリを無限に確保する</a><ul>
<li><a href="#これまでのまとめ">これまでのまとめ</a></li>
<li><a href="#vector">vector</a></li>
</ul></li>
<li><a href="#デバッグprintfデバッグ">デバッグ：printfデバッグ</a><ul>
<li><a href="#実践例">実践例</a></li>
<li><a href="#stdcerr"><code>std::cerr</code></a></li>
<li><a href="#まとめ">まとめ</a></li>
</ul></li>
<li><a href="#整数">整数</a><ul>
<li><a href="#整数リテラル">整数リテラル</a><ul>
<li><a href="#進数リテラル">10進数リテラル</a></li>
<li><a href="#進数リテラル-1">2進数リテラル</a></li>
<li><a href="#進数リテラル-2">8進数リテラル</a></li>
<li><a href="#進数リテラル-3">16進数リテラル</a></li>
<li><a href="#数値区切り">数値区切り</a></li>
</ul></li>
<li><a href="#整数の仕組み">整数の仕組み</a><ul>
<li><a href="#情報の単位">情報の単位</a></li>
<li><a href="#バイトで表現された整数">1バイトで表現された整数</a><ul>
<li><a href="#符号ビット">符号ビット</a></li>
<li><a href="#の補数">1の補数</a></li>
<li><a href="#の補数-1">2の補数</a></li>
</ul></li>
</ul></li>
<li><a href="#整数型">整数型</a><ul>
<li><a href="#int型">int型</a></li>
<li><a href="#long-int型">long int型</a></li>
<li><a href="#long-long-int型">long long int型</a></li>
<li><a href="#short-int型">short int型</a></li>
<li><a href="#char型">char型</a></li>
</ul></li>
<li><a href="#整数型のサイズ">整数型のサイズ</a></li>
<li><a href="#整数型の表現できる値の範囲">整数型の表現できる値の範囲</a></li>
<li><a href="#整数型の変換">整数型の変換</a></li>
</ul></li>
<li><a href="#浮動小数点数">浮動小数点数</a><ul>
<li><a href="#浮動小数点数リテラル">浮動小数点数リテラル</a></li>
<li><a href="#進浮動小数点数リテラル">10進浮動小数点数リテラル</a><ul>
<li><a href="#進数の仮数と指数による表記">10進数の仮数と指数による表記</a></li>
<li><a href="#進数の仮数と指数による表記-1">16進数の仮数と指数による表記</a></li>
</ul></li>
<li><a href="#浮動小数点数の表現と特性">浮動小数点数の表現と特性</a><ul>
<li><a href="#と-0.0">+0.0と-0.0</a></li>
<li><a href="#と-無限大">+∞と-∞(無限大)</a></li>
<li><a href="#nannot-a-number">NaN(Not a Number)</a></li>
<li><a href="#有効桁数">有効桁数</a></li>
</ul></li>
<li><a href="#浮動小数点数同士の変換">浮動小数点数同士の変換</a></li>
<li><a href="#浮動小数点数と整数の変換">浮動小数点数と整数の変換</a></li>
</ul></li>
<li><a href="#名前">名前</a><ul>
<li><a href="#キーワード">キーワード</a></li>
<li><a href="#名前に使える文字">名前に使える文字</a></li>
<li><a href="#宣言と定義">宣言と定義</a></li>
<li><a href="#名前空間">名前空間</a><ul>
<li><a href="#グローバル名前空間">グローバル名前空間</a></li>
<li><a href="#名前空間のネスト">名前空間のネスト</a></li>
<li><a href="#名前空間名の別名を宣言する名前空間エイリアス">名前空間名の別名を宣言する名前空間エイリアス</a></li>
<li><a href="#名前空間名の指定を省略するusingディレクティブ">名前空間名の指定を省略するusingディレクティブ</a></li>
<li><a href="#名前空間を指定しなくてもよいinline名前空間">名前空間を指定しなくてもよいinline名前空間</a></li>
</ul></li>
<li><a href="#型名">型名</a><ul>
<li><a href="#型名の別名を宣言するエイリアス宣言">型名の別名を宣言するエイリアス宣言</a></li>
</ul></li>
<li><a href="#スコープ">スコープ</a></li>
</ul></li>
<li><a href="#イテレーターの基礎">イテレーターの基礎</a><ul>
<li><a href="#イテレーターの取得方法">イテレーターの取得方法</a></li>
<li><a href="#イテレーターの参照する要素に対する読み書き">イテレーターの参照する要素に対する読み書き。</a></li>
<li><a href="#イテレーターの参照する要素を変更">イテレーターの参照する要素を変更</a></li>
<li><a href="#イテレーターの比較">イテレーターの比較</a></li>
<li><a href="#最後の次の要素へのイテレーター">最後の次の要素へのイテレーター</a></li>
<li><a href="#なんでもイテレーター">なんでもイテレーター</a></li>
<li><a href="#イテレーターと添字の範囲">イテレーターと添字の範囲</a></li>
</ul></li>
<li><a href="#ポップカルチャーリファレンス">ポップカルチャーリファレンス</a></li>
<li><a href="#cプリプロセッサー">Cプリプロセッサー</a><ul>
<li><a href="#includeディレクティブ">#includeディレクティブ</a></li>
<li><a href="#define">#define</a><ul>
<li><a href="#オブジェクト風マクロ">オブジェクト風マクロ</a></li>
<li><a href="#関数風マクロ">関数風マクロ</a></li>
<li><a href="#va_args__可変長引数マクロ"><code>__VA_ARGS__</code>(可変長引数マクロ)</a></li>
<li><a href="#va_opt__"><code>__VA_OPT__</code></a></li>
<li><a href="#演算子">#演算子</a></li>
<li><a href="#演算子-1">##演算子</a></li>
<li><a href="#複数行の置換リスト">複数行の置換リスト</a></li>
<li><a href="#undefディレクティブ">#undefディレクティブ</a></li>
</ul></li>
<li><a href="#条件付きソースファイル選択">条件付きソースファイル選択</a><ul>
<li><a href="#プリプロセッサーの定数式">プリプロセッサーの定数式</a></li>
<li><a href="#ifディレクティブ">#ifディレクティブ</a></li>
<li><a href="#elifディレクティブ">#elifディレクティブ</a></li>
<li><a href="#elseディレクティブ">#elseディレクティブ</a></li>
<li><a href="#ifdef-ifndefディレクティブ">#ifdef, #ifndefディレクティブ</a></li>
</ul></li>
<li><a href="#lineディレクティブ">#lineディレクティブ</a></li>
<li><a href="#errorディレクティブ">#errorディレクティブ</a></li>
<li><a href="#pragmra">#pragmra</a></li>
<li><a href="#nullディレクティブ">Nullディレクティブ</a></li>
<li><a href="#定義済みマクロ名">定義済みマクロ名</a></li>
</ul></li>
</ul>
</div>
<h1 id="序">序</h1>
<p>本書はプログラミング経験者向けのC++入門書である。</p>
<p>本書の対象読者は、すでに何らかの実用的なプログラミング言語を習得していることを想定し、プログラミングの初歩的な概念はすべて理解しているものとして説明しない。そのため、本書には、「変数は箱のようなものである」といったような説明は出てこない。ただし、主要な他の言語とC++として特別に注意が必要な差は解説している。</p>
<h1 id="cの概要">C++の概要</h1>
<p>C++とは何か。C++の原作者にして最初の実装者であるBjarne Stroustrupは、以下のように簡潔にまとめている。</p>
<blockquote>
<p>C++は、Simulaのプログラム構造化のための機構と、Cのシステムプログラミング用の効率性と柔軟性を提供するために設計された。C++は半年ほどで現場で使えることを見込んでいた。結果として成功した。</p>
<p>Bjarne Stroustrup, A Hisotory of C++: 1979-1991, HOPL2</p>
</blockquote>
<p>プログラミング言語史に詳しくない読者は、Simulaというプログラミング言語について知らないことだろう。Simulaというのは、初めてオブジェクト指向プログラミングを取り入れたプログラミング言語だ。当時と言えばまだ高級なプログラミング言語はほとんどなく、if else, whileなどのIBMの提唱した構造化プログラミングを可能にする文法を提供しているプログラミング言語すら、多くは研究段階であった。いわんやオブジェクト指向など、当時はまだアカデミックにおいて可能性の一つとして研究されている程度の地に足のついていない夢の機能であった。そのような粗野な時代において、Simulaは先進的なオブジェクト指向プログラミングを実現していた。</p>
<p>問題は、Simulaの設計と実装では実行速度が遅く、大規模なプログラムを開発するには適さなかった。</p>
<p>Cの効率性と柔軟性というのは、要するに実行速度が速いとかメモリ消費量が少ないということだ。なぜCは他の言語に比べて効率と柔軟に優れているのか。これには2つの理由がある。</p>
<p>ひとつ、Cのコードは直接ハードウェアがサポートする命令にまでマッピング可能であるということ。現実のハードウェアにはストレージがあり、メモリがあり、キャッシュがあり、レジスターがあり、命令は投機的に並列実行される泥臭い計算機能を提供している。</p>
<p>ひとつ、使わない機能のコストを支払う必要がないというゼロオーバーヘッドの原則。例えばあらゆるメモリ利用がGCによって管理されている言語では、たとえメモリをすべて明示的に管理していたとしても、GCのコストを支払わなければならない。実行時にメモリレイアウトを判定して実行時に分岐処理ができる言語では、たとえコンパイル時にメモリレイアウトが決定されていたとしても、実行時にメモリレイアウトを判定して条件分岐するコストを支払わなければならない。</p>
<p>C++は、「アセンブリ言語をおいて、C++より下に言語を置かない」と宣言するほど、ハードウェア機能への直接マッピングとゼロオーバーヘッドの原則を重視している。</p>
<p>C++の他の特徴としては、委員会方式による国際標準規格を定めていることがある。特定の一個人や一法人が所有する言語は、個人や法人の意思で簡単に仕様が変わってしまう。短期的な利益を追求するために長期的に問題となる変更をしたり、単一の実装が仕様だと言わんばかりの振る舞いをする。特定の個人や法人に所有されていないこと、実装が従うべき標準規格があること、独立した実装が複数あること、言語に利害関係を持つ関係者が議論して投票で変更を可決すること、これがC++が長期に渡って使われてきた理由でもある。</p>
<p>委員会方式の規格制定では、下位互換性の破壊は忌避される。なぜならば、既存の動いているコードを壊すということは、それまで存在していた資産の価値を毀損することであり、利害関係を持つ委員が反対するからだ。</p>
<p>下位互換性を壊した結果何が起こるかと言うと、単に言語が新旧2つに分断される。Python 2とPython 3がその最たる例だ。</p>
<p>C++には今日の最新で高級な言語からみれば古風な制約が数多く残っているが、いずれも理由がある。下位互換性を壊すことができないという理由。効率的な実装方法が存在しないという理由。仮に効率的な実装が存在するにしても、様々な環境で実装可能でなければ規格化はできないという理由。</p>
<p>C++には良し悪しがある。Bjarne StroustrupはC++への批判にこう答えている。</p>
<blockquote>
<p>言語には2種類ある。文句を言われる言語と、誰も使わない言語。</p>
</blockquote>
<p>C++は文句を言われる方の言語だ。</p>
<h1 id="cの実行">C++の実行</h1>
<p>プログラミング言語を学ぶには、まず書いたソースコードをプログラムとして実行できるようになることが重要だ。自分が正しく理解しているかどうかを確認するために書いたコードが期待通りに動くことを確かめてこそ、正しい理解が確認できる。</p>
<h2 id="cの実行の仕組み">C++の実行の仕組み</h2>
<p>C++は慣習的に、ソースファイルをコンパイルしてオブジェクトファイルを生成し、オブジェクトファイルをリンクして実行可能ファイルを生成し、実行可能ファイルを直接実行することで実行する言語だ。</p>
<p>他の言語では、ソースファイルをそのままパースし、解釈して実行するインタープリター形式の言語が多い。もっとも、今となってはソースファイルから中間言語に変換してVMで実行するとか、JITコンパイルしてネイティブコードを生成して実行するといった実装もあるため、昔のように単純にインタープリター型の言語ということはできなくなっている事情はある。ただし、最終的にJITコンパイルされてネイティブコードが実行される言語でも、コンパイルやコード生成はプログラマーが意識しない形で行われるため、プログラマーはコンパイラーを直接使う必要のない言語も多い。</p>
<p>C++はプログラマーが直接コンパイラーを使い、ソースファイルをプログラムに変換する言語だ。</p>
<h2 id="簡単な一つのソースファイルからなるプログラムの実行">簡単な一つのソースファイルからなるプログラムの実行</h2>
<p>ここでは、典型的なC++のソースファイルをどのようにコンパイルし実行するか、一連の流れを学ぶ。</p>
<h3 id="サンプルコード">サンプルコード</h3>
<p>以下のC++のソースファイルは標準出力にhelloと出力するものだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span>

<span class="dt">int</span> main()
{
    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;hello&quot;</span> ;
}</code></pre></div>
<p>コードの詳細な意味はさておくとして、このサンプルコードを使ってC++の実行までの流れを見ていこう。</p>
<p>まずは端末から作業用の適当な名前のディレクトリーを作る。ここでは<code>cpp</code>としておこう。ディレクトリーの作成は<code>mkdir</code>コマンドで行える。</p>
<pre><code>$ mkdir cpp
$ cd cpp</code></pre>
<p>好きなテキストエディターを使って上のサンプルコードをテキストファイルとして記述する。ファイル名は<code>hello.cpp</code>としておこう。</p>
<pre><code>$ vim hello.cpp</code></pre>
<p>C++のソースファイルの名前は何でもよいが、慣習で使われている拡張子がいくつかある。本書では<code>.cpp</code>を使う。</p>
<p>無事にソースファイルが作成できたかどうか確認してみよう。現在のカレントディレクトリー下のファイルの一覧を表示するには<code>ls</code>、ファイルの内容を表示するには<code>cat</code>を使う。</p>
<pre><code>$ ls
hello.cpp
$ cat hello.cpp
#include &lt;iostream&gt;

int main()
{
    std::cout &lt;&lt; &quot;hello&quot; ;
}</code></pre>
<h3 id="コンパイル">コンパイル</h3>
<p>さて、ソースファイルが用意できたならば、いよいよコンパイルだ。</p>
<p>C++のソースファイルから、実行可能ファイルを生成するソフトウェアをC++コンパイラーという。C++コンパイラーとしては、GCC(GNU Compiler Collection)とClang(クラン)がある。使い方はどちらもほぼ同じだ。</p>
<p>GCCを使って先程の<code>hello.cpp</code>をコンパイルするには以下のようにする。</p>
<pre><code>$ g++ -o hello hello.cpp</code></pre>
<p>GCCという名前のC++コンパイラーなのに<code>g++</code>なのは、<code>gcc</code>はC言語コンパイラーの名前としてすでに使われているからだ。この慣習はClangも引き継いでいて、ClangのC++コンパイラーは<code>clang++</code>だ。</p>
<p>サンプルコードを間違いなくタイプしていれば、カレントディレクトリに<code>hello</code>とぃう実行可能ファイルが作成されるはずだ。確認してみよう。</p>
<pre><code>$ ls
hello hello.cpp</code></pre>
<h3 id="実行">実行</h3>
<p>さて、いよいよ実行だ。通常のOSではカレントディレクトリがPATHに含まれていないため、実行するにはカレントディレクトリからパスを指定する必要がある。</p>
<pre><code>$ ./hello
hello</code></pre>
<p>上出来だ。初めてのC++プログラムが実行できた。さっそくC++を学んでいきたいところだが、その前にC++プログラミングに必要なツールの使い方を学ぶ必要がある。</p>
<h2 id="gcc-cコンパイラー">GCC: C++コンパイラー</h2>
<p>GCCはC++のソースファイルからプログラムを生成するC++コンパイラーだ。</p>
<p>GCCの基本的な使い方は以下の通り。</p>
<pre><code>g++ その他のオプション -o 出力するファイル名 ソースファイル名</code></pre>
<p>ソースファイル名は複数指定することができる。</p>
<pre><code>g++ -o abc a.cpp b.cpp c.cpp</code></pre>
<p>これについては分割コンパイルの章で詳しく解説する。</p>
<p>コンパイラーはメッセージを出力することがある。コンパイルメッセージには、エラーメッセージと警告メッセージとがある。</p>
<p>エラーメッセージというのは、ソースコードに文法上、意味上の誤りがあるため、コンパイルできない場合に生成される。エラーメッセージはエラーの箇所も教えてくれる。ただし、文法エラーは往々にして適切な誤りの箇所を指摘できないこともある。これは、C++の文法としては正しくないテキストファイルから、妥当なC++であればどういう間違いなのかを推測する必要があるためだ。</p>
<p>警告メッセージというのは、ソースコードにコンパイルを妨げる文法上、意味上の誤りは存在しないが、誤りの可能性が疑われる場合に出力される。</p>
<h3 id="コンパイラーオプション">コンパイラーオプション</h3>
<p>GCCのコンパイラーオプションをいくつか学んでいこう。</p>
<p><code>-std=</code>はC++の規格を選択するオプションだ。C++17に準拠したいのであれば<code>-std=c++17</code>を指定する。読者が本書を読む頃には、C++20や、あるいはもっと未来の規格が発行されているかもしれない。常に最新のC++規格を選択するオプションを指定するべきだ。</p>
<p><code>-Wall</code>はコンパイラーの便利な警告メッセージのほとんどすべてを有効にするオプションだ。コンパイラーによる警告メッセージはプログラムの不具合を未然に発見できるので、このオプションは指定すべきだ。</p>
<p><code>--pedantic-errors</code>はC++の規格を厳格に守るオプションだ。規格に違反しているコードがコンパイルエラー扱いになる。</p>
<p>これをまとめると、GCCは以下のように使う。</p>
<pre><code>g++ -std=c++17 -Wall --pedantic-errors -o 出力ファイル名 入力ファイル名</code></pre>
<p>ところで、GCCのオプションはとても多い。すべてを知りたい読者は、gccのマニュアルを読むとよい。</p>
<pre><code>$ man gcc</code></pre>
<h3 id="ヘッダーファイルの省略">ヘッダーファイルの省略</h3>
<p>先程のソースコードをもう一度見てみよう。冒頭に以下のような行がある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></code></pre></div>
<p>これは<code>#includeディレクティブ</code>(#include directive)といい、プリプロセッサー(preprocessor)の一部だ。プリプロセッサーについて詳しくは煩雑になるので巻末資料を参照してもらうとして、このコードは<code>iostream</code>ライブラリを使うために必要で、その意味としてはヘッダーファイル<code>iostream</code>を取り込みだ。</p>
<p>C++の標準ライブラリを使うには、ライブラリごとに対応した<code>#includeディレクティブ</code>を書かなければならない。それはあまりにも煩雑なので、本書では標準ライブラリのヘッダーファイルをすべて<code>#include</code>した<code>ヘッダーファイル</code>(header file)を作成し、それを<code>#include</code>することで、<code>#include</code>を書かなくてすむようにする。</p>
<p>そのためにはまず標準ライブラリのヘッダーファイルのほとんどすべてを<code>#include</code>したヘッダーファイル、<code>all.h</code>を作成する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&lt;cstddef&gt;</span>
<span class="pp">#include </span><span class="im">&lt;limits&gt;</span>
<span class="pp">#include </span><span class="im">&lt;climits&gt;</span>
<span class="pp">#include </span><span class="im">&lt;cfloat&gt;</span>
<span class="pp">#include </span><span class="im">&lt;cstdint&gt;</span>
<span class="pp">#include </span><span class="im">&lt;cstdlib&gt;</span>
<span class="pp">#include </span><span class="im">&lt;new&gt;</span>
<span class="pp">#include </span><span class="im">&lt;typeinfo&gt;</span>
<span class="pp">#include </span><span class="im">&lt;exception&gt;</span>
<span class="pp">#include </span><span class="im">&lt;initializer_list&gt;</span>
<span class="pp">#include </span><span class="im">&lt;cstdalign&gt;</span>
<span class="pp">#include </span><span class="im">&lt;stdexcept&gt;</span>
<span class="pp">#include </span><span class="im">&lt;cassert&gt;</span>
<span class="pp">#include </span><span class="im">&lt;cerrno&gt;</span>
<span class="pp">#include </span><span class="im">&lt;system_error&gt;</span>
<span class="pp">#include </span><span class="im">&lt;string&gt;</span>

<span class="pp">#if __has_include(&lt;string_view&gt;)</span>
<span class="pp">#   include </span><span class="im">&lt;string_view&gt;</span>
<span class="pp">#endif</span>

<span class="pp">#include </span><span class="im">&lt;array&gt;</span>
<span class="pp">#include </span><span class="im">&lt;deque&gt;</span>
<span class="pp">#include </span><span class="im">&lt;forward_list&gt;</span>
<span class="pp">#include </span><span class="im">&lt;list&gt;</span>
<span class="pp">#include </span><span class="im">&lt;vector&gt;</span>
<span class="pp">#include </span><span class="im">&lt;map&gt;</span>
<span class="pp">#include </span><span class="im">&lt;set&gt;</span>
<span class="pp">#include </span><span class="im">&lt;unordered_map&gt;</span>
<span class="pp">#include </span><span class="im">&lt;unordered_set&gt;</span>
<span class="pp">#include </span><span class="im">&lt;queue&gt;</span>
<span class="pp">#include </span><span class="im">&lt;stack&gt;</span>
<span class="pp">#include </span><span class="im">&lt;iterator&gt;</span>
<span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span>
<span class="pp">#include </span><span class="im">&lt;cfenv&gt;</span>
<span class="pp">#include </span><span class="im">&lt;random&gt;</span>
<span class="pp">#include </span><span class="im">&lt;numeric&gt;</span>
<span class="pp">#include </span><span class="im">&lt;cmath&gt;</span>
<span class="pp">#include </span><span class="im">&lt;iosfwd&gt;</span>
<span class="pp">#include </span><span class="im">&lt;iostream&gt;</span>
<span class="pp">#include </span><span class="im">&lt;ios&gt;</span>
<span class="pp">#include </span><span class="im">&lt;streambuf&gt;</span>
<span class="pp">#include </span><span class="im">&lt;istream&gt;</span>
<span class="pp">#include </span><span class="im">&lt;ostream&gt;</span>
<span class="pp">#include </span><span class="im">&lt;iomanip&gt;</span>
<span class="pp">#include </span><span class="im">&lt;sstream&gt;</span>
<span class="pp">#include </span><span class="im">&lt;fstream&gt;</span>

<span class="pp">#if __has_include(&lt;filesystem&gt;)</span>
<span class="pp">#   include </span><span class="im">&lt;filesystem&gt;</span>
<span class="pp">#endif</span>

<span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span>
<span class="pp">#include </span><span class="im">&lt;cinttypes&gt;</span>


<span class="pp">#include </span><span class="im">&lt;regex&gt;</span>
<span class="pp">#include </span><span class="im">&lt;atomic&gt;</span>
<span class="pp">#include </span><span class="im">&lt;thread&gt;</span>
<span class="pp">#include </span><span class="im">&lt;mutex&gt;</span>
<span class="pp">#include </span><span class="im">&lt;shared_mutex&gt;</span>
<span class="pp">#include </span><span class="im">&lt;condition_variable&gt;</span>
<span class="pp">#include </span><span class="im">&lt;future&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>literals ;</code></pre></div>
<p>このようなヘッダーファイル<code>all.h</code>を作成した後に、ソースファイルで以下のように書けば、他のヘッダーファイルを<code>#include</code>する必要がなくなる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&quot;all.h&quot;</span>

<span class="co">// その他のコード</span></code></pre></div>
<p><code>//</code>から行末まではコメントで、好きなテキストを書くことができる。</p>
<p>しかし、この最初の一行の<code>#include</code>も面倒だ。そこでGCCのオプション<code>-include</code>を使い、<code>all.h</code>を常に<code>#include</code>した扱いにする。</p>
<pre><code>$ g++ -include all.h -o program main.cpp</code></pre>
<p>このようにすると、<code>main.cpp</code>が以下のコードでもコンパイルできるようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// main.cpp</span>
<span class="co">// 面倒な#includeなどなし</span>

<span class="dt">int</span> main()
{
    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;hello&quot;</span> ;
}</code></pre></div>
<p>これでヘッダーファイルが省略できるようになった。</p>
<h3 id="コンパイル済みヘッダーprecompiled-header">コンパイル済みヘッダー(precompiled header)</h3>
<p>C++はソースファイルをコンパイルする必要がある言語だ。コンパイルには時間がかかる。コンパイルにどれだけ時間がかかっているかを計測するには、以下のようにするとよい。</p>
<pre><code>$ time g++ -std=c++17 -Wall --pedantic-errors -include all.h -o program main.cpp</code></pre>
<p>どうだろうか。読者の環境にもよるが、近くできるぐらいの時間がかかっているのではないだろうか。プログラミングの習得にはコードを書いてから実行までの時間が短い方がよい。そこで本格的にC++を学ぶ前に、コンパイル時間を短縮する方法を学ぶ。</p>
<p>プログラムで変更しないファイルを事前にコンパイルしておくと、変更した部分だけコンパイルすれば良いので、コンパイル時間の短縮になる。GCCでは、ヘッダーファイルを事前にコンパイルする特別な機能がある。標準ライブラリのヘッダーファイルは変更しないので、事前にコンパイルしておけばコンパイル時間の短縮になる。</p>
<p>事前にコンパイルしたヘッダーファイルのことをコンパイル済みヘッダー(precompiled header)という。</p>
<p>すでに作成した<code>all.h</code>はコンパイル済みヘッダーとするのに適切なヘッダーファイルだ。</p>
<p>コンパイル済みヘッダーファイルを作成するには、ヘッダーファイル単体をGCCに与え、出力するファイルを<code>ヘッダーファイル名.gch</code>とする。ヘッダーファイル名が<code>all.h</code>の場合、<code>all.h.gch</code>となる。</p>
<p>GCCのオプションには他のソースファイルをコンパイルするときと同じオプションを与えるほか、ヘッダーファイルがC++で書かれていることを示すオプション<code>-x c++-header</code>を与える。</p>
<pre><code>g++ -std=c++17 -Wall --pedantic-errors -x c++-header -o all.h.gch all.h</code></pre>
<p>こうすると、コンパイル済みヘッダーファイル<code>all.h.gch</code>が生成できる。</p>
<p>GCCはヘッダーファイルを使うときに、同名の.gchファイルが存在する場合は、そちらをコンパイル済みヘッダーファイルとして使うことで、ヘッダーファイルの処理を省略する。</p>
<pre><code>g++ -std=c++17 -Wall --pedantic-errors -include all.h -o program main.cpp</code></pre>
<p>コンパイル済みヘッダーは一回のコンパイルにつき一つしか使うことができない。そのため、コンパイル済みヘッダーとするヘッダーファイルを定め、そのヘッダーファイル内に他のヘッダーをすべて記述する。本書ではコンパイル済みヘッダーファイルとする元のヘッダーファイルの名前を<code>all.h</code>とする。</p>
<p>さっそくコンパイル時間の短縮効果を確かめてみよう。</p>
<pre><code>$ ls
all.h main.cpp
$ g++ -std=c++17 -Wall --pedantic-errors -x c++-header -o all.h.gch all.h
$ ls
all.h all.h.gch main.cpp
$ time g++ -std=c++17 -Wall --pedantic-errors -include all.h -o program main.cpp</code></pre>
<h2 id="make-ビルドシステム">Make: ビルドシステム</h2>
<h3 id="コンパイルと実行のまとめ">コンパイルと実行のまとめ</h3>
<p>ここまで、我々はソースファイルをコンパイルして実行可能ファイルを生成し、プログラムを実行する方法について学んできた。これまでに学んできたことを一連のコマンドで振り返ってみよう。</p>
<pre><code>$ ls
all.h main.cpp
$ cat all.h
#include &lt;iostream&gt;
$ cat main.cpp
int main() { std::cout &lt;&lt; &quot;hello&quot;s ; }</code></pre>
<p>まず、カレントディレクトリには<code>all.h</code>と<code>main.cpp</code>がある。この2つのファイルは実行可能ファイルを生成するために必要なファイルだ。今回、その中身は最小限にしてある。本当の<code>all.h</code>は、実際には前回書いたように長い内容になる。</p>
<pre><code>$ g++ -std=c++17 -Wall --pedantic-errors -x c++-header -o all.h.gch all.h
$ ls
all.h all.h.gch main.cpp</code></pre>
<p>次に、ソースファイルのコンパイルを高速化するために、ヘッダーファイル<code>all.h</code>から、コンパイル済みヘッダーファイル<code>all.h.gch</code>を生成する。</p>
<pre><code>$ g++ -std=c++17 -Wall --pedantic-errors -include all.h -o program main.cpp
$ ls
all.h all.h.gch main.cpp program</code></pre>
<p>プリコンパイル済みヘッダーファイル<code>all.h.gch</code>とC++ソースファイル<code>main.cpp</code>から、実行可能ファイル<code>program</code>を生成する。</p>
<pre><code>$ ./program
hello</code></pre>
<p>実行可能ファイル<code>program</code>を実行する。</p>
<p>これで読者はC++のプログラミングを学び始めるに当たって必要なことは全て学んだ。さっそくC++を学んでいきたいところだが、その前にもう一つ、ビルドシステムを学ぶ必要がある。</p>
<h3 id="依存関係を解決するビルドシステム">依存関係を解決するビルドシステム</h3>
<p>以上のC++のソースファイルからプログラムを実行するまでの流れは、C++のプログラムとしてはとても単純なものだが、それでも依存関係が複雑だ。</p>
<p>プログラムの実行にあたって最終的に必要なのはファイル<code>program</code>だが、このファイルはGCCで生成しなければならない。ところでGCCでファイル<code>program</code>を生成するには、事前に<code>all.h</code>, <code>all.h.gch</code>, <code>main.cpp</code>が必要だ。<code>all.h.gch</code>は<code>all.h</code>からGCCで生成しなければならない。</p>
<p>一度コンパイルしたプログラムのソースファイルを書き換えて再びコンパイルする場合はどうすればいいだろう。<code>main.cpp</code>だけを書き換えた場合、<code>all.h</code>は何も変更されていないので、コンパイル済みヘッダーファイル<code>all.h.gch</code>の再生性は必要ない。<code>all.h</code>だけを書き換えた場合は、<code>all.h.gch</code>を生成するだけでなく、<code>program</code>も再生成しなければならない。</p>
<p>プログラムのコンパイルには、このような複雑な依存関係の解決が必要になる。依存関係の解決を人間の手で行うのは大変だ。例えば読者が他人によって書かれた何千ものソースファイルと、プログラムをコンパイルする手順書だけを渡されたとしよう。手順書に従ってコンパイルをしたとして、ソースファイルの一部だけを変更した場合、一体どの手順は省略できるのか、手順書から導き出すのは難しい。するとコンパイルを最初からやり直すべきだろうか。しかし、一つのソースファイルのコンパイルに1秒かかるとして、何千ものソースファイルがある場合、何千秒もかかってしまう。たった一つのソースファイルを変更しただけですべてをコンパイルし直すのは時間と計算資源の無駄だ。</p>
<p>この依存関係の問題は、ビルドシステムによって解決できる。本書ではGNU Makeというビルドシステムを学ぶ。読者がこれから学ぶビルドシステムによって、以下のような簡単なコマンドだけで、他人の書いた何千ものソースファイルからなるプログラムがコンパイル可能になる。</p>
<p>何千ものソースファイルから実行可能ファイルを生成したい。</p>
<pre><code>$ make</code></pre>
<p>これだけだ。<code>make</code>というコマンド一つでプログラムのコンパイルは自動的に行われる。</p>
<p>何千ものソースファイルのうち、一つのソースファイルだけを変更し、必要な部分だけを効率よく再コンパイルしたい。</p>
<pre><code>$ make</code></pre>
<p>これだけだ。<code>make</code>というコマンド一つでプログラムの再コンパイルは自動的に行われる。</p>
<p>ところで、生成される実行可能ファイルの名前はプログラムごとに様々だ。プログラムの開発中は、共通の方法でプログラムを実行したい。</p>
<pre><code>$ make run</code></pre>
<p>これでどんなプログラム名でも共通の方法で実行できる。</p>
<p>ソースファイルから生成されたプログラムなどのファイルをすべて削除したい。</p>
<pre><code>$ make clean</code></pre>
<p>これで生成されたファイルをすべて削除できる</p>
<p>テキストエディターにはVimを使っているがわざわざVimからターミナルに戻るのが面倒だ。</p>
<pre><code>:make</code></pre>
<p>VimはノーマルモードからMakeを呼び出すことができる。もちろん、<code>:make run</code>や<code>:make clean</code>もできる</p>
<h3 id="依存関係を記述するルール">依存関係を記述するルール</h3>
<p>依存関係はどのように表現したらいいのだろうか。GNU makeでは<code>Makefile</code>という名前のファイルの中に、<code>ターゲット'(targets)、</code>事前要件<code>(prerequisites)、</code>レシピ<code>(recipes)という3つの概念で依存関係を</code>ルール<code>(rules)として記述する。</code>ルール`は以下の文法だ。</p>
<pre><code>ターゲット : 事前要件
[TAB文字]レシピ</code></pre>
<p>レシピは必ず<code>TAB文字</code>を直前に書かなければならない。スペース文字ではだめだ。これは<code>make</code>の初心者を混乱させる落とし穴の一つとなっている。忘れずに<code>TAB文字</code>を打とう。</p>
<p>問題を簡単に理解するために、以下のような状況を考えよう。</p>
<pre><code>$ ls
source
$ cat source &gt; program</code></pre>
<p>この例では、ファイル<code>program</code>を生成するためにはファイル<code>source</code>が必要だ。ファイル<code>source</code>はすでに存在している。</p>
<p><code>ターゲット</code>は生成されるファイル名だ。この場合<code>program</code>となる。</p>
<pre><code>program : 事前要件
    レシピ</code></pre>
<p><code>事前要件</code>は<code>ターゲット</code>を生成するために必要なファイル名だ。この場合<code>source</code>となる。</p>
<pre><code>program : source
    レシピ</code></pre>
<p><code>レシピ</code>は<code>ターゲット</code>を生成するために必要な動作だ。この場合、<code>cat source &gt; program</code>となる</p>
<div class="sourceCode"><pre class="sourceCode makefile"><code class="sourceCode makefile"><span class="dv">program :</span><span class="dt"> source</span>
    cat source &gt; program</code></pre></div>
<p>さっそくこのルールを、ファイル<code>Makefile</code>に書き込み、makeを呼び出してみよう。</p>
<pre><code>$ ls
Makefile source 
$ cat Makefile
program : source
    cat source &gt; program
$ make
cat source &gt; program
$ ls
Makefile program source</code></pre>
<p>これがMakeの仕組みだ。<code>ターゲット</code>の生成に必要な<code>事前要件</code>と、<code>ターゲット</code>を生成する<code>レシピ</code>を組み合わせた<code>ルール</code>で依存関係を記述する。makeを実行すると、実行した<code>レシピ</code>が表示される。</p>
<p>もうすこしMakeの<code>ルール</code>を追加してみよう。例えばファイル<code>source</code>は予め存在するのではなく、ファイル<code>source01</code>, <code>source02</code>, <code>source03</code>の中身をこの順番で連結して生成するとしよう。以下のように書ける。</p>
<div class="sourceCode"><pre class="sourceCode makefile"><code class="sourceCode makefile"><span class="dv">program :</span><span class="dt"> source</span>
    cat source &gt; program

<span class="dv">source :</span><span class="dt"> source01 source02 source03</span>
    cat source01 source02 source03 &gt; source</code></pre></div>
<p>GNU Makeはカレントディレクトリにあるファイル<code>Makefile</code>の一番上に書かれたルールを実行しようとする。<code>program</code>を生成するには<code>source</code>が必要だが、<code>source</code>の生成には別のルールの実行が必要だ。Makefileはこの依存関係を自動で解決してくれる。</p>
<pre><code>$ touch source01 source02 source03
$ ls
Makefile source01 source03 source03
$ make
cat source01 source02 source03 &gt; source
cat source &gt; program
$ ls
Makefile program source source01 source02 source03</code></pre>
<p>すでに<code>make</code>を実行した後で、もう一度<code>make</code>を実行するとどうなるだろうか。</p>
<pre><code>$make
make: &#39;program&#39; is up to date.</code></pre>
<p>このメッセージの意味は「programは最新だ」という意味だ。<code>make</code>はファイルのタイムスタンプを調べ、もしファイル<code>program</code>より<code>source</code>のタイムスタンプの方が若い場合、つまり<code>program</code>が変更されたよりも後に<code>source</code>が変更された場合、<code>ルール</code>を実行する。</p>
<p>ためしにファイル<code>source02</code>のタイムスタンプを更新してみよう。</p>
<pre><code>$ touch source02
$ make
cat source01 source02 source03 &gt; source
cat source &gt; program</code></pre>
<p>ファイル<code>source</code>は<code>事前要件</code>に<code>source02</code>を含む。<code>source02</code>のタイムスタンプが<code>source</code>より若いので、<code>source</code>が再び生成される。すると、<code>source</code>のタイムスタンプが<code>program</code>のタイムスタンプよりも若くなったので、<code>program</code>も生成される。</p>
<p>もう一つ例を見てみよう。</p>
<pre><code>$ touch a b c
$ ls
a b c Makefile</code></pre>
<p>あるディレクトリにファイル<code>a</code>, <code>b</code>, <code>c</code>がある。</p>
<p><code>Makefile</code>は以下の内容になっている。</p>
<pre><code>D : A B C
    cat A B C &gt; D

A : a
    cat a &gt; A

B : b
    cat b &gt; B

C : c
    cat c &gt; C</code></pre>
<p>この<code>Makefile</code>を呼び出したときに作られるのはファイル<code>D</code>だ。ファイル<code>D</code>を作るにはファイル<code>A</code>, <code>B</code>, <code>C</code>が必要だ。このファイルはそれぞれファイル<code>a</code>, <code>b</code>, <code>c</code>から生成されるルールが記述してある。</p>
<p>これを<code>make</code>すると以下のようにファイル<code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>が作られる。</p>
<pre><code>$ ls
a b c Makefile
$ make
cat a &gt; A
cat b &gt; B
cat c &gt; C
cat A B C &gt; D</code></pre>
<p>ここで、ファイル<code>b</code>のタイムスタンプだけを更新して<code>make</code>してみよう。</p>
<pre><code>$ touch b
$ make
cat b &gt; B
cat A B C &gt; D</code></pre>
<p>ファイル<code>b</code>のタイムスタンプがファイル<code>B</code>より若くなったので、ファイル<code>B</code>がターゲットとなったルールが再び実行される。ファイル<code>A</code>, <code>C</code>のルールは実行されない。そしてファイル<code>B</code>のタイムスタンプがファイル<code>D</code>より若くなったので、ファイル<code>D</code>がターゲットとなったルールが再び実行される。</p>
<p><code>make</code>により、処理する必要のあるルールだけが部分的に処理されていることがわかる。</p>
<p><code>make</code>は適切な<code>ルール</code>さえ書けば、依存関係の解決を自動的に行ってくれる。</p>
<h3 id="コメント">コメント</h3>
<p><code>Makefile</code>にはコメントを書くことができる。<code>#</code>で始まる行はコメント扱いされる。</p>
<div class="sourceCode"><pre class="sourceCode makefile"><code class="sourceCode makefile"><span class="co"># programを生成するルール</span>
<span class="dv">program :</span><span class="dt"> source</span>
    cat source &gt; program

<span class="co"># sourceを生成するルール</span>
<span class="dv">source :</span><span class="dt"> source01 source02 source03</span>
    cat source01 source02 source03 &gt; source</code></pre></div>
<h3 id="変数">変数</h3>
<p><code>Makefile</code>には<code>変数</code>を書くことができる。</p>
<p>変数の文法は以下の通り</p>
<pre><code>variable = foobar

target : $(variable)</code></pre>
<p>これは、</p>
<pre><code>target : foobar</code></pre>
<p>と書いたものと同じように扱われる。</p>
<p>変数は<code>=</code>の左側に変数名、右側に変数の内容を書く。</p>
<p>変数を使うときは、<code>$(変数名)</code>のように、<code>$()</code>で変数名を包む。</p>
<h3 id="自動変数">自動変数</h3>
<p>GNU Makeは便利なことに、いくつかの変数を自動で作ってくれる。</p>
<h4 id="ターゲット"><code>$@</code> ターゲット</h4>
<p><code>$@</code>はルールのターゲットのファイル名になる。</p>
<div class="sourceCode"><pre class="sourceCode makefile"><code class="sourceCode makefile"><span class="dv">target :</span>
    echo <span class="ch">$@</span></code></pre></div>
<p>このMakefileを実行すると以下のように出力される。</p>
<pre><code>$ make
echo target</code></pre>
<h4 id="最初の事前要件"><code>$&lt;</code> 最初の事前要件</h4>
<p><code>$&lt;</code>はルールの最初の事前要件のファイル名になる。</p>
<div class="sourceCode"><pre class="sourceCode makefile"><code class="sourceCode makefile"><span class="dv">target :</span><span class="dt"> A B C</span>
    echo <span class="ch">$&lt;</span></code></pre></div>
<p>このMakefileを実行すると以下のように出力される。</p>
<pre><code>$ make
echo A</code></pre>
<h4 id="すべての事前要件"><code>$^</code> すべての事前要件</h4>
<p><code>$^</code>はすべての事前要件のファイル名が空白区切りされたものになる</p>
<div class="sourceCode"><pre class="sourceCode makefile"><code class="sourceCode makefile"><span class="dv">target :</span><span class="dt"> A B C</span>
    echo <span class="ch">$^</span></code></pre></div>
<p>このMakefileを実行すると以下のように出力される。</p>
<pre><code>$ make
echo A B C</code></pre>
<h4 id="自動変数の組み合わせ">自動変数の組み合わせ</h4>
<p>例えば<code>ターゲット</code>を生成するために<code>事前要件</code>と<code>ターゲット</code>のファイル名をレシピに書く場合、</p>
<div class="sourceCode"><pre class="sourceCode makefile"><code class="sourceCode makefile"><span class="dv">target :</span><span class="dt"> prerequisite</span>
    cat prerequisite &gt; target</code></pre></div>
<p>と書く代わりに、</p>
<div class="sourceCode"><pre class="sourceCode makefile"><code class="sourceCode makefile"><span class="dv">target :</span><span class="dt"> prerequisite</span>
    cat <span class="ch">$&lt;</span> &gt; <span class="ch">$@</span></code></pre></div>
<p>と書ける。</p>
<h3 id="phonyターゲット">PHONYターゲット</h3>
<p>PHONYターゲットとは、ファイル名を意味せず、単にレシピを実行するターゲット名としてのみ機能するターゲットのことだ。</p>
<div class="sourceCode"><pre class="sourceCode makefile"><code class="sourceCode makefile"><span class="dv">hi :</span>
    echo hi

<span class="dv">hello :</span>
    echo hello</code></pre></div>
<p>これを実行すると以下のようになる。</p>
<pre><code>$ make
echo hi
hi
$make hi
echo hi
hi
$ make hello
echo hello
hello</code></pre>
<p><code>make</code>を引数を付けずに実行すると、一番上に書かれたルールが実行される。引数としてターゲットを指定すると、そのターゲットのルールと、依存するルールが実行される。</p>
<p>ただし、ターゲットと同じファイル名が存在すると、ルールは実行されない。</p>
<pre><code>$ touch hello
$ make hello
make: &#39;hello&#39; is up to date.</code></pre>
<p>GNU makeはこの問題に対処するため、<code>.PHONY</code>ターゲットという特殊な機能がある。これはPHONYターゲットを<code>.PHONY</code>ターゲットの事前要件とすることで、ターゲットと同じファイル名の存在の有無にかかわらずルールを実行させられる。</p>
<div class="sourceCode"><pre class="sourceCode makefile"><code class="sourceCode makefile"><span class="dv">hello :</span>
    echo hello

<span class="ot">.PHONY</span> <span class="ot">:</span><span class="dt"> hello</span></code></pre></div>
<p>PHONYターゲットはコンパイルしたプログラムの実行や削除に使うことができる。</p>
<div class="sourceCode"><pre class="sourceCode makefile"><code class="sourceCode makefile"><span class="dv">hello :</span><span class="dt"> hello.cpp</span>
    g++ -o <span class="ch">$@</span> <span class="ch">$&lt;</span>

<span class="dv">run :</span><span class="dt"> hello</span>
    ./hello

<span class="dv">clean :</span>
    rm -rf ./hello

<span class="ot">.PHONY</span> <span class="ot">:</span><span class="dt"> run clean</span></code></pre></div>
<h2 id="入門用の環境構築">入門用の環境構築</h2>
<p>以上を踏まえて、C++入門用の環境構築をしてこの章のまとめとする。</p>
<p>今回構築する環境のファイル名とその意味は以下の通り。</p>
<dl>
<dt>main.cpp</dt>
<dd>C++のコードを書く all.h
</dd>
<dd>標準ライブラリのヘッダーファイルを書く all.h.gch
</dd>
<dd>コンパイル済みヘッダー program
</dd>
<dd>実行可能ファイル Makefile
</dd>
<dd>GNU makeのルールを書く
</dd>
</dl>
<p>使い方は以下の通り。</p>
<dl>
<dt>make</dt>
<dd>コンパイルする make run
</dd>
<dd>コンパイルして実行 make clean
</dd>
<dd>コンパイル結果を削除
</dd>
</dl>
<p>GCCに与えるコンパイラーオプションを変数にまとめる。</p>
<div class="sourceCode"><pre class="sourceCode makefile"><code class="sourceCode makefile"><span class="dt">gcc_options </span><span class="ch">=</span><span class="st"> -std=c++17 -Wall --pedantic-error</span></code></pre></div>
<p>言語はC++17、すべての警告を有効にし、企画準拠ではないコードはエラーとする。</p>
<p>プログラムをコンパイルする部分は以下の通り。</p>
<div class="sourceCode"><pre class="sourceCode makefile"><code class="sourceCode makefile"><span class="dv">program :</span><span class="dt"> main.cpp all.h all.h.gch</span>
    g++ <span class="ch">$(</span><span class="dt">gcc_options</span><span class="ch">)</span> -include all.h <span class="ch">$&lt;</span> -o <span class="ch">$@</span>

<span class="dv">all.h.gch :</span><span class="dt"> all.h</span>
    g++ <span class="ch">$(</span><span class="dt">gcc_options</span><span class="ch">)</span> -x c++-header -o <span class="ch">$@</span> <span class="ch">$&lt;</span></code></pre></div>
<p>実行可能ファイル<code>program</code>と、コンパイル済みヘッダー<code>all.h.gch</code>をコンパイルするルールだ。</p>
<p>PHONYターゲットは以下の通り。</p>
<div class="sourceCode"><pre class="sourceCode makefile"><code class="sourceCode makefile"><span class="dv">run :</span><span class="dt"> program</span>
    ./program

<span class="dv">clean :</span>
    rm -f ./program
    rm -f ./all.h.gch

<span class="ot">.PHONY</span> <span class="ot">:</span><span class="dt"> run clean</span></code></pre></div>
<p><code>make</code>でコンパイル。<code>make run</code>で実行。<code>make clean</code>でコンパイル結果の削除。</p>
<p>Makefile全体は以下のようになる。</p>
<p><sub>~</sub>makefile gcc_options = -std=c++17 -Wall --pedantic-error</p>
<p>program : main.cpp all.h all.h.gch g++ $(gcc_options) -include all.h $&lt; -o $@</p>
<p>all.h.gch : all.h g++ $(gcc_options) -x c++-header -o $@ $&lt;</p>
<p>run : program ./program</p>
<p>clean : rm -f ./program rm -f ./all.h.gch</p>
<p>.PHONY : run clean ~~</p>
<h1 id="cヒッチハイクガイド">C++ヒッチハイクガイド</h1>
<p>プログラミング言語の個々の機能の解説を理解するためには、まず言語の全体像を掴まなければならない。この章ではC++の様々なコードを一通り観光していく。ここではコードの詳細な解説はしない。</p>
<h2 id="最小のコード">最小のコード</h2>
<p>以下はC++の最小のコードだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main(){}</code></pre></div>
<p>暗号のようなコードで訳がわからないが、これが最小のコードだ。<code>main</code>というのは<code>main関数</code>のことだ。C++ではプログラムの実行はmain関数から始まる。</p>
<p>ソースコードにコメントを記述して、もう少しわかりやすく書いてみよう。</p>
<pre><code>int     // 関数の戻り値の型
main    // 関数名
()      // 関数の引数
{       // 関数の始まり
    // 実行される処理
}       // 関数の終わり</code></pre>
<p><code>//</code>から行末まではコメントだ。コメントには好きなことを書くことができる。</p>
<p>このコードと一つ前のコードは、コメントの有無を別にすれば何の違いもない。このコードで使っている、<code>int</code>とか<code>main</code>とか記号文字の一つ一つをトークン(token)と呼ぶ。C++ではトークンの間に空白文字や改行文字をいくら使ってもよい。</p>
<p>なので、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main(){ }</code></pre></div>
<p>と書くこともできるし、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span>    main    (    )    {   }</code></pre></div>
<p>と書くこともできるし、紙に印刷する都合上とても読みづらくなるかもしれないが</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span>
main
(
)
{
}</code></pre></div>
<p>と書くこともできる。</p>
<p>ただし、トークンの途中で空白文字や改行文字を使うことはできない。以下のコードは間違っている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">i
nt ma in(){}</code></pre></div>
<h2 id="標準出力">標準出力</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// helloと改行を出力するプログラム</span>
<span class="dt">int</span> main()
{
    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;hello&quot;</span>s ;
}</code></pre></div>
<p>標準出力はプログラムの基本だ。C++で標準出力する方法はいくつもあるが、&lt;iostream&gt;ライブラリを利用するものが最も簡単だ。</p>
<p><code>std::cout</code>は標準出力を使うためのライブラリだ。</p>
<p><code>&lt;&lt;</code>は<code>operator &lt;&lt;</code>という演算子だ。C++では演算子にも名前がついていて、例えば<code>+</code>は<code>operator +</code>となる。<code>&lt;&lt;</code>も演算子の一種だ。</p>
<p><code>&quot;hello&quot;s</code>というのは文字列で、二重引用符で囲まれた中の文字列が標準出力に出力される。</p>
<p>セミコロン<code>;</code>は文の区切り文字だ。C++では文の区切りは明示的にセミコロンを書く必要がある。他の言語では改行文字を文脈から判断して文の区切りとみなすこともあるが、C++では明示的に文の区切り文字としてセミコロンを書かなければならない。</p>
<p>セミコロンを書き忘れるとエラーとなる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// エラー！　セミコロンがない</span>
    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;error&quot;</span>s
}</code></pre></div>
<p>複数の文を書いてみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;one &quot;</span>s ;
    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;two &quot;</span>s ;
    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;three &quot;</span>s ;
}</code></pre></div>
<p>C++は他の多くの言語と同じように、逐次実行される。つまり、コードは書いた順番に実行される。そして標準出力のような外部への副作用は、実行された順番で出力される。このコードを実行した結果は以下の通り。</p>
<pre><code>one two three </code></pre>
<p>&quot;three two one &quot;や&quot;two one three &quot;のような出力結果にはならない。</p>
<p>C++を含む多くの言語で<code>a + b + c</code>と書けるように、<code>opeartor &lt;&lt;</code>も<code>a &lt;&lt; b &lt;&lt; c</code>と書ける。<code>operator &lt;&lt;</code>で標準出力をするには、左端は<code>std::cout</code>でなければならない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;aaa&quot;</span>s &lt;&lt; <span class="st">&quot;bbb&quot;</span>s &lt;&lt; <span class="st">&quot;ccc&quot;</span>s ;
}</code></pre></div>
<p>出力は<code>aaabbbccc</code>となる。</p>
<h2 id="文字列">文字列</h2>
<p>二重引用符で囲まれた文字列を、文字通り<code>文字列</code>という。文字列には末尾にsがつくものとつかないものがある。これには違いがあるのだが、わからないうちはsを付けておいたほうが便利だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// これは文字列</span>
    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;hello&quot;</span>s ;
    <span class="co">// これも文字列、ただし不便</span>
    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;hello&quot;</span> ;
}</code></pre></div>
<p>文字列リテラルの中にバックスラッシュを書くと、エスケープシーケンスとして扱われる。最もよく使われるのは改行文字を表す<code>\n</code>だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;aaa</span><span class="sc">\n</span><span class="st">bbb</span><span class="sc">\n</span><span class="st">ccc&quot;</span>s ;
}</code></pre></div>
<p>これは以下のように出力される。</p>
<pre><code>aaa
bbb
ccc</code></pre>
<p>バックスラッシュを文字列で使いたい場合は<code>\\</code>と書かなければならない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// </span>
    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;</span><span class="sc">\\</span><span class="st">n is a new-line.</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
}</code></pre></div>
<p>文字列は演算子<code>operator +</code>で「足す」ことができる。「文字列を足す」というのは、「文字列を結合する」という意味だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;hello&quot;</span>s + <span class="st">&quot;world&quot;</span>s ;
}</code></pre></div>
<h2 id="整数と浮動小数点数">整数と浮動小数点数</h2>
<p>iostreamは文字列の他にも、整数や浮動小数点数を出力できる。早速試してみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>cout
        &lt;&lt; <span class="st">&quot;Integer: &quot;</span>s &lt;&lt; <span class="dv">42</span> &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s
        &lt;&lt; <span class="st">&quot;Floating Point: &quot;</span>s &lt;&lt; <span class="fl">3.14</span> ;
}</code></pre></div>
<p><code>-123</code>や<code>0</code>や<code>123</code>といった数値を整数という。<code>3.14</code>のような数値を浮動小数点数という。</p>
<p>数値を扱えるのだから、計算をしてみたいところだ。C++は整数同士の演算子として、四則演算(<code>+-*/</code>)や剰余(<code>%</code>)をサポートしている</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>cout
        &lt;&lt; <span class="dv">3</span> + <span class="dv">5</span> &lt;&lt; <span class="st">&quot; &quot;</span>s &lt;&lt; <span class="dv">3</span> - <span class="dv">5</span> &lt;&lt; <span class="st">&quot; &quot;</span>s
        &lt;&lt; <span class="dv">3</span> * <span class="dv">5</span> &lt;&lt; <span class="st">&quot; &quot;</span>s &lt;&lt; <span class="dv">3</span> / <span class="dv">5</span> &lt;&lt; <span class="st">&quot; &quot;</span>s
        &lt;&lt; <span class="dv">3</span> % <span class="dv">5</span> ;
}</code></pre></div>
<p>演算子は組み合わせて使うこともできる。その場合、演算子<code>*/%</code>は演算子<code>+-</code>よりも優先される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 7</span>
    <span class="bu">std::</span>cout &lt;&lt; <span class="dv">1</span> + <span class="dv">2</span> * <span class="dv">3</span> ;
}</code></pre></div>
<p>この場合、まず<code>2*3</code>が計算され6となり、<code>1+6</code>が計算され<code>7</code>となる。</p>
<p><code>1+2</code>の法を先に計算したい場合、括弧<code>()</code>で囲むことにより、計算の優先度を帰ることができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 9</span>
    <span class="bu">std::</span>cout &lt;&lt; (<span class="dv">1</span> + <span class="dv">2</span>) * <span class="dv">3</span> ;
}</code></pre></div>
<p>これは<code>1+2</code>が先に計算され<code>3</code>となり、<code>3*3</code>が計算され<code>9</code>となる。</p>
<p>浮動小数点数同士でも四則演算ができる。剰余はできない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>cout
        &lt;&lt; <span class="fl">3.5</span> + <span class="fl">7.11</span> &lt;&lt; <span class="st">&quot; &quot;</span>s &lt;&lt; <span class="fl">3.5</span> - <span class="fl">7.11</span> &lt;&lt; <span class="st">&quot; &quot;</span>s
        &lt;&lt; <span class="fl">3.5</span> * <span class="fl">7.11</span> &lt;&lt; <span class="st">&quot; &quot;</span>s &lt;&lt; <span class="fl">3.5</span> / <span class="fl">7.11</span> ;
}</code></pre></div>
<p>では整数と浮動小数点数を演算した場合どうなるのだろう。さっそく試してみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>cout &lt;&lt; <span class="dv">1</span> + <span class="fl">0.1</span> ;
}</code></pre></div>
<p>結果は<code>1.1</code>だ。整数と浮動小数点数を演算した結果は浮動小数点数になる。</p>
<p>そういえばC++には文字列もあるのだった。文字列と文字列は足すことができる。数値と数値も足すことができる。では数値と文字列を足すとどうなるのだろう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>cout &lt;&lt; <span class="dv">1</span> + <span class="st">&quot;234&quot;</span>s ;
}</code></pre></div>
<p>この結果はエラーになる。</p>
<p>いやまて、C++には末尾にsをつけない文字列もあるのだった。これも試してみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>cout &lt;&lt; <span class="dv">1</span> + <span class="st">&quot;234&quot;</span> ;
}</code></pre></div>
<p>結果はなんと<code>34</code>になるではないか。C++では謎の数学により<code>1 + &quot;234&quot; = &quot;34&quot;</code>であることが判明した。この謎はいずれ解き明かすとして、今は文字列には必ず末尾にsをつけることにしよう。そのほうが安全だ。</p>
<h2 id="変数variable">変数(variable)</h2>
<p>さあどんどんプログラミング言語によくある機能を見ていこう。次は変数だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 整数の変数</span>
    <span class="kw">auto</span> answer = <span class="dv">42</span> ;
    <span class="bu">std::</span>cout &lt;&lt; answer &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
    <span class="co">// 浮動小数点数の変数</span>
    <span class="kw">auto</span> pi = <span class="fl">3.14</span> ;
    <span class="bu">std::</span>cout &lt;&lt; pi &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;

    <span class="co">// 文字列の変数</span>
    <span class="kw">auto</span> question = <span class="st">&quot;Life, The Universe, and Everything.&quot;</span>s ;
    <span class="bu">std::</span>cout &lt;&lt; question ;
}</code></pre></div>
<p>変数はキーワード<code>auto</code>に続いて変数名を書き、<code>=</code>に続いて値を書くことで宣言できる。変数の宣言は文なので、文末にはセミコロンが必要だ。</p>
<pre><code>auto 変数名 = 値 ;</code></pre>
<p><code>変数名</code>はキーワード、アンダースコア(_)で始まる名前、アンダースコア2つ(__)を含む名前以外は自由に名付けることができる。</p>
<p>変数の最初の値は、<code>= 値</code>のかわりに<code>(値)</code>や<code>{値}</code>と書いてもよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> a = <span class="dv">1</span> ;
    <span class="kw">auto</span> b(<span class="dv">2</span>) ;
    <span class="kw">auto</span> c{<span class="dv">3</span>} ;
}</code></pre></div>
<p>この<code>=</code>, <code>()</code>, <code>{}</code>による変数の初期値の指定を、<code>初期化</code>という。</p>
<p>変数は使う前に宣言しなければならない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// エラー、名前xは宣言されていない</span>
    <span class="bu">std::</span>cout &lt;&lt; x ;
    <span class="kw">auto</span> x = <span class="dv">123</span> ;
}</code></pre></div>
<p>変数の値は初期化した後にも演算子<code>=</code>で変更できる。これを<code>代入</code>という。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 変数の宣言</span>
    <span class="kw">auto</span> x
    <span class="co">// 初期化</span>
    = <span class="dv">123</span> ;

    <span class="co">// 123</span>
    <span class="bu">std::</span>cout &lt;&lt; x ;

    <span class="co">// 代入</span>
    x = <span class="dv">456</span> ;

    <span class="co">// 456</span>
    <span class="bu">std::</span>cout &lt;&lt; x ;

    <span class="co">// もう一度代入</span>
    x = <span class="dv">789</span> ;
    <span class="co">// 789</span>
    <span class="bu">std::</span>cout &lt;&lt; x ;
}</code></pre></div>
<p>代入演算子<code>operator =</code>は左辺に変数名を、右辺に代入する値を書く。面白いこととして、右辺には代入する変数名そのものを書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> x = <span class="dv">10</span> ;
    x = x + <span class="dv">5</span> ;

    <span class="co">// 15</span>
    <span class="bu">std::</span>cout &lt;&lt; c ;
}</code></pre></div>
<p><code>operator =</code>は「代入」という意味で、「等号」という意味ではないからだ。<code>x=x+5</code>は、「<code>x</code>と<code>x+5</code>は等しい」という独創的な数学上の定義ではなく、「変数xに代入前の変数xの値に5を加えた数を代入する」という意味だ。</p>
<p>変数の今の値に対して演算した結果を変数に代入するという処理はとても良く使うので、C++には<code>x = x + a</code>と同じ意味で使える演算子、<code>operator +=</code>もある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> x = <span class="dv">1</span> ;
    <span class="co">// x = x + 5と同じ</span>
    x += <span class="dv">5</span> ;
}</code></pre></div>
<p><code>operator +=</code>と同様に、<code>operator -=</code>, <code>operator *=</code>, <code>operator /=</code>, <code>operator %=</code>もある。</p>
<p>C++の変数は、専門用語を使うと「静的型付け」になる。静的型付けと対比されるのが「動的型付け」だ。もっと難しく書くと、動的型付け言語の変数は、C++で言えば型情報付きの<code>void *</code>型の変数のような扱いを受ける。</p>
<p>C++の変数には<code>型</code>がある。<code>型</code>というのは値の種類を表す情報のことだ。</p>
<p>例えば、以下は変数が動的型付けの言語JavaScriptのコードだ。</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> x <span class="op">=</span> <span class="dv">1</span> <span class="op">;</span>
x <span class="op">=</span> <span class="st">&quot;hello&quot;</span> <span class="op">;</span>
x <span class="op">=</span> <span class="dv">2</span> <span class="op">;</span></code></pre></div>
<p>JavaScriptではこのコードは正しい。変数<code>x</code>は数値型であり、文字列型に代わり、また数値型に戻る。</p>
<p>C++ではこのようなコードは書けない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> x = <span class="dv">1</span> ;
    <span class="co">// エラー</span>
    x = <span class="st">&quot;hello&quot;</span>s ;
    x = <span class="dv">2</span> ;
}</code></pre></div>
<p>C++では、変数<code>x</code>は整数型であり、文字列型に変わることはない。整数型の変数に文字列型を代入しようとするとエラーとなる。</p>
<p>C++では型に名前がついている。整数型はint、浮動小数点数型はdouble、文字列型はstd::stringだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// iはint型</span>
    <span class="kw">auto</span> i = <span class="dv">123</span> ;
    <span class="co">// dはdouble型</span>
    <span class="kw">auto</span> d = <span class="fl">1.23</span> ;
    <span class="co">// sはstd::string型</span>
    <span class="kw">auto</span> s = <span class="st">&quot;123&quot;</span>s ;
}</code></pre></div>
<p>実は変数の宣言で<code>auto</code>と書くかわりに、具体的な型を書いてもよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">
<span class="dt">int</span> main()
{
    <span class="dt">int</span> i           = <span class="dv">123</span> ;
    <span class="dt">double</span> d        = <span class="fl">1.23</span> ;
    <span class="bu">std::</span>string s   = <span class="st">&quot;123&quot;</span>s ;
}</code></pre></div>
<p>整数型(int)と浮動小数点数型(double)はそれぞれお互いの型の変数に代入できる。ただし、変数の型は変わらない。単に一方の型の値がもう一方の型の値に変換されるだけだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 浮動小数点数型を整数型に変換</span>
    <span class="dt">int</span> a = <span class="fl">3.14</span> ;
    <span class="co">// 3</span>
    <span class="bu">std::</span>cout &lt;&lt; a &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;

    <span class="co">// 整数型を浮動小数点数型に変換</span>
    <span class="dt">double</span> d = <span class="dv">1</span> ;
    <span class="co">// 123</span>
    <span class="bu">std::</span>cout &lt;&lt; d ;
}</code></pre></div>
<p>浮動小数点数型を整数型に変換すると、小数部が切り捨てられる。この場合、<code>3.14</code>の小数部<code>0.14</code>が切り捨てられ<code>3</code>となる。<code>0.9999</code>も小数部が切り捨てられ<code>0</code>になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> i = <span class="fl">0.9999</span> ;
    <span class="co">// 0</span>
    <span class="bu">std::</span>cout &lt;&lt; i ;
}</code></pre></div>
<p>整数型を浮動小数点数型に変換すると、値を正確に表現できる場合はその値になる。正確に表現できない場合は近い値になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">double</span> d = <span class="dv">1234567890</span> ;
    <span class="co">// 正確に表現できるかどうかわからない</span>
    <span class="bu">std::</span>cout &lt;&lt; d ;
}</code></pre></div>
<p>整数型と浮動小数点数型の挙動については後の章で詳しく解説する。また、これ以外にも型はいくらでもあるし、読者が新しい型を作り出すこともできる。これも後の章で詳しく解説する。</p>
<h2 id="関数function">関数(function)</h2>
<p>「変数ぐらい知っている。さっさと教えてもらいたい。どうせC++の関数は書きづらいのだろう」と考える読者の皆さん、おまたせしました。こちらがC++の関数でございます。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 関数</span>
    <span class="kw">auto</span> print = [](<span class="kw">auto</span> x)
    {
        <span class="bu">std::</span>cout &lt;&lt; x &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
    } ;

    <span class="co">// 関数呼び出し</span>
    print(<span class="dv">123</span>) ;
    print(<span class="fl">3.14</span>) ;
    print(<span class="st">&quot;hello&quot;</span>) ;
}</code></pre></div>
<p>C++では関数も変数として扱える。<code>auto print =</code>までは変数だ。変数の初期化として関数を書いている。より正確にはラムダ式と呼ばれる関数を値として書くための文法だ。</p>
<p>ラムダ式は以下のような文法を持つ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">[] <span class="co">// ラムダ式導入部</span>
() <span class="co">// 引数</span>
{} <span class="co">// 本体</span></code></pre></div>
<p>ラムダ式は<code>[]</code>で始まり、<code>()</code>の中に引数を書き、<code>{}</code>の中の文が実行される。</p>
<p>例えば以下は引数を2回標準出力する関数だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> twice = [](<span class="kw">auto</span> x)
    {
        <span class="bu">std::</span>cout &lt;&lt; x &lt;&lt; <span class="st">&quot; &quot;</span>s &lt;&lt; x &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
    } ;

    twice(<span class="dv">5</span>) ;
}</code></pre></div>
<p>引数は<code>auto 引数名</code>で受け取れる。引数を複数取る場合は、カンマ<code>,</code>で区切る。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> print_two = []( <span class="kw">auto</span> x, <span class="kw">auto</span> y )
    {
        <span class="bu">std::</span>cout &lt;&lt; x &lt;&lt; <span class="st">&quot; &quot;</span>s &lt;&lt; y &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
    } ;

    print_two( <span class="dv">1</span>, <span class="dv">2</span> ) ;
    print_two( <span class="st">&quot;Pi is&quot;</span>, <span class="fl">3.14</span> ) ;
}</code></pre></div>
<p>引数を取らないラムダ式を書く場合は、単に<code>()</code>と書く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> no_args = []()
    {
        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Nothing.</span><span class="sc">\n</span><span class="st">&quot;</span> ;
    } ;

    no_args() ;
}</code></pre></div>
<p>関数は演算子<code>operator ()</code>を関数の直後に書いて呼び出す。これが演算子であるというのは少し不思議な感じがするが、C++では紛れもなく演算子だ。<code>operator +</code>とか<code>operator -</code>などと同じ演算子だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 何もしない関数</span>
    <span class="kw">auto</span> func = [](){} ;

    <span class="co">// operator ()の適用</span>
    func() ;
    <span class="co">// これもoperator ()</span>
    func    (   ) ;
}</code></pre></div>
<p>演算子<code>operator ()</code>は、ラムダ式そのものに対して適用することもできる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 変数fをラムダ式で初期化</span>
    <span class="kw">auto</span> f = [](){} ;
    <span class="co">// 変数fを関数呼び出し</span>
    f() ;

    <span class="co">// ラムダ式を関数呼び出し</span>
    [](){}() ;
}</code></pre></div>
<p>このコードを見ると、<code>operator ()</code>が単なる演算子であることがよくわかるだろう。<code>[](){}</code>がラムダ式でその直後の<code>()</code>が関数呼び出し演算子だ。</p>
<p>関数は値を返すことができる。関数から値を返すには、<code>return文</code>を使う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> plus = []( <span class="kw">auto</span> x, <span class="kw">auto</span> y )
        { <span class="cf">return</span> x + y ; } ;

    <span class="bu">std::</span>cout
        &lt;&lt; plus( <span class="dv">1</span>, <span class="dv">2</span> ) &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s
        &lt;&lt; plus( <span class="fl">1.5</span>, <span class="fl">0.5</span> ) &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s
        &lt;&lt; plus( <span class="st">&quot;123&quot;</span>, <span class="st">&quot;456&quot;</span>) ;
}</code></pre></div>
<p>関数はreturn文を実行すると処理を関数の呼び出し元に返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> f = []()
    {
        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;f is called.</span><span class="sc">\n</span><span class="st">&quot;</span> ;
        <span class="cf">return</span> <span class="dv">0</span> ; <span class="co">// ここで処理が戻る</span>
        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;f returned zero.</span><span class="sc">\n</span><span class="st">&quot;</span> ;
    } ;

    <span class="kw">auto</span> result = f() ;
}</code></pre></div>
<p>これを実行すると以下のようになる。</p>
<pre><code>$ make
f is called.</code></pre>
<p>return文以降の文が実行されていないことがわかる。</p>
<h2 id="本当の関数">本当の関数</h2>
<p>実はラムダ式は本当のC++の<code>関数</code>ではない。本当の<code>関数</code>はとても書きづらいので心して読むべきだ。</p>
<p>読者は本書の冒頭で使った<code>main関数</code>という言葉を覚えているだろうか。覚えていないとしても、サンプルコードに必ずと行っていいほど出てくる<code>main</code>という名前は気になっていたことだろう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main(){}</code></pre></div>
<p>これをみると、聡明な読者はラムダ式と似通ったところがあることに気づくだろう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">[](){}</code></pre></div>
<p>末尾の<code>(){}</code>が同じだ。これは同じ意味だ。<code>()</code>は関数の引数で、<code>{}</code>は関数の本体だ。</p>
<p>では残りの部分はどうだろうか。<code>int</code>は関数の戻り値の型、<code>main</code>は関数の名前だ。</p>
<p>C++の本当の関数は以下のような文法で定義される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span>     <span class="co">// 戻り値の型</span>
main    <span class="co">// 関数名</span>
()      <span class="co">// 関数の引数</span>
{}      <span class="co">// 関数の本体</span></code></pre></div>
<p>ためしに、int型の引数を2つ取り足して返す関数`plus'を書いてみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> plus( <span class="dt">int</span> x, <span class="dt">int</span> y )
{
    <span class="cf">return</span> x + y ;
}

<span class="dt">int</span> main()
{
    <span class="kw">auto</span> x = plus( <span class="dv">1</span>, <span class="dv">2</span> ) ;
}</code></pre></div>
<p>では次に、double型の引数を2つ取り足して返す関数<code>plus</code>を書いてみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span> plus( <span class="dt">double</span> x, <span class="dt">double</span> y )
{
    <span class="cf">return</span> x + y ;
}

<span class="dt">int</span> main()
{
    <span class="kw">auto</span> x = plus( <span class="fl">1.0</span>, <span class="fl">2.0</span> ) ;
}</code></pre></div>
<p>最後のstd::string型の引数を2つ取り足して返す関数<code>plus</code>は読者への課題とする。</p>
<p>これがC++の本当の関数だ。C++の関数では、型をすべて明示的に書かなければならない。型を間違えるとエラーだ。</p>
<p>しかも、C++の関数は、戻り値の型を正しく返さなければならない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> f()
{
    <span class="co">// エラー、return文がない</span>
}</code></pre></div>
<p>もし、何も値を返さない関数を書く場合は、どの値でもないという特別な型、<code>void</code>型を関数の戻り値の型として書かなければならないという特別なルールまである。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f()
{
    <span class="co">// OK</span>
}</code></pre></div>
<p>ただし、戻り値の型については、具体的な型の代わりに<code>auto</code>を書くこともできる。その場合、return文で同じ型さえ返していれば、気にする必要はない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// void</span>
<span class="kw">auto</span> a() { }
<span class="co">// int</span>
<span class="kw">auto</span> b() { <span class="cf">return</span> <span class="dv">0</span> ; }
<span class="co">// double</span>
<span class="kw">auto</span> c() { <span class="cf">return</span> <span class="fl">0.0</span> ; }
<span class="co">// std::string</span>
<span class="kw">auto</span> d() { <span class="cf">return</span> <span class="st">&quot;&quot;</span>s ; }

<span class="co">// エラー</span>
<span class="co">// return文の型が一致しない。</span>
<span class="kw">auto</span> e()
{
    <span class="cf">return</span> <span class="dv">0</span> ;
    <span class="cf">return</span> <span class="fl">0.0</span> ;
}</code></pre></div>
<h1 id="デバッグコンパイルエラーメッセージの読み方">デバッグ：コンパイルエラーメッセージの読み方</h1>
<p>やれやれ疲れた。この辺で一休みして、デバッグについて考えよう。まずはコンパイルエラーについてだ。</p>
<p>プログラムには様々なバグがあるが、コンパイルエラーは最も簡単なバグだ。というのも、プログラムのバグの存在が実行前に発覚したわけだから、手間が省ける。もしコンパイルエラーにならない場合、実行した結果から、バグがあるかどうかを判断しなければならない。</p>
<p>読者の中には、せっかく書いたソースコードをコンパイルしたらコンパイルエラーが出たので、運が悪かったとか、失敗したとか、怒られてつらい気持ちになったなどと感じることがあるかもしれない。しかしそれは大違いだ。コンパイラーによって読者はプログラムを実行することなくバグが発見できたのだから、読者は運が良かった、大成功した、褒められて最高の気持ちになったと感じるべきなのだ。</p>
<p>さあ皆さんご一緒に、</p>
<ul>
<li>コンパイルエラーは普通</li>
<li>コンパイルエラーが出たらありがとう</li>
<li>コンパイルエラーがでたら大喜び</li>
</ul>
<p>熟練のプログラマーは自分の書いたコードがコンパイルエラーを出さずに一発でコンパイルが通った場合、逆に不安になるくらいだ。</p>
<p>もしバグがあるのにコンパイルエラーが出なければ、バグの存在に気が付かないまま、読者の書いたソフトウェアは広く世の中に使われ、10年後、20年後に最もバグが発見されてほしくない方法で発見されてしまうかもしれない。すなわち、セキュリティ上問題となる脆弱性という形での発覚だ。しかし安心してほしい。今読者が出したコンパイルエラーによって、そのような悲しい未来の可能性は永久に排除されたのだ。コンパイルエラーはどんどん出すとよい。</p>
<p>コンパイルエラーの原因は2つ。</p>
<ol style="list-style-type: decimal">
<li>文法エラー</li>
<li>意味エラー</li>
<li>コンパイラーのバグ</li>
</ol>
<p>3つだった。コンパイルエラーの原因は3つ。</p>
<ol style="list-style-type: decimal">
<li>文法エラー</li>
<li>意味エラー</li>
<li>コンパイラーのバグ</li>
<li>コンピューターの故障</li>
</ol>
<p>4つだった。ただ、3.と4.はめったにないから無視してよい。</p>
<h2 id="文法エラー">文法エラー</h2>
<p>文法エラーとは、C++というプログラミング言語の文法に従っていないエラーのことだ。これはC++として解釈できないので、当然エラーになる。</p>
<p>よくある文法エラーとしては、文末のセミコロンを打ち忘れたものがある。例えば以下のコードには間違いがある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> x = <span class="dv">1</span> + <span class="dv">1</span> 
    <span class="kw">auto</span> y = x + <span class="dv">1</span> ;
}</code></pre></div>
<p>これをコンパイルすると以下のようにコンパイルエラーメッセージが出力される。</p>
<pre><code>$ make
g++ -std=c++17 -Wall --pedantic-error -include all.h main.cpp -o program
main.cpp: In function ‘int main()’:
main.cpp:4:5: error: expected ‘,’ or ‘;’ before ‘auto’
     auto y = x + 1 ;
     ^~~~
main.cpp:3:10: warning: unused variable ‘x’ [-Wunused-variable]
     auto x = 1 + 1
          ^
Makefile:4: recipe for target &#39;program&#39; failed
make: *** [program] Error 1</code></pre>
<p>コンパイラーのメッセージを読み慣れていない読者はここで考えることを放棄してコンピューターの電源を落とし家を出て街を徘徊し夕日を見つめて人生、宇宙、すべてについての究極の質問への答えを模索してしまうことだろう。</p>
<p>しかし恐れるなかれ。コンパイラーのエラーメッセージを読み解くのは難しくない。</p>
<p>まず最初の2行を見てみよう。</p>
<pre><code>$ make
g++ -std=c++17 -Wall --pedantic-error -include all.h main.cpp -o program</code></pre>
<p>1行目はシェルにmakeを実行させるためのコマンド、二行目はmakeが実行したレシピの中身だ。これはコンパイラーによるメッセージではない。</p>
<p>3行目からはコンパイラーによる出力だ。</p>
<pre><code>main.cpp: In function ‘int main()’:</code></pre>
<p>コンパイラーはソースファイル<code>main.cpp</code>の中の、<code>int main()</code>という関数について、特に言うべきことがあると主張している。</p>
<p>言うべきこととは以下だ。</p>
<pre><code>main.cpp:4:5: error: expected ‘,’ or ‘;’ before ‘auto’
     auto y = x + 1 ;
     ^~~~</code></pre>
<p>GCCというコンパイラーのエラーメッセージは、以下のフォーマットを採用している。</p>
<pre><code>ソースファイル名:行番号:列番号: メッセージの種類: メッセージの内容</code></pre>
<p>ここでのメッセージの種類は<code>error</code>、つまりこのメッセージはエラーを伝えるものだ。</p>
<p>ソースファイル名は<code>main.cpp</code>、つまりエラーは<code>main.cpp</code>の中にあるということだ。</p>
<p>行番号というのは、最初の行を1行目とし、改行ごとにインクリメントされていく。今回のソースファイルの場合、以下のようになる。</p>
<pre><code>1 int main()
2 {
3     auto x = 1 + 1 
4     auto y = x + 1 ;
5 }</code></pre>
<p>もし読者が素晴らしいテキストエディターであるVimを使っている場合、<code>:set nu</code>すると行番号を表示できる。</p>
<p>その上でエラーメッセージの行番号を確認すると<code>4</code>とある。つまりコンパイラーは4行目に問題があると考えているわけだ。</p>
<p>4行目を確認してみよう。</p>
<pre><code>    auto y = x + 1 ;</code></pre>
<p>何の問題もないように見える。更にエラーメッセージを読んでみよう。</p>
<p>列番号が<code>5</code>となっている。列番号というのは、行頭からの文字数だ。最初の文字を1文字目とし、文字ごとにインクリメントされていく。</p>
<pre><code>123456789...
    auto y = x + 1 ;</code></pre>
<p>4行目は空白文字を4つ使ってインデントしているので、autoのaの列番号は5だ。ここに問題があるのだろうか。何も問題がないように見える。</p>
<p>この謎を解くためには、メッセージの内容を読まなければならない。</p>
<pre><code>expected ‘,’ or ‘;’ before ‘auto’
     auto y = x + 1 ;
     ^~~</code></pre>
<p>これは日本語に翻訳すると以下のようになる。</p>
<pre><code>‘auto’の前に&#39;,&#39;か&#39;;&#39;があるべき
     auto y = x + 1 ;
     ^~~</code></pre>
<p>1行目はエラー内容をテキストで表現したものだ。これによると、'auto'の前に','か';'があるべきとあるが、やはりまだわからない。</p>
<p>2行目は問題のある箇所のソースコードを部分的に抜粋したもので、3行目はそのソースコードの問題のある文字を視覚的にわかりやすく示しているものだ。</p>
<p>ともかく、コンパイラーの支持に従って'auto'の前に','を付けてみよう。</p>
<pre><code>    ,auto y = x + 1 ;</code></pre>
<p>これをコンパイルすると、また違ったエラーメッセージが表示される。</p>
<pre><code>main.cpp: In function ‘int main()’:
main.cpp:4:6: error: expected unqualified-id before ‘auto’
     ,auto y = x + 1 ;
      ^~~~</code></pre>
<p>では';'ならばどうか。</p>
<pre><code>    ;auto y = x + 1 ;</code></pre>
<p>これはコンパイルが通るようだ。</p>
<p>しかしなぜこれでコンパイルが通るのだろう。そのためには、コンパイラーが問題だとした行の一つ上の行を見る必要がある。</p>
<pre><code>    auto x = 1 + 1
    auto y = x + 1 ;</code></pre>
<p>コンパイラーにとって、改行は空白文字と同じくソースファイル中の意味のあるトークン(キーワードや名前や記号)を区切る文字でしかない。コンパイラーにとって、このコードは実質以下のように見えてる。</p>
<pre><code>auto x=1+1 auto y=x+1;</code></pre>
<p>&quot;1 auto&quot;というのは文法エラーだ。なのでコンパイラーは文法エラーが発覚する最初の文字である'auto'の'a'を指摘したのだ。</p>
<p>人間にとって自然になるように修正すると、コンパイラーが指摘した行の一つ上の行の行末に';'を追加すべきだ。</p>
<pre><code>    auto x = 1 + 1 ;
    auto y = x + 1 ;</code></pre>
<p>さて、問題自体は解決したわけだが、残りのメッセージも見ていこう。</p>
<pre><code>main.cpp:3:10: warning: unused variable ‘x’ [-Wunused-variable]
     auto x = 1 + 1</code></pre>
<p>これはコンパイラーによる警告メッセージだ。警告メッセージについて詳しくは、デバッグ：警告メッセージの章で解説する。</p>
<pre><code>Makefile:4: recipe for target &#39;program&#39; failed
make: *** [program] Error 1</code></pre>
<p>これはGNU makeによるメッセージだ。GCCがソースファイルを正しくコンパイルできず、実行が失敗したとエラーを返したので、レシピの実行が失敗したことを伝えるメッセージだ。</p>
<p>プログラムはどうやってエラーを通知するのか。main関数の戻り値によってだ。main関数は関数であるので、戻り値がある。main関数の戻り値はint型だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 戻り値の型</span>
<span class="dt">int</span>
<span class="co">// main関数の残りの部分</span>
main() { }</code></pre></div>
<p>main関数が何も値を返さない場合、<code>return 0</code>したものとみなされる。main関数が<code>0</code>もしくは<code>EXIT_SUCCESS</code>を返した場合、プログラムの実行の成功を通知したことになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 必ず実行が成功したと通知するプログラム</span>
<span class="dt">int</span> main()
{
    <span class="cf">return</span> <span class="dv">0</span> ;
}</code></pre></div>
<p>プログラムの実行が失敗した場合、main関数は<code>EXIT_FAILURE</code>を返すことでエラーを通知できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 必ず実行が失敗したと通知するプログラム</span>
<span class="dt">int</span> main()
{
    <span class="cf">return</span> EXIT_FAILURE ;
}</code></pre></div>
<p><code>EXIT_SUCCESS</code>と<code>EXIT_FAILURE</code>はマクロだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#define EXIT_SUCCESS</span>
<span class="pp">#define EXIT_FAILURE</span></code></pre></div>
<p>その中身はC++標準規格では規定されていない。どうしても値を知りたい場合は以下のプログラムを実行してみるとよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>cout
        &lt;&lt; <span class="st">&quot;EXIT_SUCCESS: &quot;</span>s &lt;&lt; EXIT_SUCCESS &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s
        &lt;&lt; <span class="st">&quot;EXIT_FAILURE: &quot;</span>s   &lt;&lt; EXIT_FAILURE ;  
}</code></pre></div>
<p>文法エラーというのは厄介なバグだ。というのも、コンパイラーというのは正しい文法のソースファイルを処理するように作られている。文法を間違えた場合、ソースファイル全体が正しくないということになる。コンパイラーは文法違反に遭遇した場合、なるべく人間がよく間違えそうなパターンをヒューリスティックに指摘することもしている。そのため、エラーメッセージに指摘された行番号と列番号は、必ずしも人間にとっての問題の箇所と一致しない。</p>
<p>もうひとつ例を見てみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 引数を3つとって足して返す関数</span>
    <span class="kw">auto</span> f = [](<span class="kw">auto</span> a, <span class="kw">auto</span> b, <span class="kw">auto</span> c)
    { <span class="cf">return</span> a + b + c ; } ;

    <span class="bu">std::</span>cout &lt;&lt; f(<span class="dv">1</span>+(<span class="dv">2</span>*<span class="dv">3</span>),<span class="dv">4-5</span>,<span class="dv">6</span>/(<span class="dv">7-8</span>))) ;
}</code></pre></div>
<p>GCCによるコンパイルエラーメッセージだけ抜粋すると以下の通り、</p>
<pre><code>main.cpp: In function ‘int main()’:
main.cpp:7:40: error: expected ‘;’ before ‘)’ token
     std::cout &lt;&lt; f(1+(2*3),4-5,6/(7-8))) ;
                                        ^</code></pre>
<p>さて早速読んでみよう。すでに学んだように、GCCのメッセージのフォーマットは以下の通りだ。</p>
<pre><code>ソースファイル名:行番号:列番号: メッセージの種類: メッセージの内容</code></pre>
<p>これに当てはめると、問題はソースファイル<code>main.cpp</code>の7行目の40列目にある。</p>
<p>エラーメッセージは、「';'か')'がトークンの前にあるべき」だ。</p>
<p>トークン(token)というのは'std'とか'::'とか'cout'といったソースファイルの空白文字で区切られた最小の文字列の単位のことだ。</p>
<p>抜粋されたソースコードに示された問題の箇所、つまり7行目40列目にあるトークンは')'だ。この前に';'が必要とはどういうことだろう。</p>
<p>問題を探るため、7行目のトークンを詳しく分解してみよう。以下は7行目と同じソースコードだが、トークンをわかりやすく分解してある</p>
<pre><code>std::cout &lt;&lt; // 標準出力
f // 関数名
    ( // 空き括弧
        1+(2*3),    // 第1引数
        4-5,        // 第2引数
        6/(7-8)     // 第3引数
    ) // 空き括弧に対応する閉じ括弧
    ) // ???
    ; // 終端文字</code></pre>
<p>これを見ると、閉じ括弧が一つ多いことがわかる。</p>
<h2 id="意味エラー">意味エラー</h2>
<p>意味エラーとは、ソースファイルは文法的に正しいが、意味的に間違っているコンパイルエラーのことだ。</p>
<p>早速例を見ていこう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> x = <span class="fl">1.0</span> % <span class="fl">1.0</span> ;
}</code></pre></div>
<p>このコードをコンパイルすると出力されるエラーメッセージは以下の通り。</p>
<pre><code>main.cpp: In function ‘int main()’:
main.cpp:3:18: error: invalid operands of types ‘double’ and ‘double’ to binary ‘operator%’
     auto x = 1.0 % 1.0 ;
              ~~~~^~~~~</code></pre>
<p>問題の箇所は3行目の18列目、'%'だ。</p>
<p>エラーメッセージは、「二項 'operator%'に対して不適切なオペランドである型'double'と'double'」とある。</p>
<p>前の章を読み直すとわかるとおり、<code>operator %</code>は剰余を計算する演算子だが、この演算子には<code>double</code>型を渡すことはできない。</p>
<p>このコードはどうだろう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 引数を一つ取る関数</span>
<span class="dt">void</span> f( <span class="dt">int</span> x ) { }

<span class="dt">int</span> main()
{
    <span class="co">// 引数を2つ渡す</span>
    f( <span class="dv">1</span>, <span class="dv">2</span> ) ;
}</code></pre></div>
<p>このようなエラーメッセージになる。</p>
<pre><code>
main.cpp: In function ‘int main()’:
main.cpp:7:13: error: too many arguments to function ‘void f(int)’
     f( 1, 2 ) ;
             ^
main.cpp:2:6: note: declared here
 void f( int x ) { }
      ^</code></pre>
<p>問題の箇所は7行目。「関数'void f(int)'に対して実引数が多すぎる」とある。<code>関数f</code>は引数を一つしか取らないのに、2つの引数を渡しているのがエラーの原因だ。</p>
<p>2つめのメッセージはエラーではなくて、エラーを補足説明するための注記(note)メッセージだ。ここで言及している<code>関数f</code>とは、2行目に宣言されていることを説明してくれている。</p>
<p>意味エラーは時としておぞましいほどのエラーメッセージを生成することがある。例えば以下の一件無害そうなコードだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="st">&quot;hello&quot;</span>s &lt;&lt; <span class="dv">1</span> ;
}</code></pre></div>
<p>このコードは文法的に正しいが、意味的に間違っているコードだ。このコードをコンパイルすると膨大なエラーメッセージが出力される。しかも問題の行番号特定以外、大して役に立たない。</p>
<h2 id="コンパイラーのバグ">コンパイラーのバグ</h2>
<p>C++コンパイラーもソフトウェアであり、バグがある。コンパイラーにバグがある場合、正しいC++のソースファイルがコンパイルできないことがある。</p>
<p>読者がそのようなコンパイラーの秘孔を突くコードを書くことはまれだ。しかし、もしそのようなコードを偶然にも書いてしまった場合、GCCは、</p>
<pre><code>gcc: internal compiler error: エラー内容
Please submit a full bug report,
with preprocessed source if appropriate.
See &lt;ドキュメントへのファイルパス&gt; for instructions.</code></pre>
<p>のようなメッセージを出力する。</p>
<p>これはGCCのバグなので、見つけた読者は適切な方法でバグ報告をしよう。</p>
<h1 id="条件分岐の果てのレストラン">条件分岐の果てのレストラン</h1>
<p>さてC++の勉強に戻ろう。この章では条件分岐について学ぶ。</p>
<h2 id="複合文">複合文</h2>
<p>条件分岐とループについて学ぶ前に、まず'複合文(compound statement)'や`ブロック(block)'と呼ばれている、複数の文をひとまとめにする文について学ばなければならない。</p>
<p>C++では<code>文(statement)</code>が実行される。<code>文</code>については詳しく説明すると長くなるが、';'で区切られたものが<code>文</code>だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 文</span>
    <span class="kw">auto</span> x = <span class="dv">1</span> + <span class="dv">1</span> ;
    <span class="co">// 文</span>
    <span class="bu">std::</span>cout &lt;&lt; x ;

    <span class="co">// 空文</span>
    <span class="co">// 実は空っぽの文も書ける。</span>
    ;
}</code></pre></div>
<p>複数の<code>文</code>を<code>{}</code>で囲むことで、一つの文として扱うことができる。これを<code>複合文</code>という</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 複合文開始</span>
    {
        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;hello</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;hello</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
    } <span class="co">// 複合文終了</span>

    <span class="co">// 別の複合文</span>
    { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;world</span><span class="sc">\n</span><span class="st">&quot;</span>s ; }

    <span class="co">// 空の複合文</span>
    { }
}</code></pre></div>
<p><code>複合文</code>には';'はいらない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// ;はいらない</span>
    { }

    <span class="co">// これは空の複合文に続いて</span>
    <span class="co">// 空文があるだけのコード</span>
    { } ;
}</code></pre></div>
<p><code>複合文</code>の中に<code>複合文</code>を書くこともできる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    {{{}}} ;
}</code></pre></div>
<p><code>関数の本体</code>としての一番外側'{}'はこの<code>複合文</code>とは別のものだが、読者はまだ気にする必要はない。</p>
<p><code>複合文</code>は複数の<code>文</code>をひとまとめにして、ひとつの<code>文</code>として扱えるようにするぐらいの意味しか持っていない。ただし、変数の見え方に影響する。変数は宣言された最も内側の複合文の中でしか使えない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> a = <span class="dv">0</span> ;

    {
        <span class="kw">auto</span> b = <span class="dv">0</span> ;
        {
            <span class="kw">auto</span> c = <span class="dv">0</span> ;
            <span class="co">// cはここまで使える</span>
        }
        <span class="co">// bはここまで使える</span>
    }
    <span class="co">// aはここまで使える</span>
}</code></pre></div>
<p>これを専門用語では<code>変数</code>の<code>寿命</code>とか<code>ブロックスコープ(block-scope)</code>という。</p>
<p>内側のブロックスコープの変数が、外側のブロックスコープの変数と同じ名前を持っていた場合はエラーではない。外側の変数が内側の変数で隠される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> x = <span class="dv">0</span> ;
    {
        <span class="kw">auto</span> x = <span class="dv">1</span> ;
        {
            <span class="kw">auto</span> x = <span class="dv">2</span> ;
            <span class="co">// 2</span>
            <span class="bu">std::</span>cout &lt;&lt; x ;
        }
        <span class="co">// 1</span>
        <span class="bu">std::</span>cout &lt;&lt; x ;
        x = <span class="dv">42</span> ;
        <span class="co">// 42</span>
        <span class="bu">std::</span>cout &lt;&lt; x ;
    }
    <span class="co">// 0</span>
    <span class="bu">std::</span>cout &lt;&lt; x ;
}</code></pre></div>
<p>なれないうちは驚くかもしれないが、多くのプログラミング言語はこのような挙動になっているものだ。</p>
<h2 id="条件分岐">条件分岐</h2>
<p>すでに読者は様々な数値計算を学んだ。読者は<code>12345 + 6789</code>の答えや、<code>8073 * 132 / 5</code>の答えを計算できる上、この2つの答えをさらにかけ合わせた結果だって計算できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> a = <span class="dv">12345</span> + <span class="dv">6789</span> ;
    <span class="kw">auto</span> b = <span class="dv">8073</span> * <span class="dv">132</span> / <span class="dv">5</span> ;
    <span class="kw">auto</span> sum = a + b ;

    <span class="bu">std::</span>cout
        &lt;&lt; <span class="st">&quot;a=12345 + 6789=&quot;</span> &lt;&lt; a &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s
        &lt;&lt; <span class="st">&quot;b=8073 * 132 / 5=&quot;</span> &lt;&lt; b &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s
        &lt;&lt; <span class="st">&quot;a+b=&quot;</span> &lt;&lt; sum &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
}</code></pre></div>
<p>なるほど、答えがわかった。ところで変数<code>a</code>と変数`b'はどちらが大きいのだろうか。大きい変数だけ出力したい。この場合は条件分岐を使う。</p>
<p>C++では条件分岐に<code>if文</code>を使う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> a = <span class="dv">12345</span> + <span class="dv">6789</span> ;
    <span class="kw">auto</span> b = <span class="dv">8073</span> * <span class="dv">132</span> / <span class="dv">5</span> ;


    <span class="cf">if</span> ( a &lt; b )
    {
        <span class="co">// bが大きい</span>
        <span class="bu">std::</span>cout &lt;&lt; b ;
    } <span class="cf">else</span>
    {
        <span class="co">// aが大きい</span>
        <span class="bu">std::</span>cout &lt;&lt; a ;
    }
}</code></pre></div>
<p><code>if文</code>は以下のように書く。</p>
<pre><code>if ( 条件 )
文1
else
文2</code></pre>
<p><code>条件</code>が真(true)のときは<code>文1</code>が実行され、偽(false)のときは<code>文2</code>が実行される。</p>
<p>elseの部分は書かなくてもよい。</p>
<pre><code>if ( 条件 )
文1
文2</code></pre>
<p>その場合、<code>条件</code>が真の時だけ<code>文1</code>が実行される。条件の真偽にかかわらず<code>文2</code>は実行される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="cf">if</span> ( <span class="dv">2</span> &lt; <span class="dv">1</span> )
        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;sentence 1.</span><span class="sc">\n</span><span class="st">&quot;</span> ; <span class="co">// 文1</span>
    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;sentence 2.</span><span class="sc">\n</span><span class="st">&quot;</span> ; <span class="co">// 文2</span>
}</code></pre></div>
<p>この例では、2が1より小さい場合は<code>文1</code>が実行される。<code>文2</code>は必ず実行される。</p>
<p>条件次第で複数の文を実行したい場合、<code>複合文</code>を使う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="cf">if</span> ( <span class="dv">1</span> &lt; <span class="dv">2</span> )
    {
        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;yes!</span><span class="sc">\n</span><span class="st">&quot;</span> ;
        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;yes!</span><span class="sc">\n</span><span class="st">&quot;</span> ;
    }
}</code></pre></div>
<p><code>条件</code>とか<code>真偽</code>についてはとてもとても深い話があるのだが、その解説は後の章に回すとして、まずは以下の比較演算子を覚えよう。</p>
<table>
<thead>
<tr class="header">
<th align="left">演算子</th>
<th align="left">意味</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">a == b</td>
<td align="left">aはbと等しい</td>
</tr>
<tr class="even">
<td align="left">a != b</td>
<td align="left">aはbと等しくない</td>
</tr>
<tr class="odd">
<td align="left">a &lt; b</td>
<td align="left">aはbより小さい</td>
</tr>
<tr class="even">
<td align="left">a &lt;= b</td>
<td align="left">aはbより小さい、もしくは等しい</td>
</tr>
<tr class="odd">
<td align="left">a &gt; b</td>
<td align="left">aはbより大きい</td>
</tr>
<tr class="even">
<td align="left">a &gt;= b</td>
<td align="left">aはbより大きい、もしくは等しい</td>
</tr>
</tbody>
</table>
<p>真(true)というのは、意味が真であるときだ。正しい、成り立つ、正解などと言い換えてもよい。それ以外の場合はすべて偽(false)だ。正しくない、成り立たない、不正解などと言い換えてもいい。</p>
<p>整数や浮動小数点数の場合、話は簡単だ。</p>
<pre><code>int main()
{
    // 1は2より小さいか？
    if ( 1 &lt; 2 )
    {   // 真、お使いのコンピューターは正常です
        std::cout &lt;&lt; &quot;Your computer works just fine.\n&quot;s ;
    }
    else
    {
        // 偽、お使いのコンピューターには深刻な問題があります
        std::cout &lt;&lt; &quot;Your computer has serious issues.&quot;
    }
}</code></pre>
<p>文字列の場合、内容が同じであれば等しい。違うのであれば等しくない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> a = <span class="st">&quot;dog&quot;</span>s ;
    <span class="kw">auto</span> b = <span class="st">&quot;dog&quot;</span>s ;
    <span class="kw">auto</span> c = <span class="st">&quot;cat&quot;</span>s ;

    <span class="cf">if</span> ( a == b )
    {
        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;a == b</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
    }
    <span class="cf">else</span>
    {
        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;a != b</span><span class="sc">\n</span><span class="st">&quot;</span> ;
    }

    <span class="cf">if</span> ( a == c )
    {
        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;a == c</span><span class="sc">\n</span><span class="st">&quot;</span> ;
    }
    <span class="cf">else</span>
    {
        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;a != c</span><span class="sc">\n</span><span class="st">&quot;</span> ;
    }
}</code></pre></div>
<p>では文字列に大小はあるのだろうか。文字列に大小はある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> cat = <span class="st">&quot;cat&quot;</span>s ;
    <span class="kw">auto</span> dog = <span class="st">&quot;dog&quot;</span>s ;

    <span class="cf">if</span> ( cat &lt; dog )
    {   <span class="co">// 猫は小さい</span>
        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;cat is smaller.</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
    }
    <span class="cf">else</span>
    {   <span class="co">// 犬は小さい</span>
        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;dog is smaller.</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
    }

    <span class="kw">auto</span> longcat = <span class="st">&quot;longcat&quot;</span>s ;

    <span class="cf">if</span> ( longcat &gt; cat )
    {   <span class="co">// longcatは長い</span>
        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Longcat is Looong.</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
    }
    <span class="cf">else</span>
    {
        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Longcat isn&#39;t that long. Sigh.</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
    }
}</code></pre></div>
<p>実行して確かめてみよう。ほとんどの読者の実行環境では以下のようになるはずだ。ほとんどの、というのは、そうではない環境も存在するからだ。読者がそのような稀有な環境を使っている可能性はまずないだろうが。</p>
<pre><code>cat is smaller.
Longcat is Looong.</code></pre>
<p>なるほど。&quot;cat&quot;sは&quot;dog&quot;sよりも小さく(？)、&quot;longcat&quot;sは&quot;cat&quot;sよりも長い(大きい？)ようだ。なんだかよくわからない結果になった。</p>
<p>これはどういうことなのか。もっと簡単な文字列で試してみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> x = <span class="st">&quot;&quot;</span>s ;

    <span class="co">// aとbはどちらが小さいのだろうか？</span>
    <span class="cf">if</span> ( <span class="st">&quot;a&quot;</span>s &lt; <span class="st">&quot;b&quot;</span>s )
    {   x = <span class="st">&quot;a&quot;</span>s ; }
    <span class="cf">else</span>
    {   x = <span class="st">&quot;b&quot;</span>s ; }
 
    <span class="co">// 小さい方の文字が出力される</span>
    <span class="bu">std::</span>cout &lt;&lt; x ;
}</code></pre></div>
<p>これを実行するとaと出力される。すると&quot;a&quot;sは&quot;b&quot;sより小さいようだ。</p>
<p>もっと試してみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> x = <span class="st">&quot;&quot;</span>s ;
    <span class="cf">if</span> ( <span class="st">&quot;aa&quot;</span>s &lt; <span class="st">&quot;ab&quot;</span>s )
    { x = <span class="st">&quot;aa&quot;</span>s ; }
    <span class="cf">else</span>
    { x = <span class="st">&quot;ab&quot;</span>s ; }

    <span class="co">// 小さい文字列が出力される</span>
    <span class="bu">std::</span>cout &lt;&lt; x ;
}</code></pre></div>
<p>これを実行すると、aaと出力される。すると&quot;aa&quot;sは&quot;ab&quot;sより小さいことになる。</p>
<p>文字列の大小比較は文字単位で行われる。まず最初の文字が大小比較される。もし等しい場合は、次の文字が大小比較される。等しくない最初の文字の結果が、文字列の大小比較の結果となる。</p>
<h2 id="条件式">条件式</h2>
<h3 id="条件とは何だろう">条件とは何だろう</h3>
<p><code>if文</code>の中で書く<code>条件(condition)</code>は、<code>条件式(conditional expression)</code>とも呼ばれている<code>式(expression)</code>の一種だ。<code>式</code>というのは例えば&quot;1+1&quot;のようなものだ。<code>式</code>は<code>文</code>の中に書くことができ、これを<code>式文(expression statement)</code>という。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dv">1</span> + <span class="dv">1</span> ; <span class="co">// 式文</span>
}</code></pre></div>
<p>&quot;a==b&quot;や&quot;a&lt;b&quot;のような<code>条件</code>も<code>式</code>なので、<code>文</code>として書くことができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dv">1</span> == <span class="dv">1</span> ;
    <span class="dv">1</span> &lt; <span class="dv">2</span> ;
}</code></pre></div>
<p>C++では多くの式には型がある。たとえば&quot;123&quot;はint型で、&quot;123+4&quot;もint型だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> a = <span class="dv">123</span> ; <span class="co">// int</span>
    <span class="kw">auto</span> b = a + <span class="dv">4</span> ; <span class="co">// int</span>
    <span class="kw">auto</span> c = <span class="fl">1.0</span> ; <span class="co">// double</span>
    <span class="kw">auto</span> d = <span class="st">&quot;hello&quot;</span>s ; <span class="co">// std::string</span>
}</code></pre></div>
<p>とすると、&quot;1==2&quot;や&quot;3!=3&quot;のような条件式にも型があるのではないか。型があるのであれば変数に入れられるはずだ。試してみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="cf">if</span> (  <span class="dv">1</span> == <span class="dv">1</span> )
    { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;1 == 1 is true.</span><span class="sc">\n</span><span class="st">&quot;</span>s ; }
    <span class="cf">else</span>
    { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;1 == 1 is false.</span><span class="sc">\n</span><span class="st">&quot;</span>s ; }

    <span class="kw">auto</span> x = <span class="dv">1</span> == <span class="dv">1</span> ;
    <span class="cf">if</span> ( x )
    { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;1 == 1 is true.</span><span class="sc">\n</span><span class="st">&quot;</span>s ; }
    <span class="cf">else</span>
    { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;1 == 1 is false.</span><span class="sc">\n</span><span class="st">&quot;</span>s ; }
}</code></pre></div>
<p>&quot;if(x)&quot;は&quot;if(1==1)&quot;と書いた場合と同じように動く。</p>
<p>変数に入れられるのであれば出力もできるのではないだろうか。試してみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> a = <span class="dv">1</span> == <span class="dv">1</span> ; <span class="co">// 正しい</span>
    <span class="kw">auto</span> b = <span class="dv">1</span> != <span class="dv">1</span> ; <span class="co">// 間違い</span>
    <span class="bu">std::</span>cout &lt;&lt; a &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s &lt;&lt; b ;
}</code></pre></div>
<pre><code>1
0</code></pre>
<p>なるほど、条件が正しい場合&quot;1&quot;になり、条件が間違っている場合&quot;0&quot;になるようだ。</p>
<p>では<code>if文</code>の中に1や0を入れたらどうなるのだろうか。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 条件が正しい値だけ出力される。</span>
<span class="dt">int</span> main()
{
    <span class="cf">if</span> ( <span class="dv">1</span> ) <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;1</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
    <span class="cf">if</span> ( <span class="dv">0</span> ) <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;0</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
    <span class="cf">if</span> ( <span class="dv">123</span> ) <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;123</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
    <span class="cf">if</span> ( <span class="dv">-1</span> ) <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;-1</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
}</code></pre></div>
<p>実行結果は以下のようになる。</p>
<pre><code>1
123
-1</code></pre>
<p>この結果を見ると、条件として1, 123, -1は正しく、0は間違っているということになる。ますます訳がわからなくなってきた。</p>
<h2 id="bool型">bool型</h2>
<p>そろそろ種明かしをしよう。条件式の結果は、<code>bool型</code>という特別な型を持っている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> a = <span class="dv">1</span> == <span class="dv">1</span> ; <span class="co">// bool型</span>
    <span class="dt">bool</span> A = <span class="dv">1</span> == <span class="dv">1</span> ; <span class="co">// 型を書いてもよい</span>
}</code></pre></div>
<p>int型の変数には整数の値が入る。double型の変数には浮動小数点数の値が入る。std::string型の変数には文字列の値が入る。</p>
<p>すると、bool型の変数にはbool型の値が入る。</p>
<p>bool型には2つの値がある。条件が正しいことを意味する<code>true</code>と、条件が間違っていることを意味する<code>false</code>だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">bool</span> correct = <span class="kw">true</span> ;
    <span class="dt">bool</span> wrong = <span class="kw">false</span> ;
}</code></pre></div>
<p>bool型にこれ以外の値は存在しない。</p>
<p>bool型の値を正しく出力するには、std::boolalphaを出力する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>cout &lt;&lt; <span class="bu">std::</span>boolalpha ;
    <span class="bu">std::</span>cout &lt;&lt; <span class="kw">true</span> &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s &lt;&lt;<span class="kw">false</span> ;
}</code></pre></div>
<pre><code>true
false</code></pre>
<p>std::boolalpha自体は何も出力をしない。一度std::boolalphaを出力すると、それ以降のbool値がtrue/falseで出力されるようになる。</p>
<p>元に戻すにはstd::noboolalphaを使う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>cout &lt;&lt; <span class="bu">std::</span>boolalpha ;
    <span class="bu">std::</span>cout &lt;&lt; <span class="kw">true</span> &lt;&lt; <span class="kw">false</span> ;
    <span class="bu">std::</span>cout &lt;&lt; <span class="bu">std::</span>noboolalpha ;
    <span class="bu">std::</span>cout &lt;&lt; <span class="kw">true</span> &lt;&lt; <span class="kw">false</span> ;
}</code></pre></div>
<p>以下のように出力される。</p>
<pre><code>truefalse10</code></pre>
<p>すでに学んだ比較演算子は、正しい場合に<code>bool</code>型の値<code>true</code>を、間違っている場合に<code>bool</code>型の値<code>false</code>を返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// true</span>
    <span class="dt">bool</span> a = <span class="dv">1</span> == <span class="dv">1</span> ;
    <span class="co">// false</span>
    <span class="dt">bool</span> b = <span class="dv">1</span> != <span class="dv">1</span> ;

    <span class="co">// true</span>
    <span class="dt">bool</span> c = <span class="dv">1</span> &lt; <span class="dv">2</span> ;
    <span class="co">// false</span>
    <span class="dt">bool</span> d = <span class="dv">1</span> &gt; <span class="dv">2</span> ;
}</code></pre></div>
<p>先に説明した<code>if文</code>の<code>条件</code>が「正しい」というのは<code>true</code>のことで、「間違っている」というのは<code>false</code>のことだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 出力される</span>
    <span class="cf">if</span> ( <span class="kw">true</span> )
        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;true</span><span class="sc">\n</span><span class="st">&quot;</span>s ;

    <span class="co">// 出力されない。</span>
    <span class="cf">if</span> ( <span class="kw">false</span> )
        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;false`n&quot;</span>s ; 
}</code></pre></div>
<h2 id="bool型の演算">bool型の演算</h2>
<p>bool型にはいくつかの演算が用意されている。</p>
<h3 id="論理否定-operator">論理否定: operator !</h3>
<p>&quot;!a&quot;はaが<code>true</code>の場合<code>false</code>に、<code>false</code>の場合<code>true</code>になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>cout &lt;&lt; <span class="bu">std::</span>boolalpha ;

    <span class="co">// false</span>
    <span class="bu">std::</span>cout &lt;&lt; !<span class="kw">true</span> &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;

    <span class="co">// true</span>
    <span class="bu">std::</span>cout &lt;&lt; !<span class="kw">false</span> &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
}</code></pre></div>
<p>論理否定演算子を使うと、falseのときのみ実行されてほしい条件分岐が書きやすくなる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// ロケットが発射可能かどうかを返す関数</span>
<span class="dt">bool</span> is_rocket_ready_to_launch()
{
    <span class="co">// まだだよ</span>
    <span class="cf">return</span> <span class="kw">false</span> ;
}

<span class="dt">int</span> main()
{

    <span class="co">// ロケットが発射可能ではないときに実行される</span>
    <span class="cf">if</span> ( !is_rocket_ready_to_launch() )
    {   <span class="co">// もうしばらくそのままでお待ちください</span>
        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Standby...</span><span class="sc">\n</span><span class="st">&quot;</span> ;
    }
}</code></pre></div>
<p>この例では、ロケットが発射可能でない場合のみ、待つようにアナウンスする。</p>
<p>同じように、trueのときに実行されてほしくない条件分岐も書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// ロケットが発射可能かどうかを返す関数</span>
<span class="dt">bool</span> is_rocket_ready_to_launch()
{
    <span class="co">// もういいよ</span>
    <span class="cf">return</span> <span class="kw">true</span> ;
}

<span class="dt">int</span> main()
{
    <span class="co">// ロケットが発射可能なときに実行される</span>
    <span class="cf">if</span> ( !is_rocket_ready_to_launch() )
    {   <span class="co">// カウントダウン</span>
        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;3...2...1...Hallelujah!</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
    }

}</code></pre></div>
<p>この2つの例では、ロケットの状態が実行すべき条件ではないので、正しく何も出力されない。</p>
<h3 id="同値比較-operator">同値比較: operator ==, !=</h3>
<p>bool型の値の同値比較はわかりやすい。<code>true</code>は<code>true</code>と等しく、<code>false</code>は<code>false</code>と等しく、<code>true</code>と<code>false</code>は等しくない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>cout &lt;&lt; <span class="bu">std::</span>boolalpha ;
    <span class="kw">auto</span> print = [](<span class="kw">auto</span> b)
    { <span class="bu">std::</span>cout &lt;&lt; b &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s } ;

    print( <span class="kw">true</span>  == <span class="kw">true</span>  ) ; <span class="co">// true</span>
    print( <span class="kw">true</span>  == <span class="kw">false</span> ) ; <span class="co">// false</span>
    print( <span class="kw">false</span> == <span class="kw">true</span>  ) ; <span class="co">// false</span>
    print( <span class="kw">false</span> == <span class="kw">false</span> ) ; <span class="co">// true</span>

    print( <span class="kw">true</span>  != <span class="kw">true</span>  ) ; <span class="co">// false</span>
    print( <span class="kw">true</span>  != <span class="kw">false</span> ) ; <span class="co">// true</span>
    print( <span class="kw">false</span> != <span class="kw">true</span>  ) ; <span class="co">// true</span>
    print( <span class="kw">false</span> != <span class="kw">false</span> ) ; <span class="co">// false</span>
}</code></pre></div>
<p>比較演算子の結果はbool値になるということを覚えてるだろうか。&quot;1 &lt; 2&quot;は<code>true</code>になり、&quot;1 &gt; 2&quot;はfalseになる。</p>
<p>bool値同士も同値比較ができるということは、&quot;(1 &lt; 2) == true&quot;のように書くことも可能だということだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">bool</span> b = (<span class="dv">1</span> &lt; <span class="dv">2</span>) == <span class="kw">true</span> ;
}</code></pre></div>
<p>&quot;(1&lt;2)&quot;はtrueなので、&quot;(1&lt;2)==true&quot;は&quot;true==true&quot;と同じ意味になる。この結果はもちろん&quot;true&quot;だ。</p>
<h3 id="論理積-operator">論理積: operator &amp;&amp;</h3>
<p>&quot;a &amp;&amp; b&quot;は<code>a</code>と<code>b</code>がともに<code>true</code>のときに<code>true</code>となる。それ以外の場合は<code>false</code>となる。これを論理積という。</p>
<p>表にまとめると以下のようになる。</p>
<table>
<thead>
<tr class="header">
<th align="left">式</th>
<th align="left">結果</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">false &amp;&amp; false</td>
<td align="left">false</td>
</tr>
<tr class="even">
<td align="left">false &amp;&amp; true</td>
<td align="left">false</td>
</tr>
<tr class="odd">
<td align="left">true &amp;&amp; false</td>
<td align="left">false</td>
</tr>
<tr class="even">
<td align="left">true &amp;&amp; true</td>
<td align="left">true</td>
</tr>
</tbody>
</table>
<p>早速確かめてみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>cout &lt;&lt; <span class="bu">std::</span>boolalpha ;
    <span class="kw">auto</span> print = []( <span class="kw">auto</span> b )
    { <span class="bu">std::</span>cout &lt;&lt; b &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ; } ;

    print( <span class="kw">false</span> &amp;&amp; <span class="kw">false</span> ) ; <span class="co">// false</span>
    print( <span class="kw">false</span> &amp;&amp; <span class="kw">true</span>  ) ; <span class="co">// false</span>
    print( <span class="kw">true</span>  &amp;&amp; <span class="kw">false</span> ) ; <span class="co">// false</span>
    print( <span class="kw">true</span>  &amp;&amp; <span class="kw">true</span>  ) ; <span class="co">// true</span>
}</code></pre></div>
<p>論理積は、「AかつB」を表現するのに使える。</p>
<p>例えば、人間の体温が平熱かどうかを判断するプログラムを書くとする。36.1℃以上、37.2℃以下を平熱とすると、if文を使って以下のように書くことができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 体温</span>
    <span class="dt">double</span> temperature = <span class="fl">36.6</span> ;

    <span class="co">// 36.1度以上</span>
    <span class="cf">if</span> ( temperature &gt;= <span class="fl">36.1</span> )
        <span class="cf">if</span> ( temperature &lt;= <span class="fl">37.2</span> )
        { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Good.</span><span class="sc">\n</span><span class="st">&quot;</span>s ; }
        <span class="cf">else</span>
        { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Bad.</span><span class="sc">\n</span><span class="st">&quot;</span>s ; }
}</code></pre></div>
<p>このコードは、<code>operator &amp;&amp;</code>を使えば簡潔に書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">double</span> temperature = <span class="fl">36.6</span> ;

    <span class="cf">if</span> ( ( temperature &gt;= <span class="fl">36.1</span> ) &amp;&amp; ( temperature &lt;= <span class="fl">37.2</span> ) )
    { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Good.</span><span class="sc">\n</span><span class="st">&quot;</span>s ; }
    <span class="cf">else</span>
    { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Bad.</span><span class="sc">\n</span><span class="st">&quot;</span>s ; }
}</code></pre></div>
<h3 id="論理和-operator">論理和: operator ||</h3>
<p>&quot;a || b&quot;は<code>a</code>と<code>b</code>がともにfalseのときに<code>false</code>となる。それ以外の場合は<code>true</code>となる。これを論理和という。</p>
<p>表にまとめると以下のようになる。</p>
<table>
<thead>
<tr class="header">
<th align="left">式</th>
<th align="left">結果</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">false || false</td>
<td align="left">false</td>
</tr>
<tr class="even">
<td align="left">false || true</td>
<td align="left">true</td>
</tr>
<tr class="odd">
<td align="left">true || false</td>
<td align="left">true</td>
</tr>
<tr class="even">
<td align="left">true || true</td>
<td align="left">true</td>
</tr>
</tbody>
</table>
<p>早速確かめてみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>cout &lt;&lt; <span class="bu">std::</span>boolalpha ;
    <span class="kw">auto</span> print = []( <span class="kw">auto</span> b )
    { <span class="bu">std::</span>cout &lt;&lt; b &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ; } ;

    print( <span class="kw">false</span> || <span class="kw">false</span> ) ; <span class="co">// false</span>
    print( <span class="kw">false</span> || <span class="kw">true</span>  ) ; <span class="co">// false</span>
    print( <span class="kw">true</span>  || <span class="kw">false</span> ) ; <span class="co">// false</span>
    print( <span class="kw">true</span>  || <span class="kw">true</span>  ) ; <span class="co">// true</span>
}</code></pre></div>
<p>論理和は、「AもしくはB」を表現するのに使える。</p>
<p>例えば、ある遊園地の乗り物には安全上の理由で身長が1.1m未満、あるいは1.9mを超える人は乗れないものとする。この場合、乗り物に乗れる身長かどうかを確かめるコードは、<code>if文</code>を使うと以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">double</span> height = <span class="fl">1.3</span> ;

    <span class="cf">if</span> ( height &lt; <span class="fl">1.1</span> )
    { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;No.&quot;</span>s ; }
    <span class="cf">else</span> <span class="cf">if</span> ( height &gt; <span class="fl">1.9</span> )
    { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;No.&quot;</span>s ; }
    <span class="cf">else</span>
    { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Yes.&quot;</span>s ; }
}</code></pre></div>
<p>論理和を使うと以下のように簡潔に書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">double</span> height = <span class="fl">1.3</span> ;

    <span class="cf">if</span> ( ( height &lt; <span class="fl">1.1</span> ) || ( height &gt; <span class="fl">1.9</span> ) )
    { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;No.&quot;</span>s ; }
    <span class="cf">else</span>
    { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Yes.&quot;</span>s ; }
}</code></pre></div>
<h3 id="短絡評価">短絡評価</h3>
<p>論理積と論理和は短絡評価と呼ばれる特殊な評価が行われる。これは、左から右に最小限の評価をするという意味だ。</p>
<p>論理積では、&quot;a &amp;&amp; b&quot;とある場合、<code>a</code>と<code>b</code>が共に<code>true</code>である場合のみ、結果は<code>true</code>になる。もし、<code>a</code>が<code>false</code>であった場合、'b'の結果如何にかかわらず結果は<code>false</code>となるので、<code>b</code>は評価されない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> a = []()
    {
        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;a</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
        <span class="cf">return</span> <span class="kw">false</span> ;
    } ;
    <span class="kw">auto</span> b = []()
    {
        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;b</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
        <span class="cf">return</span> <span class="kw">true</span> ;
    } ;

    <span class="dt">bool</span> c = a() &amp;&amp; b() ;
    <span class="bu">std::</span>cout &lt;&lt; <span class="bu">std::</span>boolalpha &lt;&lt; c ; 
}</code></pre></div>
<p>これを実行すると以下のようになる。</p>
<pre><code>a
false</code></pre>
<p>関数呼び出し&quot;a()&quot;の結果は<code>false</code>なので、&quot;b()&quot;は評価されない。評価されないということは関数呼び出しが行われず、当然標準出力も行われない。</p>
<p>同様に、論理和では、&quot;a || b&quot;とある場合、<code>a</code>と'b'のどちらか片方でも<code>true</code>であれば、結果は<code>true</code>となる。もし、<code>a</code>が<code>true</code>であった場合、<code>b</code>の結果如何にかかわらず結果は<code>true</code>となるので、<code>b</code>は評価されない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> a = []()
    {
        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;a</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
        <span class="cf">return</span> <span class="kw">true</span> ;
    } ;
    <span class="kw">auto</span> b = []()
    {
        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;b</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
        <span class="cf">return</span> <span class="kw">false</span> ;
    } ;

    <span class="dt">bool</span> c = a() &amp;&amp; b() ;
    <span class="bu">std::</span>cout &lt;&lt; <span class="bu">std::</span>boolalpha &lt;&lt; c ; 
}</code></pre></div>
<p>結果、</p>
<pre><code>a
true</code></pre>
<p>&quot;b()&quot;が評価されていないことがわかる。</p>
<h2 id="boolの変換">boolの変換</h2>
<p><code>bool</code>型の値と演算はこれで全部だ。値は<code>true</code>/<code>false</code>の2つのみ。演算は==, !=, !と&amp;&amp;と||の5つだけだ。</p>
<p>読者の中には納得の行かないものもいるだろう。ちょっとまってもらいたい。boolの大小比較できないのだろうか。boolの四則演算はできないのか。&quot;if(123)&quot;などと書けてしまうのはなんなのか。</p>
<p>好奇心旺盛な読者は本書の解説を待たずしてすでに自分で色々とコードを書いて試してしまっていることだろう。</p>
<p>boolの大小比較はどうなるのだろうか。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>cout &lt;&lt; <span class="bu">std::</span>boolalpha ;

    <span class="dt">bool</span> b = <span class="kw">true</span> &lt; <span class="kw">false</span> ;
    <span class="bu">std::</span>cout &lt;&lt; b ;
}</code></pre></div>
<p>このコードを実行すると、出力は&quot;false&quot;だ。&quot;true &lt; false&quot;の結果が&quot;false&quot;だということは、<code>true</code>は<code>false</code>より大きいということになる</p>
<p>四則演算はどうか？</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">
<span class="dt">int</span> main()
{
    <span class="kw">auto</span> print = [](<span class="kw">auto</span> x)
    { <span class="bu">std::</span>cout &lt;&lt; x &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ; } ;

    print( <span class="kw">true</span>  + <span class="kw">true</span>  ) ;
    print( <span class="kw">true</span>  + <span class="kw">false</span> ) ;
    print( <span class="kw">false</span> + <span class="kw">true</span>  ) ;
    print( <span class="kw">false</span> + <span class="kw">false</span> ) ;
}</code></pre></div>
<p>結果、</p>
<pre><code>2
1
1
0</code></pre>
<p>不思議な結果だ。&quot;true+true&quot;は&quot;2&quot;、&quot;true+false&quot;は&quot;1&quot;、&quot;false+false&quot;は&quot;0&quot;。これは<code>true</code>が1で<code>false</code>が0ならば納得の行く結果だ。大小比較の結果としても矛盾していない。</p>
<p>すでに見たように、std::boolalphaを出力していない状態でboolを出力すると<code>true</code>が1、<code>false</code>が0となる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>cout &lt;&lt; <span class="kw">true</span> &lt;&lt; <span class="kw">false</span> ;
}</code></pre></div>
<p>結果、</p>
<pre><code>10</code></pre>
<p>これは<code>bool型</code>と<code>整数型</code>が変換されているのだ。</p>
<p>ことなる型の値が変換されるというのは、すでに例がある。<code>整数型</code>と<code>浮動小数点数型</code>だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 3</span>
    <span class="dt">int</span> i = <span class="fl">3.14</span> ;
    <span class="bu">std::</span>cout &lt;&lt; i &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;

    <span class="co">// 123.0</span>
    <span class="dt">double</span> d = <span class="dv">123</span> ;
    <span class="bu">std::</span>cout &lt;&lt; d &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
}</code></pre></div>
<p><code>浮動小数点数型</code>は<code>整数型</code>に変換できる。その際に小数部は切り捨てられる。<code>整数型</code>は<code>浮動小数点数型</code>に変換できる。小数部はない。</p>
<p>これと同じように、<code>bool型</code>も<code>整数型</code>と変換ができる。</p>
<p>bool型の<code>true</code>を<code>整数型</code>に変換すると1になる。<code>false</code>は0になる。</p>
<pre><code>int main()
{
    // 1
    int True = true ;
    // 0
    int False = false ;
}</code></pre>
<p>同様に、<code>整数型</code>のゼロを<code>bool型</code>に変換すると<code>false</code>になる。非ゼロは<code>true</code>になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// false</span>
    <span class="dt">bool</span> Zero = <span class="dv">0</span> ;

    <span class="co">// すべてtrue</span>
    <span class="dt">bool</span> One = <span class="dv">1</span> ;
    <span class="dt">bool</span> minus_one = <span class="dv">-1</span> ;
    <span class="dt">bool</span> OneTwoThree = <span class="dv">123</span> ;  
}</code></pre></div>
<p>したがって、&quot;if (0)&quot;は&quot;if (false)&quot;と等しく、&quot;if (1)&quot;や&quot;if(-1)&quot;など非ゼロな値は&quot;if (true)&quot;と等しい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 出力されない</span>
    <span class="cf">if</span> ( <span class="dv">0</span> )
        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;No output.</span><span class="sc">\n</span><span class="st">&quot;</span>s ;

    <span class="co">// 出力される</span>
    <span class="cf">if</span> ( <span class="dv">1</span> )
        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Output.</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
}</code></pre></div>
<p>大小比較は単にboolを整数に変換した結果を比較しているだけだ。&quot;true &lt; false&quot;は&quot;1 &lt; 0&quot;と書くのと同じだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>cout &lt;&lt; <span class="bu">std::</span>boolalpha ;

    <span class="co">// 1 &lt; 0</span>
    <span class="bu">std::</span>cout &lt;&lt; (<span class="kw">true</span> &lt; <span class="kw">false</span>) ;
}</code></pre></div>
<p>同様に四則演算もbool型を整数型に変換した上で計算をしているだけだ。&quot;true + true&quot;は&quot;1 + 1&quot;と書くのと同じだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 1 + 1</span>
    <span class="bu">std::</span>cout &lt;&lt; (<span class="kw">true</span> + <span class="kw">true</span>) ;
}</code></pre></div>
<p>C++では、<code>bool型</code>と<code>整数型</code>の変換は暗黙に行われてしまうので注意が必要だ。</p>
<h1 id="デバッグ-コンパイル警告メッセージ">デバッグ: コンパイル警告メッセージ</h1>
<p>やれやれ、条件分岐は難しかった。この辺でもう一度一休みして、息抜きとしてデバッグの話をしよう。今回はコンパイラーの警告メッセージ(warning messages)についてだ。</p>
<p>コンパイラーはソースコードに文法エラーや意味エラーがあると、エラーメッセージを出すことはすでに学んだ。</p>
<p>コンパイラーがエラーメッセージを出さなかったとき、コンパイラーはソースコードには文法エラーや意味エラーを発見できず、コンパイラーは意味のあるプログラムを生成することができたということを意味する。しかし、コンパイルが通って実行可能なプログラムが生成できたからと行って、プログラムにバグがないことは保証できない。</p>
<p>たとえば、変数xとyを足して出力するプログラムを考える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> x = <span class="dv">1</span> ;
    <span class="kw">auto</span> y = <span class="dv">2</span> ;

    <span class="bu">std::</span>cout &lt;&lt; x + x ;
}</code></pre></div>
<p>このプログラムにはバグがある。プログラムの仕様は変数xとyを足すはずだったが変数xとxを足してしまっている。</p>
<p>コンパイラーはこのソースコードをコンパイルエラーにはしない。なぜならば上のコードは文法的に正しく、意味的にも正しいコードだからだ。</p>
<p>警告メッセージはこのような疑わしいコードについて、エラーとまでは行かないまでも、文字通り警告を出す機能だ。例えば上のコードをGCCでコンパイルすると以下のような警告メッセージを出す</p>
<pre><code>$ make
g++ -std=c++17 -Wall --pedantic-error -include all.h main.cpp -o program
main.cpp: In function ‘int main()’:
main.cpp:5:10: warning: unused variable ‘y’ [-Wunused-variable]
     auto y = 2 ;
          ^</code></pre>
<p>すでに説明したように、GCCのメッセージは</p>
<pre><code>ソースファイル名:行番号:列番号:メッセージの種類:メッセージの内容</code></pre>
<p>というフォーマットを取る。</p>
<p>このメッセージのフォーマットに照らし合わせると、このメッセージはソースファイルmain.cppの5行目の10列目について何かを警告している。警告はメッセージの種類として<code>warning</code>が使われる。</p>
<p>警告メッセージの内容は、「未使用の変数'y' [-Wunused-variable]」だ。コード中で'y'という名前の変数を宣言しているにもかかわらず、使っている場所がない。使わない変数を宣言するのはバグの可能性が高いので警告しているのだ。</p>
<p>[-Wunused-variable]というのはGCCに与えるこの警告を有効にするためのオプション名だ。GCCに-Wunused-variableというオプションを与えると、未使用の変数を警告するようになる。</p>
<pre><code>$ g++ -Wunused-variable その他のオプション</code></pre>
<p>今回は-Wallというすべての警告を有効にするオプションを使っているので、このオプションを使う必要はない。</p>
<p>もう一つ例を出そう。以下のソースコードは変数xの値が123と等しいかどうかを調べるものだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// xの値は0</span>
    <span class="kw">auto</span> x = <span class="dv">0</span> ;

    <span class="co">// xが123と等しいかどうか比較する</span>
    <span class="cf">if</span> ( x = <span class="dv">123</span> )
        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;x is 123.</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
    <span class="cf">else</span>
        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;x is NOT 123.</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
}</code></pre></div>
<p>これを実行すると、&quot;x is 123.&quot;と出力される。しかし、変数xの値は0のはずだ。なぜか0と123は等しいと判断されてしまった。一体どういうことだろう。</p>
<p>この謎は警告メッセージを読むと解ける。</p>
<pre><code>g++ -std=c++17 -Wall --pedantic-error -include all.h main.cpp -o program
main.cpp: In function ‘int main()’:
main.cpp:5:12: warning: suggest parentheses around assignment used as truth value [-Wparentheses]
     if ( x = 123 )
          ~~^~~~~</code></pre>
<p>main.cppの5行目の12列目、「真偽値として使われている代入は括弧で囲むべき」とある。これは一体どういうことか。よく見てみると、演算子が同値比較につかう==ではなく、=だ。=は代入演算子だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> x = <span class="dv">0</span> ;

    <span class="co">// 代入</span>
    <span class="co">// xの値は1</span>
    x = <span class="dv">1</span> ;

    <span class="co">// 同値比較</span>
    x == <span class="dv">1</span> ;
}</code></pre></div>
<p>実は<code>if文</code>の<code>条件</code>にはあらゆる<code>式</code>を書くことができる。代入というのは、実は<code>代入式</code>という式なので、<code>if文</code>の中にも書くことができる。その場合、式の結果の値は代入される変数の値になる。</p>
<p>そして思い出してほしいのは、整数型はbool型に変換されるということだ。0は<code>false</code>、非ゼロは<code>true</code>だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> x = <span class="dv">0</span> ;
    <span class="co">// 1はtrue</span>
    <span class="dt">bool</span> b1 = x = <span class="dv">1</span> ;
    <span class="cf">if</span> ( x = <span class="dv">1</span> ) ;

    <span class="co">// 0はfalse</span>
    <span class="dt">bool</span> b0 = x = <span class="dv">0</span> ;
    <span class="cf">if</span> ( x = <span class="dv">0</span> ) ;
}</code></pre></div>
<p>つまり、&quot;if(x=1)&quot;というのは、&quot;if(1)&quot;と書くのと同じで、これは最終的に、&quot;if(true)&quot;と同じ意味になる。</p>
<p>警告メッセージの「括弧で囲むべき」というのは、括弧で囲んだ場合、この警告メッセージはでなくなるからだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> x = <span class="dv">0</span> ;

    <span class="cf">if</span> ( (x = <span class="dv">0</span>) )
        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;x is 123.</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
    <span class="cf">else</span>
        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;x is NOT 123.</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
}</code></pre></div>
<p>このコードをコンパイルしても警告メッセージはでない。</p>
<p>わざわざ括弧で囲むということは、ちゃんと代入を意図して使っていることがわかっていると意思表示したことになり、結果として警告メッセージはなくなる。</p>
<p>この警告メッセージ単体を有効にするオプションは<code>-Wparentheses</code>だ。</p>
<p>警告メッセージは万能ではない。時には全く問題ないコードに対して警告メッセージがでたりする。これは仕方がないことだ。というのもコンパイラーはソースコード中に表現されていない、人間の脳内にある意図を読むことはできないからだ。ただし、警告メッセージには一通り目を通して、それが問題ない誤検知であるかどうかを確認することは重要だ。</p>
<h1 id="最近体重が気になるあなたのための標準入力">最近体重が気になるあなたのための標準入力</h1>
<h2 id="これまでのおさらい">これまでのおさらい</h2>
<p>ここまで学んできた範囲でも、かなりのプログラムが書けるようになってきた。試しにちょっとプログラムを書いてみよう。</p>
<p>最近肥満が気になる読者は、肥満度を把握するためにBMI(Body Mass Index)を計算して出力するプログラムを書くことにした。</p>
<p>BMIの計算は以下の通り。</p>
<p><span class="math display">\[
BMI = \frac{体重_{kg}}{身長^2_{m}}
\]</span></p>
<p>本書をここまで読み進めた読者ならば、このようなプログラムは簡単に書けるだろう。計算は小数点以下の値を扱う必要があるために、変数は浮動小数点数型(double)にする。掛け算は<code>operator *</code>で、割り算は<code>operator /</code>だ。出力にはstd::coutを使う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 身長1.63m</span>
    <span class="dt">double</span> height = <span class="fl">1.63</span> ; 
    <span class="co">// 体重73kg</span>
    <span class="dt">double</span> mass = <span class="fl">73.0</span> ;

    <span class="co">// BMIの計算</span>
    dublle bmi = mass / (height*height) ;

    <span class="co">// BMIの出力</span>
    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;BMI=&quot;</span> &lt;&lt; bmi &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
}</code></pre></div>
<p>結果は&quot;27.4756&quot;となった。これだけでは太っているのか痩せているのかよくわからない。調べてみると、BMIの数値と肥満との関係は以下の表のとおりになるそうだ。</p>
<table>
<thead>
<tr class="header">
<th align="left">BMI</th>
<th align="left">状態</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">18.5未満</td>
<td align="left">痩せすぎ(Underweight)</td>
</tr>
<tr class="even">
<td align="left">18.5以上、25未満</td>
<td align="left">普通(Normal)</td>
</tr>
<tr class="odd">
<td align="left">25以上、30未満</td>
<td align="left">太り気味(Overweight)</td>
</tr>
<tr class="even">
<td align="left">30以上</td>
<td align="left">肥満(Obese)</td>
</tr>
</tbody>
</table>
<p>では早速、この表のようにBMIから肥満状態も出力してくれるように、プログラムを書き換えよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 身長1.6m</span>
    <span class="dt">double</span> height = <span class="fl">1.63</span> ; 
    <span class="co">// 体重73kg</span>
    <span class="dt">double</span> mass = <span class="fl">73.0</span> ;

    <span class="co">// BMIの計算</span>
    <span class="dt">double</span> bmi = mass / (height*height) ;

    <span class="co">// BMIの出力</span>
    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;BMI=&quot;</span> &lt;&lt; bmi &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;

    <span class="co">// 状態の判定をする関数</span>
    <span class="kw">auto</span> status = []( <span class="dt">double</span> bmi )
    {
        <span class="cf">if</span> ( bmi &lt; <span class="fl">18.5</span> )
            <span class="cf">return</span> <span class="st">&quot;Underweight.</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
        <span class="cf">else</span> <span class="cf">if</span> ( bmi &lt; <span class="fl">25.0</span> )
            <span class="cf">return</span> <span class="st">&quot;Nomarl.</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
        <span class="cf">else</span> <span class="cf">if</span> ( bmi &lt; <span class="fl">30.0</span> )
            <span class="cf">return</span> <span class="st">&quot;Overweight.</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
        <span class="cf">else</span>
            <span class="cf">return</span> <span class="st">&quot;Obese.&quot;</span>s ;
    } ;

    <span class="co">// 状態の出力</span>
    <span class="bu">std::</span>cout &lt;&lt; status(bmi) ;
}</code></pre></div>
<p>ここまで問題なく読むことができただろうか。ここまでのコードはすべて、本書をはじめからから読めば理解できる機能しか使っていない。わからない場合、この先に進む前に本書をもう一度はじめから読みなすべきだろう。</p>
<h2 id="標準入力">標準入力</h2>
<p>上のプログラムには実用にする上で一つ問題がある。身長と体重の値を変えたい場合、ソースコードを書き換えてコンパイルしなければならないのだ。</p>
<p>例えば読者の身長が1.8mで体重が80kgの場合、以下のように書き換えなければならない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 身長1.63m</span>
    <span class="dt">double</span> height = <span class="fl">1.80</span> ; 
    <span class="co">// 体重73kg</span>
    <span class="dt">double</span> mass = <span class="fl">80.0</span> ;

    <span class="co">// BMIの計算</span>
    dublle bmi = mass / (height*height) ;

    <span class="co">// BMIの出力</span>
    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;BMI=&quot;</span> &lt;&lt; bmi &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
}</code></pre></div>
<p>すると今度は身長が1.48mで体重が48kgの人がやってきて私のBMIも計測しろとうるさい。しかも昨日と今日で体重が変わったからどちらも計測したいと言い出す始末。</p>
<p>こういうとき、プログラムのコンパイル時ではなく、実行時に値を入力できたならば、いちいちプログラムをコンパイルし直す必要がなくなる。</p>
<p>入力には<code>std::cin</code>を使う。<code>std::cout</code>は標準出力を扱うのに対し、<code>std::cin</code>は標準入力を扱う。<code>std::cout</code>が<code>operator &lt;&lt;</code>を使って値を出力したのに対し、<code>std::cin</code>は<code>opeartor &gt;&gt;</code>を使って値を変数に入れる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 入力を受け取るための変数</span>
    <span class="bu">std::</span>string x{} ;
    <span class="co">// 変数に入力を受け取る</span>
    <span class="bu">std::</span>cin &gt;&gt; x ;
    <span class="co">// 入力された値を出力</span>
    <span class="bu">std::</span>cout &lt;&lt; x ;
}</code></pre></div>
<p>実行結果、</p>
<pre><code>$ make run
hello
hello</code></pre>
<p>標準入力はデフォルトでは、プログラムを実行したユーザーがターミナルから入力する。上の実行結果の2行目は、ユーザーの入力だ。</p>
<p><code>std::cin</code>は入力された文字列を変数に入れる。入力は空白文字や改行で区切られる。そのため、空白で区切られた文字列を渡すと、以下のようになる。</p>
<pre><code>$ make run
hello world
hello</code></pre>
<p>入力は複数取ることができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>string x{} ;
    <span class="bu">std::</span>string y{} ;
    <span class="bu">std::</span>cin &gt;&gt;  x &gt;&gt; y ;
    <span class="bu">std::</span>cout &lt;&lt; x &lt;&lt; y ;
}</code></pre></div>
<p>実行結果、</p>
<pre><code>$ make run
hello world
helloworld</code></pre>
<p>空白文字は文字列の区切り文字として認識されるので変数x, yには入らない。</p>
<p><code>std::cin</code>では文字列の他にも整数や浮動小数点数、boolを入力として得ることができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 整数</span>
    <span class="dt">int</span> i{} ;
    <span class="bu">std::</span>cin &gt;&gt; i ;
    <span class="co">// 浮動小数点数</span>
    <span class="dt">double</span> d{} ;
    <span class="bu">std::</span>cin &gt;&gt; d ;
}</code></pre></div>
<p>実行結果、</p>
<pre><code>$ make run
123 1.23</code></pre>
<p>数値はデフォルトで10進数として扱われる。</p>
<p>boolの入力には注意が必要だ。普通に書くと、ゼロが<code>false</code>, 非ゼロが<code>true</code>として扱われる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">bool</span> b{} ;
    <span class="bu">std::</span>cin &gt;&gt; b ;

    <span class="bu">std::</span>cout &lt;&lt; <span class="bu">std::</span>boolalpha &lt;&lt; b &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
}</code></pre></div>
<p>実行結果、</p>
<pre><code>$ make run
1
true
$ make run
0
false
$ make run
123
true
$ make run
-1
true</code></pre>
<p>&quot;true&quot;, &quot;false&quot;という文字列で<code>true</code>, <code>false</code>の入力をしたい場合、<code>std::cin</code>に<code>std::boolalpha</code>を「入力」させる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 整数</span>
    <span class="dt">bool</span> b{} ;
    <span class="bu">std::</span>cin &gt;&gt; <span class="bu">std::</span>boolalpha &gt;&gt; b ;

    <span class="bu">std::</span>cout &lt;&lt; <span class="bu">std::</span>boolalpha &lt;&lt; b ;
}</code></pre></div>
<p>実行結果</p>
<pre><code>$ make run
true
true
$ make run
false
false</code></pre>
<p>std::boolalphaを入出力するというのは、実際には何も入出力しないので奇妙に見えるが、そういう設計になっているので仕方がない。</p>
<p>では標準入力を学んだので、さっそくBMIを計算するプログラムを標準入力に対応させよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 身長の入力</span>
    <span class="dt">double</span> height{} ;
    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;height(m)&gt;&quot;</span> ;
    <span class="bu">std::</span>cin &gt;&gt; height ;

    <span class="co">// 体重の入力</span>
    <span class="dt">double</span> mass{} ;
    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;mass(kg)&gt;&quot;</span> ;
    <span class="bu">std::</span>cin &gt;&gt; mass ;

    <span class="dt">double</span> bmi = mass / (height*height) ;

    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;BMI=&quot;</span> &lt;&lt; bmi &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
}</code></pre></div>
<p>上出来だ。</p>
<h2 id="リダイレクト">リダイレクト</h2>
<p>標準入出力が扱えるようになれば、もう自分の好きなプログラムを書くことができる。プログラムというのは結局、入力を得て、処理して、出力するだけのものだからだ。入力はテキストだったりグラフィックだったり何らかの特殊なデバイスだったりするが、基本は変わらない。</p>
<p>たとえば読者はまだC++でファイルを読み書きする方法を知らないが、標準入出力さえ使えれば、ファイルの読み書きはリダイレクトを使うだけでできるのだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;hello&quot;</span> ;
}</code></pre></div>
<p>これは&quot;hello&quot;と標準出力するだけの簡単なプログラムだ。このプログラムをコンパイルしたプログラム名を<code>program</code>としよう。標準出力の出力先はデフォルトで、ユーザーのターミナルになる。</p>
<pre><code>$ ./program
hello</code></pre>
<p>リダイレクトを使えば、この出力先をファイルにできる。リダイレクトを使うには&quot;プログラム &gt; ファイル名&quot;とする</p>
<pre><code>$ ./program &gt; hello.txt
$ cat hello.txt
hello</code></pre>
<p>ファイルへの簡単な書き込みは、リダイレクトを使うことで後から簡単に実現可能だ。</p>
<p>リダイレクトはファイルの読み込みにも使える。例えば先程のBMIを計算するプログラムを用意しよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// bmi</span>
<span class="dt">int</span> main()
{
    <span class="dt">double</span> height{ } ;
    <span class="dt">double</span> mass { } ;

    <span class="bu">std::</span>cin &gt;&gt; height &gt;&gt; mass ;

    <span class="bu">std::</span>cout &lt;&lt; mass / (height*height) ;
}</code></pre></div>
<p>このプログラム名を<code>bmi</code>として、通常通り実行すると以下のようになる。</p>
<pre><code>$　./bmi
1.63
73
27.4756</code></pre>
<p>このうち、1.63と73はユーザーによる入力だ。これを毎回手で入力するのではなく、ファイルから入力することができる。つまり以下のようなファイルを用意して、</p>
<pre><code>1.63
73</code></pre>
<p>このファイルを例えば、&quot;bodymass.txt&quot;とする。手で入力する代わりに、このファイルを入力として使いたい。これにはリダイレクトとして&quot;プログラム名 &lt; ファイル名&quot;とする。</p>
<pre><code>$ ./bmi &lt; bodymass.txt
27.4756</code></pre>
<p>リダイレクトの入出力を組み合わせることも可能だ。</p>
<pre><code>$ cat bodymass.txt
1.63
73
$ ./bmi &lt; bodymass.txt &gt; index.txt
$ cat index.text
27.4756</code></pre>
<p>もちろん、このようなファイルの読み書きは簡易的なものだが、かなりの処理がこの程度のファイル操作でも行えるのだ。</p>
<h2 id="パイプ">パイプ</h2>
<p>プログラムが出力した結果をさらに入力にすることだってできる。</p>
<p>例えば、先程のプログラム<code>bmi</code>に入力するファイル<code>bodymass.txt</code>の身長の単位がメートルではなくセンチメートルだったとしよう。</p>
<pre><code>163
73</code></pre>
<p>この場合、プログラム<code>bmi</code>を書き換えて対処することもできるが、プログラムに入力させる前にファイルを読み込み、書き換えて出力し、その出力を入力とすることもできる。</p>
<p>まず、身長の単位をセンチメートルからメートルに直すプログラムを書く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// convert</span>
<span class="dt">int</span> main()
{
    <span class="dt">double</span> height{} ;
    <span class="dt">double</span> mass{} ;

    <span class="bu">std::</span>cin &gt;&gt; height &gt;&gt; mass ;

    <span class="co">// 身長をセンチメートルからメートルに直す</span>
    <span class="co">// 体重はそのままでよい</span>
    <span class="bu">std::</span>cout &lt;&lt; height/<span class="fl">100.0</span> &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s &lt;&lt; mass ;
}</code></pre></div>
<p>このプログラムを<code>convert</code>と名付け、さっそく使ってみよう。</p>
<pre><code>$ ./convert
163
73
1.63
73</code></pre>
<p>身長の単位がセンチメートルからメートルに正しく直されている。</p>
<p>これをリダイレクトで使うとこうなる。</p>
<pre><code>$ ./convert &lt; bodymass.txt &gt; fixed_bodymass.txt
$ ./bmi &lt; fixed_bodymass.txt
27.4756</code></pre>
<p>しかしこれではファイルが増えて面倒だ。この場合、パイプを使うとスッキリと書ける。</p>
<p>パイプはプログラムの標準出力をプログラムの標準入力とするの使い方は、&quot;プログラム名 | プログラム名&quot;だ。</p>
<pre><code>$ ./convert &lt; bodymass.txt | ./bmi
27.4756</code></pre>
<p>ところで、すでに何度か説明無しで使っているが、POSIX規格を満たすOSには<code>cat</code>というプログラムが標準で入っている。<code>cat ファイル名</code>は指定したファイル名の内容を標準出力する。標準出力はパイプで標準入力にできる。</p>
<pre><code>$ cat bodymass.txt | ./convert | ./bmi
27.4756</code></pre>
<h2 id="プログラムの組み合わせ">プログラムの組み合わせ</h2>
<p>現代のプログラミングというのは、すでに存在するプログラムを組み合わせて作るものだ。もし、自分の必要とする処理がすでに実装されているのであれば、自分で書く必要はない。</p>
<p>例えば、読者はまだカレントディレクトリー下のファイルの一覧を列挙する方法を知らない。しかしPOSIX規格を満たすOSには<code>ls</code>というカレントディレクトリー下のファイルの一覧を列挙するプログラムが存在する。これを先程までBMIの計算などの作業をしていたディレクトリ下で実行してみよう。</p>
<pre><code>$ ls
all.h  all.h.gch  bmi  bodymass.txt  convert  data  main.cpp  Makefile  program</code></pre>
<p>ファイルの一覧が列挙される。そしてこれはプログラム<code>ls</code>による標準出力だ。標準出力ということは、リダイレクトしてファイルに書き込んだり、パイプで別のプログラムに渡したりできるということだ。</p>
<pre><code>$ ls &gt; files.txt
$ ls | ./program</code></pre>
<p>標準入出力が扱えれば、ネットワークごしにWebサイトをダウンロードすることもできる。これにはほとんどのGNU/LinuxベースのOSに入っている<code>curl</code>というプログラムを使う。</p>
<pre><code>$ curl https://example.com</code></pre>
<p>プログラム<code>curl</code>は指定されたURLからデータをダウンロードして、標準出力する。標準出力するということは、パイプによって標準入力にできるということだ。</p>
<pre><code>$ curl https://example.com | ./program</code></pre>
<p>読者はC++でネットワークアクセスする方法を知らないが、すでにネットワークアクセスは可能になった。</p>
<p>他にも便利なプログラムはたくさんある。プログラミングの学び始めはできることが少なくて退屈になりがちだが、読者はもうファイルの読み書きやネットワークアクセスまでできるようになったのだから、退屈はしないはずだ。</p>
<h1 id="ループ">ループ</h1>
<p>さて、ここまでで変数や関数、標準入出力といったプログラミングの基礎的な概念を教えてきた。あと一つでプログラミングに必要な基礎的な概念はすべて説明し終わる。ループだ。</p>
<h2 id="これまでのおさらい-1">これまでのおさらい</h2>
<p>C++では、プログラムは書いた順番に実行される。これを<code>逐次実行</code>という。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>cout &lt;&lt; <span class="dv">1</span> ;
    <span class="bu">std::</span>cout &lt;&lt; <span class="dv">2</span> ;
    <span class="bu">std::</span>cout &lt;&lt; <span class="dv">3</span> ;
}</code></pre></div>
<p>実行結果、</p>
<pre><code>123</code></pre>
<p>この実行結果が&quot;123&quot;以外の結果になることはない。C++ではプログラムは書かれた順番に実行されるからだ。</p>
<p>条件分岐は、プログラムの実行を条件付きで行うことができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>cout &lt;&lt; <span class="dv">1</span> ;

    <span class="cf">if</span> ( <span class="kw">false</span> )
        <span class="bu">std::</span>cout &lt;&lt; <span class="dv">2</span> ;

    <span class="bu">std::</span>cout &lt;&lt; <span class="dv">3</span> ;

    <span class="cf">if</span> ( <span class="kw">true</span> )
        <span class="bu">std::</span>cout &lt;&lt; <span class="dv">4</span> ;
    <span class="cf">else</span>
        <span class="bu">std::</span>cout &lt;&lt; <span class="dv">5</span> ;
}</code></pre></div>
<p>実行結果、</p>
<pre><code>134</code></pre>
<p>条件分岐によって、プログラムの一部を実行しないということが可能になる。</p>
<h2 id="goto文">goto文</h2>
<p>ここでは繰り返し(ループ)の基礎的な仕組みを理解するために、最も原始的で最も使いづらい繰り返しの機能である<code>goto文</code>を学ぶ。<code>goto文</code>で実用的な繰り返し処理をするのは面倒だが、恐れることはない。より簡単な方法もすぐに説明するからだ。なぜ本書で<code>goto文</code>を先に教えるかと言うと、あらゆる繰り返しは、結局のところ<code>if文</code>と<code>goto文</code>へのシンタックスシュガーにすぎないからだ。<code>goto文</code>を学ぶことにより、繰り返しを恐れることなく使う本物のプログラマーになれる。</p>
<h3 id="無限ループ">無限ループ</h3>
<p>&quot;hello&quot;と3回出力するプログラムはどうやって書くのだろうか。&quot;hello&quot;を1回出力するプログラムの書き方はすでにわかっているので、同じ文を3回書けばよい。。</p>
<pre><code>// 1回&quot;hello\n&quot;を出力する関数
void hello()
{
    std::cout &lt;&lt; &quot;hello\n&quot;s ;
}

int main()
{
    hello() ;
    hello() ;
    hello() ;
}</code></pre>
<p>10回出力する場合はどうするのだろう。10回書けばよい。コードは省略する。</p>
<p>では100回出力する場合はどうするのだろう。100回書くのだろうか。100回も同じコードを書くのはとても面倒だ。読者がVimのような優秀なテキストエディターを使っていない限り100回も同じコードを間違えずに書くことは不可能だろう。Vimならば1回書いた後にノーマルモードで&quot;100.&quot;するだけで100回書ける。</p>
<p>実際のところ、100回だろうが、1000回だろうが、あらかじめ回数がコンパイル時に決まっているのであれば、その回数だけ同じ処理を書くことで実現可能だ。</p>
<p>しかし、プログラムを外部から強制的に停止させるまで、無限に出力し続けるプログラムはどう書けばいいのだろうか。そういった停止しないプログラムを外部から強制的に停止させるには<code>Ctrl-C</code>を使う。</p>
<p>以下はそのようなプログラムの実行例だ。</p>
<pre><code>$ make run
hello
hello
hello
hello
...
[Ctrl-Cを押す]</code></pre>
<p><code>goto文</code>は指定したラベルに実行を移す機能だ。</p>
<pre><code>ラベル名 : 文

goto ラベル名 ;</code></pre>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>cout &lt;&lt; <span class="dv">1</span> ;

    <span class="co">// ラベルskipまで飛ぶ</span>
    <span class="cf">goto</span> skip ; 

    <span class="bu">std::</span>cout &lt;&lt; <span class="dv">2</span> ;

<span class="co">// ラベルskip</span>
skip :
    <span class="bu">std::</span>cout &lt;&lt; <span class="dv">3</span> ;
}</code></pre></div>
<p>これを実行すると以下のようになる。</p>
<pre><code>13</code></pre>
<p><code>2</code>を出力すべき文の実行が飛ばされていることがわかる。</p>
<p>これだけみると&quot;if (false)&quot;と同じように見えるが、<code>goto文</code>はソースコードの上に飛ぶこともできるのだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> hello()
{
    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;hello</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
}
<span class="dt">int</span> main()
{
loop :
    hello() ;
    <span class="cf">goto</span> loop ; 
}</code></pre></div>
<p>これは&quot;hello&quot;を無限に出力するプログラムだ。</p>
<p>このプログラムを実行すると、</p>
<ol style="list-style-type: decimal">
<li>関数helloが呼ばれる</li>
<li>goto文でラベルloopまで飛ぶ</li>
<li>1に戻る</li>
</ol>
<p>という処理を行う。</p>
<h3 id="終了条件付きループ">終了条件付きループ</h3>
<p>ひたすら同じ文字列を出力し続けるだけのプログラムというのも味気ない。もっと面白くてためになるプログラムを作ろう。例えば、ユーザーから入力された数値を合計し続けるプログラムはどうだろう。</p>
<p>今から作るプログラムを実行すると以下のようになる。</p>
<pre><code>$ make run
&gt; 10
10
&gt; 5
15
&gt; 999
1014
&gt; -234
780</code></pre>
<p>このプログラムは、</p>
<ol style="list-style-type: decimal">
<li>&quot;&gt;&quot;と表示してユーザーから整数値を入力</li>
<li>これまでの入力との合計値を出力</li>
<li>1.に戻る</li>
</ol>
<p>という動作を繰り返す。先程学んだ無限ループと同じだ。</p>
<p>さっそく作っていこう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> input()
{
    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;&gt;&quot;</span>s ;
    <span class="dt">int</span> x {} ;
    <span class="bu">std::</span>cin &gt;&gt; x ;
    <span class="cf">return</span> x ;
}

<span class="dt">int</span> main()
{
    <span class="dt">int</span> sum = <span class="dv">0</span> ;
loop :
    sum = sum + input() ;
    <span class="bu">std::</span>cout &lt;&lt; sum &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
    <span class="cf">goto</span> loop ;
}</code></pre></div>
<p>関数inputは&quot;&gt;&quot;を表示してユーザーからの入力を得て戻り値として返すだけの関数だ。</p>
<p>&quot;sum = sum + input()&quot;は、変数sumに新しい値を代入するもので、その代入する値というのは、代入する前の変数sumの値と関数inputの戻り値を足した値だ。</p>
<p>このような変数xに何らかの値nを足した結果を元の変数xに代入するという処理はとても多く使われるので、C++では&quot;x = x + n&quot;を意味する省略記法&quot;x += x&quot;がある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> x = <span class="dv">1</span> ;
    <span class="dt">int</span> n = <span class="dv">5</span> ;

    x = x + n ; <span class="co">// 6</span>
    x += n ; <span class="co">// 11</span>
}</code></pre></div>
<p>さて、本題に戻ろう。上のプログラムは動く。しかし、プログラムを停止するにはCtrl-Cを押すしかない。できればプログラム自ら終了してもらいたいものだ。</p>
<p>そこで、ユーザーが0を入力したときはプログラムを終了するようにしよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> input()
{
    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;&gt;&quot;</span>s ;
    <span class="dt">int</span> x {} ;
    <span class="bu">std::</span>cin &gt;&gt; x ;
    <span class="cf">return</span> x ;
}

<span class="dt">int</span> main()
{
    <span class="dt">int</span> sum = <span class="dv">0</span> ;
loop :
    <span class="co">// 一度入力を変数に代入</span>
    <span class="dt">int</span> x = input() ;
    <span class="co">// 変数xが0でない場合</span>
    <span class="cf">if</span> ( x != <span class="dv">0</span> )
    {<span class="co">// 実行</span>
        sum = sum + x ;
        <span class="bu">std::</span>cout &lt;&lt; sum &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
        <span class="cf">goto</span> loop ;
    }
    <span class="co">// x == 0の場合、ここに実行が移る</span>
    <span class="co">// main関数の最後なのでプログラムが終了</span>
}</code></pre></div>
<p>うまくいった。このループは、ユーザーが0を入力した場合に繰り返しを終了する、条件付きのループだ。</p>
<h3 id="インデックスループ">インデックスループ</h3>
<p>最後に紹介するループは、インデックスループだ。n回&quot;hello&quot;sを出力するプログラムを書こう。問題は、このnはコンパイル時には与えられず、実行時にユーザーからの入力で与えられる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// n回出力する関数の宣言</span>
<span class="dt">void</span> hello_n( <span class="dt">int</span> n ) ;

<span class="dt">int</span> main()
{
    <span class="co">// ユーザーからの入力</span>
    <span class="dt">int</span> n {} ;
    <span class="bu">std::</span>cin &gt;&gt; n ;
    <span class="co">// n回出力</span>
    hello_n( n ) ;
}</code></pre></div>
<p>このコードをコンパイルしようとするとエラーになる。これは実はコンパイルエラーではなくてリンクエラーという種類のエラーだ。その理由は、関数hello_nに対する関数の定義が存在しないからだ。</p>
<p>関数というのは宣言と定義に分かれている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 関数の宣言</span>
<span class="dt">void</span> f( ) ;

<span class="co">// 宣言</span>
<span class="dt">void</span> f( )
<span class="co">// 定義</span>
{ }</code></pre></div>
<p>関数の宣言というのは何度書いても大丈夫だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 宣言</span>
<span class="dt">int</span> f( <span class="dt">int</span> x ) ;

<span class="co">// 再宣言</span>
<span class="dt">int</span> f( <span class="dt">int</span> x ) ;

<span class="co">// 再宣言</span>
<span class="dt">int</span> f( <span class="dt">int</span> x ) ;</code></pre></div>
<p>関数の宣言というのは戻り値の型や関数名や引数リストだけで、&quot;;&quot;で終わる。</p>
<p>関数の定義とは、関数の宣言の後の&quot;{}&quot;だ。この場合、宣言のあとに&quot;;&quot;は書かない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> f( <span class="dt">int</span> x ) { <span class="cf">return</span> x ; }</code></pre></div>
<p>関数の定義は一度しか書けない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 定義</span>
<span class="dt">void</span> f() {}
<span class="co">// エラー、再定義</span>
<span class="dt">void</span> f() {}</code></pre></div>
<p>なぜ関数は宣言と定義とに別れているかというと、C++では名前は宣言しないと使えないためだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// エラー</span>
    <span class="co">// 名前fは宣言されていない</span>
    f() ;
}

<span class="co">// 定義</span>
<span class="dt">void</span> f() { }</code></pre></div>
<p>なので、必ず名前は使う前に宣言しなければならない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 名前fの宣言</span>
<span class="dt">void</span> f() ;

<span class="dt">int</span> main()
{
    <span class="co">// OK、名前fは関数</span>
    f() ;
}

<span class="co">// 名前fの定義</span>
<span class="dt">void</span> f() { }</code></pre></div>
<p>さて、話をもとに戻そう。これから学ぶのはn回&quot;hello&quot;sと出力するプログラムの書き方だ。ただしnはユーザーが入力するので実行時にしかわからない。すでに我々はユーザーからnの入力を受け取る部分のプログラムは書いた。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// n回出力する関数の宣言</span>
<span class="dt">void</span> hello_n( <span class="dt">int</span> n ) ;

<span class="dt">int</span> main()
{
    <span class="co">// ユーザーからの入力</span>
    <span class="dt">int</span> n {} ;
    <span class="bu">std::</span>cin &gt;&gt; n ;
    <span class="co">// n回出力</span>
    hello_n( n ) ;
}</code></pre></div>
<p>あとは関数<code>hello_n(n)</code>がn回&quot;hello&quot;sと出力するようなループを実行すればいいのだ。</p>
<p>すでに我々は無限回&quot;hello&quot;sと出力する方法を知っている。まずは無限回ループを書こう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> hello_n( <span class="dt">int</span> n )
{
loop :
    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;hello</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
    <span class="cf">goto</span> loop ;
}</code></pre></div>
<p>終了条件付きループで学んだように、このループをn回繰り返した場合に終了させるには、<code>if文</code>を使って、終了条件に達したかどうかで実行を分岐させればよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> hello_n( <span class="dt">int</span> n )
{
loop :
    <span class="co">// まだn回繰り返していない場合</span>
    <span class="cf">if</span> ( ??? )
    { <span class="co">// 以下を実行</span>
        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;hello</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
        <span class="cf">goto</span> loop ;
    }
}</code></pre></div>
<p>このコードを完成させるにはどうすればいいのか。まず、現在何回繰り返しを行ったのか記録する必要がある。このために変数を作る。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> i = <span class="dv">0</span> ;</code></pre></div>
<p>変数iの初期値は0だ。まだ繰り返し実行を1回も行っていないということは、つまり0回繰り返し実行をしたということだ。</p>
<p>1回繰り返し実行をするたびに、変数iの値を1増やす。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">i = i + <span class="dv">1</span> ;</code></pre></div>
<p>これはすでに学んだように、もっと簡単に書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">i += <span class="dv">1</span> ;</code></pre></div>
<p>実は、更に簡単に書くこともできる。変数の代入前の値に1を足した値を代入する、つまり変数の値を1増やすというのはとてもよく書くコードなので、とても簡単な演算子が用意されている。<code>operator ++</code>だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> i = <span class="dv">0</span> ;
    ++i ; <span class="co">// 1</span>
    ++i ; <span class="co">// 2</span>
    ++i ; <span class="co">// 3</span>
}</code></pre></div>
<p>これで変数iの値は1増える。これをインクリメント(increment)という。</p>
<p>インクリメントと対になるのがデクリメント(decrement)だ。これは変数の値を1減らす。演算子は<code>operator --</code>だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> i = <span class="dv">0</span> ;
    --i ; <span class="co">// -1</span>
    --i ; <span class="co">// -2</span>
    --i ; <span class="co">// -3</span>
}</code></pre></div>
<p>さて、必要な知識は学び終えたので本題に戻ろう。n回の繰り返しをした後にループを終了するには、まず今何回繰り返し実行しているのかを記録する必要がある。その方法を学ぶために、0, 1, 2, 3, 4...と無限に出力されるプログラムを書いてみよう。</p>
<p>このプログラムを実行すると以下のように表示される。</p>
<pre><code>$ make run
1, 2, 3, 4, 5, 6, [Ctrl-C]</code></pre>
<p>Ctrl-Cを押すまでプログラムは無限に実行される。</p>
<p>ではどうやって書くのか。以下のようにする。</p>
<ol style="list-style-type: decimal">
<li>変数iを作り、値を0にする</li>
<li>変数iと&quot;, &quot;sを出力する</li>
<li>変数iをインクリメントする</li>
<li>goto 2</li>
</ol>
<p>この処理を素直に書くと以下のコードになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 1. 変数iを作り、値を0にする</span>
    <span class="dt">int</span> i = <span class="dv">0</span> ;
loop :
    <span class="co">// 2. 変数iと&quot;, &quot;sを出力する</span>
    <span class="bu">std::</span>cout &lt;&lt; i &lt;&lt; <span class="st">&quot;, &quot;</span>s ;
    <span class="co">// 3. 変数iをインクリメントする</span>
    ++i ;
    <span class="co">// 4. goto 2</span>
    <span class="cf">goto</span> loop ;
}</code></pre></div>
<p>どうやら、いま何回繰り返し実行しているか記録することはできるようになったようだ。</p>
<p>ここまでくればしめたもの。あとは<code>goto文</code>を実行するかどうかを<code>if文</code>で条件分岐すればよい。しかし、<code>if文</code>の中にどんな条件を書けばいいのだろうか。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> hello_n( <span class="dt">int</span> n )
{
    <span class="dt">int</span> i = <span class="dv">0</span> ;
loop :
    <span class="co">// まだn回繰り返し実行をしていなければ実行</span>
    <span class="cf">if</span> ( ??? )
    {
        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;hello</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
        ++i ;
        <span class="cf">goto</span> loop ;
    }
}</code></pre></div>
<p>具体的に考えてみよう。n == 3のとき、つまり3回繰り返すときを考えよう。</p>
<ol style="list-style-type: decimal">
<li>1回目のif文実行の時、i == 0</li>
<li>2回めのif文実行の時、i == 1</li>
<li>3回目のif文実行の時、i == 2</li>
<li>4回目のif文実行の時、i == 3</li>
</ol>
<p>ここではn == 3なので、3回まで実行してほしい。つまり3回目まではtrueになり、4回目のif文実行のときにはfalseになるような式を書く。そのような式とは、ズバリ&quot;i != n&quot;だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> hello_n( <span class="dt">int</span> n )
{
    <span class="dt">int</span> i = <span class="dv">0</span> ;
loop :
    <span class="cf">if</span> ( i != n )
    {
        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;hello</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
        ++i ;
        <span class="cf">goto</span> loop ;
    }
}</code></pre></div>
<p>早速実行してみよう。</p>
<pre><code>$ make run
3
hello
hello
hello
$ make run
2
hello
hello</code></pre>
<p>なるほど、動くようだ。しかしこのプログラムにはバグがある。-1を入力すると、何故か大量のhelloが出力されてしまうのだ。</p>
<pre><code>$ make run
-1
hello
hello
hello
hello
[Ctrl-C]</code></pre>
<p>この原因はまだ現時点の読者には難しい。この謎はいずれ明らかにするとして、今はnが負数の場合にプログラムを0回の繰り返し分の実行で終了するように書き換えよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> hello_n( <span class="dt">int</span> n )
{
    <span class="co">// nが負数ならば</span>
    <span class="cf">if</span> ( n &lt; <span class="dv">0</span> )
        <span class="co">// 関数の実行を終了</span>
        <span class="cf">return</span> ;

    <span class="dt">int</span> i = <span class="dv">0</span> ;
loop :
    <span class="cf">if</span> ( i != n )
    {
        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;hello</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
        ++i ;
        <span class="cf">goto</span> loop ;
    }
}</code></pre></div>
<h2 id="while文">while文</h2>
<p><code>goto文</code>は極めて原始的で使いづらい機能だ。現実のC++プログラムでは<code>goto文</code>はめったに使われない。もっと簡単な機能を使う。ではなぜ<code>goto文</code>が存在するかというと、<code>goto文</code>は最も原始的で基礎的で、他の繰り返し機能は<code>if文</code>と<code>goto文</code>に変換することで実現できるからだ。</p>
<p><code>goto文</code>より簡単な繰り返し文に、<code>while文</code>がある。ここでは<code>goto文</code>と<code>while文</code>を比較することで、<code>while文</code>を学んでいこう。</p>
<h3 id="無限ループ-1">無限ループ</h3>
<p>無限ループを<code>goto文</code>で書く方法を思い出してみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> hello = []()
    { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;hello</span><span class="sc">\n</span><span class="st">&quot;</span>s ; } ;

loop :
    <span class="co">// 繰り返し実行される文</span>
    hello() ;
    <span class="cf">goto</span> loop ;
}</code></pre></div>
<p>このコードで本当に重要なのは関数helloを呼び出している部分だ。ここが繰り返し実行される文で、<code>ラベル文</code>と<code>goto文</code>は、繰り返し実行を実現するために必要な記述でしかない。</p>
<p>そこで<code>while(true)</code>だ。<code>while(true)</code>は<code>goto文</code>と<code>ラベル文</code>よりも簡単に無限ループを実現できる。</p>
<pre><code>while (true) 文</code></pre>
<p><code>while文</code>は文を無限に繰り返して実行してくれる。試してみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> hello = []()
    { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;hello</span><span class="sc">\n</span><span class="st">&quot;</span>s ; } ;

    <span class="cf">while</span> (<span class="kw">true</span>)
        hello() ;
}</code></pre></div>
<p>このコードの重要な部分は以下の2行。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="cf">while</span> (<span class="kw">true</span>)
    hello() ;</code></pre></div>
<p>これを<code>goto文</code>と<code>ラベル文</code>を使った無限ループと比べてみよう。</p>
<pre><code>loop:
    hello() ;
    goto loop ;</code></pre>
<p>どちらも同じ意味のコードだが、<code>while文</code>の方が明らかに書きやすくなっているのがわかる。</p>
<p><code>goto文</code>で学んだ、ユーザーからの整数値の入力の合計の計算を繰り返すプログラムを<code>while(true)</code>で書いてみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> input()
{
    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;&gt;&quot;</span>s ;
    <span class="dt">int</span> x {} ;
    <span class="bu">std::</span>cin &gt;&gt; x ;
    <span class="cf">return</span> x ;
}

<span class="dt">int</span> main()
{
    <span class="dt">int</span> sum = <span class="dv">0</span> ;

    <span class="cf">while</span>( <span class="kw">true</span> )
    {
        sum += input() ;
        <span class="bu">std::</span>cout &lt;&lt; sum &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
    }
}</code></pre></div>
<p>重要なのは以下の4行だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="cf">while</span>( <span class="kw">true</span> )
{
    sum += input() ;
    <span class="bu">std::</span>cout &lt;&lt; sum &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
}</code></pre></div>
<p>これを<code>goto文</code>で書いた場合と比べてみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">loop :
    sum += input() ;
    <span class="bu">std::</span>cout &lt;&lt; sum &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
    <span class="cf">goto</span> loop ;</code></pre></div>
<p>本当に重要で本質的な、繰り返し実行をする部分の2行のコードは全く変わっていない。それでいて<code>while(true)</code>の方が圧倒的に簡単に書ける。</p>
<h2 id="終了条件付きループ-1">終了条件付きループ</h2>
<p>なるほど、無限ループを書くのに、<code>goto文</code>を使うより<code>while(true)</code>を使ったほうがいいことがわかった。では他のループの場合でも、<code>while文</code>の方が使いやすいだろうか。</p>
<p>本書を先頭から読んでいる優秀な読者は<code>while(true)</code>の<code>true</code>はbool型の値であることに気がついているだろう。実は<code>while(E)</code>の括弧の中Eは、<code>if(E)</code>と書くのと全く同じ<code>条件</code>なのだ。<code>条件</code>が<code>true</code>であれば繰り返し実行される。<code>false</code>なら繰り返し実行されない。</p>
<pre><code>while ( 条件 ) 文</code></pre>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 実行されない</span>
    <span class="cf">while</span> ( <span class="kw">false</span> )
        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;No&quot;</span>s ;

    <span class="co">// 実行されない</span>
    <span class="cf">while</span> ( <span class="dv">1</span> &gt; <span class="dv">2</span> )
        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;No&quot;</span>s ;

    <span class="co">// 実行される</span>
    <span class="co">// 無限ループ</span>
    <span class="cf">while</span> ( <span class="dv">1</span> &lt; <span class="dv">2</span> )
        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Yes&quot;</span>s ;
}</code></pre></div>
<p><code>while文</code>を使って、0が入力されたら終了する合計値計算プログラムを書いてみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> input()
{
    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;&gt;&quot;</span>s ;
    <span class="dt">int</span> x {} ;
    <span class="bu">std::</span>cin &gt;&gt; x ;
    <span class="cf">return</span> x ;
}

<span class="dt">int</span> main()
{
    <span class="dt">int</span> sum = <span class="dv">0</span> ;
    <span class="dt">int</span> x {} ;

    <span class="cf">while</span>( ( x = input() ) != <span class="dv">0</span> )
    {
        sum += x ;
        <span class="bu">std::</span>cout &lt;&lt; sum &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
    }
}</code></pre></div>
<p>重要なのはこの5行。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="cf">while</span>( ( x = input() ) != <span class="dv">0</span> )
{
    sum += x ;
    <span class="bu">std::</span>cout &lt;&lt; sum &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
}</code></pre></div>
<p>ここではちょっとむずかしいコードが出てくる。<code>while</code>の中の<code>条件</code>が、&quot;( x = input() ) != 0&quot;になっている。これはどういうことか。</p>
<p>実は<code>条件</code>は<code>bool型</code>に変換さえできればどんな式でも書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> x { } ;

    <span class="cf">if</span> ( (x = <span class="dv">1</span>) == <span class="dv">1</span> )
        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;(x = 1) is 1.</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
}</code></pre></div>
<p>このコードでは、&quot;(x=1)&quot;と&quot;1&quot;が等しいか&quot;==&quot;どうかを判断している。&quot;(x=1)&quot;という式は変数xに1を代入する式だ。<code>代入式</code>の値は、代入された変数の値になる。この場合変数xの値だ。変数xには1が代入されているので、その値は1、つまり&quot;(x=1) == 1&quot;は&quot;1 == 1&quot;と書くのと同じ意味になる。この結果は<code>true</code>だ。</p>
<p>さて、このことを踏まえて、&quot;( x = input() ) != 0&quot;を考えてみよう。</p>
<p>&quot;( x = input() )&quot;は変数xに関数inputを呼び出した結果を代入している。関数inputはユーザーから入力を得て、その入力をそのまま返す。つまり変数xにはユーザーの入力した値が代入される。その結果が0と等しくないか&quot;!=&quot;どうかを判断している。つまり、ユーザーが0を入力した場合はfalse、非ゼロを入力した場合はtrueとなる。</p>
<p><code>while(条件)</code>は<code>条件</code>が<code>true</code>となる場合に繰り返し実行をする。結果として、ユーザーが0を入力するまで繰り返し実行をするコードになる。</p>
<p><code>goto文</code>を使った終了条件付きループと比較してみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">loop:
    <span class="cf">if</span> ( (x = input() ) != <span class="dv">0</span> )
    {
        sum += x ;
        <span class="bu">std::</span>cout &lt;&lt; sum &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
        <span class="cf">goto</span> loop ;
    }</code></pre></div>
<p><code>while文</code>の方が圧倒的に書きやすいことがわかる。</p>
<h3 id="インデックスループ-1">インデックスループ</h3>
<p>n回&quot;hello&quot;sと出力するプログラムを<code>while文</code>で書いてみよう。ただしnはユーザーが入力するものとする。</p>
<p>まずは<code>goto文</code>でも使ったループ以外の処理をするコードから。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> hello_n( <span class="dt">int</span> n ) ;

<span class="dt">int</span> main()
{
    <span class="dt">int</span> n {} ;
    <span class="bu">std::</span>cin &gt;&gt; n ;
    hello_n( n ) ;
}</code></pre></div>
<p>後は関数hello_n(n)がインデックスループを実装するだけだ。ただしnが負数ならば何も実行しないように仕様。</p>
<p><code>goto文</code>でインデックスループを書くときに学んだように、</p>
<ol style="list-style-type: decimal">
<li>n &lt; 0ならば関数を終了</li>
<li>変数iを作り値を0にする</li>
<li>i != nならば繰り返し実行</li>
<li>出力</li>
<li>++i</li>
<li>goto 3.</li>
</ol>
<p>を<code>while文</code>で書くだけだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> hello_n( <span class="dt">int</span> n )
{
    <span class="co">// 1. n &lt; 0ならば関数を終了</span>
    <span class="cf">if</span> ( n &lt; <span class="dv">0</span> )
        <span class="cf">return</span> ;

    <span class="co">// 2. 変数iを作り値を0にする</span>
    <span class="dt">int</span> i = <span class="dv">0</span> ;

    <span class="co">//3. i != nならば繰り返し実行</span>
    <span class="cf">while</span>( i != n )
    {   <span class="co">// 4. 出力</span>
        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;hello</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
        <span class="co">// 5. ++i</span>
        ++i ;
    } <span class="co">// 6. goto 3</span>
}</code></pre></div>
<p>重要な部分だけ抜き出すと以下の通り。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="cf">while</span>( i != n )
{
    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;hello</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
    ++i ;
}</code></pre></div>
<p><code>goto文</code>を使ったインデックスループと比較してみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">loop :
    <span class="cf">if</span> ( i != n )
    {
        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;hello</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
        ++i ;
        <span class="cf">goto</span> loop ;
    }</code></pre></div>
<p>読者の中にはあまり変わらないのではないかと思う人もいるかもしれない。しかし、次の問題を解くプログラムを書くと、<code>while文</code>がいかに楽に書けるかを実感するだろう。</p>
<p>問題：以下のような九九の表を出力するプログラムを書きなさい</p>
<pre><code>1   2   3   4   5   6   7   8   9   
2   4   6   8   10  12  14  16  18  
3   6   9   12  15  18  21  24  27  
4   8   12  16  20  24  28  32  36  
5   10  15  20  25  30  35  40  45  
6   12  18  24  30  36  42  48  54  
7   14  21  28  35  42  49  56  63  
8   16  24  32  40  48  56  64  72  
9   18  27  36  45  54  63  72  81</code></pre>
<p>もちろん、このような文字列を愚直に出力しろという問題ではない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 違う！</span>
    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;1 2 3 4 5...&quot;</span>s ;
}</code></pre></div>
<p>逐次実行、条件分岐、ループまでを習得した誇りある本物のプログラマーである我々は、もちろん九九の表はループを書いて出力する。</p>
<p>まず出力すべき表をみると、数値が左揃えになっていることに気がつくだろう。</p>
<pre><code>4   8   12
5   10  15</code></pre>
<p>8は1文字、10は2文字にもかかわらず、12と15は同じ列目から始まっている。これは出力するスペース文字を調整することでも実現できるが、ここでは単にタブ文字を使っている。</p>
<p>タブ文字はMakefileを書くのにも使った文字で、C++の文字列中に直接書くこともできるが、エスケープ文字<code>\t</code>を使ってもよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>cout &lt;&lt; <span class="dv">4</span>\t8\t12\n5\t10\t15<span class="st">&quot;s ;</span>
}</code></pre></div>
<p>エスケープ文字<code>\n</code>が改行文字に置き換わるように、エスケープ文字<code>\t</code>はタブ文字に置き換わる。</p>
<p>九九の表はどうやって出力すればよいだろうか。計算自体はC++では&quot;a*b&quot;でできる。上の表がどのように計算されているかを考えてみよう。</p>
<pre><code>1*1 1*2 1*3 1*4 1*5 1*6 1*7 1*8 1*9 
2*1 2*2 2*3 2*4 2*5 2*6 2*7 2*8 2*9 
3*1 3*2 3*3 3*4 3*5 3*6 3*7 3*8 3*9 
4*1 4*2 4*3 4*4 4*5 4*6 4*7 4*8 4*9 
5*1 5*2 5*3 5*4 5*5 5*6 5*7 5*8 5*9 
6*1 6*2 6*3 6*4 6*5 6*6 6*7 6*8 6*9 
7*1 7*2 7*3 7*4 7*5 7*6 7*7 7*8 7*9 
8*1 8*2 8*3 8*4 8*5 8*6 8*7 8*8 8*9 
9*1 9*2 9*3 9*4 9*5 9*6 9*7 9*8 9*9</code></pre>
<p>これをみると、&quot;a*b&quot;のうちのaを1から9までインクリメントし、それに対してbを1から9までインクリメントさせればよい。つまり、9回のインデックスループの中で9回のインデックスループを実行することになる。ループの中のループだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="cf">while</span> ( 条件 )
    <span class="cf">while</span> ( 条件 )
        文</code></pre></div>
<p>早速そのようなコードを書いてみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 1から9まで</span>
    <span class="dt">int</span> a = <span class="dv">1</span> ;
    <span class="cf">while</span> ( a &lt;= <span class="dv">9</span> )
    {
        <span class="co">// 1から9まで</span>
        <span class="dt">int</span> b = <span class="dv">1</span> ;
        <span class="cf">while</span> ( b &lt;= <span class="dv">9</span> )
        {
            <span class="co">// 計算結果を出力</span>
            <span class="bu">std::</span>cout &lt;&lt; a * b &lt;&lt; <span class="st">&quot;</span><span class="sc">\t</span><span class="st">&quot;</span>s ;
            ++b ;
        }
        <span class="co">// 段の終わりに改行</span>
        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
        ++a ;
    }
}</code></pre></div>
<p>うまくいった。</p>
<p>ところで、このコードを<code>goto文</code>で書くとどうなるだろうか。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> a = <span class="dv">1</span> ;
loop_outer :
    <span class="cf">if</span> ( a &lt;= <span class="dv">9</span> )
    {
        <span class="dt">int</span> b = <span class="dv">1</span> ;
loop_inner :
        <span class="cf">if</span> ( b &lt;= <span class="dv">9</span> )
        {
            <span class="bu">std::</span>cout &lt;&lt; a * b &lt;&lt; <span class="st">&quot;</span><span class="sc">\t</span><span class="st">&quot;</span>s ;
            ++b ;
            <span class="cf">goto</span> loop_inner ;
        }
        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
        ++a ;
        <span class="cf">goto</span> loop_outer ;
    }
}</code></pre></div>
<p>とてつもなく読みにくい。</p>
<h2 id="for文">for文</h2>
<p>ところで今まで<code>while文</code>で書いてきたインデックスループには特徴がある。</p>
<p>試しに1から100までの整数を出力するコードを見てみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> i = <span class="dv">1</span> ;
    <span class="cf">while</span> ( i &lt;= <span class="dv">100</span> )
    {
        <span class="bu">std::</span>cout &lt;&lt; i &lt;&lt; <span class="st">&quot; &quot;</span>s ;
        ++i ;
    }
}</code></pre></div>
<p>このコードを読むと、以下のようなパターンがあることがわかる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// ループ実行前の変数の宣言と初期化</span>
    <span class="dt">int</span> i = <span class="dv">1</span> ;
    <span class="co">// ループ中の終了条件の確認</span>
    <span class="cf">while</span> ( i &lt;= <span class="dv">100</span> )
    {
        <span class="co">// 実際に繰り返したい文</span>
        <span class="bu">std::</span>cout &lt;&lt; i &lt;&lt; <span class="st">&quot; &quot;</span>s ;
        <span class="co">// 各ループの最後に必ず行う処理</span>
        ++i ;
    }
}</code></pre></div>
<p>ここで真に必要なのは、「実際に繰り返したい文」だ。その他の処理は、ループを実現するために必要なコードだ。ループの実現に必要な処理が飛び飛びの場所にあるのは甚だわかりにくい。</p>
<p><code>for文</code>はそのような問題を解決するための機能だ。</p>
<pre><code>for ( 変数の宣言 ; 終了条件の確認 ; 各ループの最後に必ず行う処理 ) 文</code></pre>
<p><code>for文</code>を使うと、上のコードは以下のように書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="cf">for</span> ( <span class="dt">int</span> i = <span class="dv">1</span> ; i &lt;= <span class="dv">100</span> ; ++i )
    {
        <span class="bu">std::</span>cout &lt;&lt; i &lt;&lt; <span class="st">&quot; &quot;</span>s ;
    } 
}</code></pre></div>
<p>ループの実現に必要な部分だけ抜き出すと以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// for文の開始</span>
<span class="cf">for</span> (
<span class="co">// 変数の宣言と初期化</span>
<span class="dt">int</span> i = <span class="dv">1</span> ;
<span class="co">// 終了条件の確認</span>
i &lt;= <span class="dv">100</span> ;
<span class="co">// 各ループの最後に必ず行う処理</span>
++i )</code></pre></div>
<p><code>for文</code>はインデックスループによくあるパターンをわかりやすく書くための機能だ。例えば<code>while文</code>のときに書いた九九の表を出力するプログラムは、<code>for文</code>ならばこんなに簡潔に書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="cf">for</span> ( <span class="dt">int</span> a = <span class="dv">1</span> ; a &lt;= <span class="dv">9</span> ; ++a )
    {
        <span class="cf">for</span> ( <span class="dt">int</span> b = <span class="dv">1</span> ; b &lt;= <span class="dv">9</span> ; ++b )
        { <span class="bu">std::</span>cout &lt;&lt; a*b &lt;&lt; <span class="st">&quot;</span><span class="sc">\t</span><span class="st">&quot;</span>s ; }

        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
    }
}</code></pre></div>
<p><code>while文</code>を使ったコードと比べてみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">
<span class="dt">int</span> main()
{
    <span class="dt">int</span> a = <span class="dv">1</span> ;
    <span class="cf">while</span> ( a &lt;= <span class="dv">9</span> )
    {
        <span class="dt">int</span> b = <span class="dv">1</span> ;
        <span class="cf">while</span> ( b &lt;= <span class="dv">9</span> )
        {
            <span class="bu">std::</span>cout &lt;&lt; a * b &lt;&lt; <span class="st">&quot;</span><span class="sc">\t</span><span class="st">&quot;</span>s ;
            ++b ;
        }
        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
        ++a ;
    }
}</code></pre></div>
<p>格段に読みやすくなっていることがわかる。</p>
<p>C++ではカンマ','を使うことで、複数の<code>式</code>をひとつの<code>文</code>に書くことができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">
<span class="dt">int</span> main()
{
    <span class="dt">int</span> a = <span class="dv">0</span>, b = <span class="dv">0</span> ;
    ++a, ++b ;
}</code></pre></div>
<p><code>for文</code>でもカンマが使える。九九の表を出力するプログラムは、以下のように書くこともできる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="cf">for</span> ( <span class="dt">int</span> a = <span class="dv">1</span> ; a &lt;= <span class="dv">9</span> ; ++a, <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s )
        <span class="cf">for</span> ( <span class="dt">int</span> b = <span class="dv">1</span> ; b &lt;= <span class="dv">9</span> ; ++b )
            <span class="bu">std::</span>cout &lt;&lt; a*b &lt;&lt; <span class="st">&quot;</span><span class="sc">\t</span><span class="st">&quot;</span>s ;
}</code></pre></div>
<p>変数もカンマで複数宣言できると知った読者は、以下のように書きたくなるだろう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="cf">for</span> (   <span class="dt">int</span> a = <span class="dv">1</span>, b = <span class="dv">1</span> ;
            a &lt;= <span class="dv">9</span> ;
            +++a, ++b,
            <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s
        )
            <span class="bu">std::</span>cout &lt;&lt; a*b &lt;&lt; <span class="st">&quot;</span><span class="sc">\t</span><span class="st">&quot;</span>s ;
}</code></pre></div>
<p>これは動かない。なぜならば、<code>for文</code>を2つネストさせたループは、<span class="math inline">\(a \times b\)</span>回のループで、変数aが1から9まで変化するそれぞれに対して、変数bが1から9まで変化する。しかし、上の<code>for文</code>ひとつのコードは、変数a, bともに同時に1から9まで変化する。したがって、これは単にa回のループでしかない。a回のループの中でb回のループをすることで<span class="math inline">\(a \times b\)</span>回のループを実現できる。</p>
<p><code>for文</code>では使わない部分を省略することができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">bool</span> b = <span class="kw">true</span>
    <span class="co">// for文による変数宣言は使わない</span>
    <span class="cf">for</span> ( ; b ; b = <span class="kw">false</span> )
        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;hello&quot;</span>s ;
}</code></pre></div>
<p><code>for文</code>で終了条件を省略した場合、<code>true</code>と同じになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="cf">for</span> (;;)
        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;hello</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
}</code></pre></div>
<p>このプログラムは&quot;hello&quot;sと無限に出力し続けるプログラムだ。&quot;for(;;)&quot;は&quot;for(;true;)&quot;と同じ意味であり、&quot;while(true)&quot;とも同じ意味だ。</p>
<h2 id="do文">do文</h2>
<p><code>do文</code>は<code>while文</code>に似ている。</p>
<pre><code>do 文 while ( 条件 ) ;</code></pre>
<p>比較のために<code>while文</code>の文法も書いてみると以下のようになる。</p>
<pre><code>while ( 条件 ) 文</code></pre>
<p><code>while文</code>はまず<code>条件</code>を確認し<code>true</code>の場合<code>文</code>を実行する。これを繰り返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="cf">while</span> ( <span class="kw">false</span> )
    {
        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;hello</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
    }
}</code></pre></div>
<p><code>do文</code>はまず<code>文</code>を実行する。しかる後に<code>条件</code>を確認し<code>true</code>の場合繰り返しを行う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="cf">do</span> {
        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;hello</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
    } <span class="cf">while</span> ( <span class="kw">false</span> ) ;
}</code></pre></div>
<p>違いがわかっただろうか。<code>do文</code>は繰り返し実行する<code>文</code>を、<code>条件</code>がなんであれ、最初に一度実行する。</p>
<p><code>do文</code>を使うと条件にかかわらず文を1回は実行するコードが、文の重複なく書けるようになる。</p>
<h2 id="break文">break文</h2>
<p>ループの実行の途中で、ループの中から外に脱出したくなった場合、どうすればいいのだろうか。例えばループを実行中に何らかのエラーを検出したので処理を中止したい場合などだ</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="cf">while</span> ( <span class="kw">true</span> )
{
    <span class="co">// 処理</span>

    <span class="cf">if</span> ( is_error() )
        <span class="co">// エラーのため脱出したくなった</span>

    <span class="co">// 処理</span>
}</code></pre></div>
<p><code>break文</code>はループの途中から脱出するための文だ。</p>
<pre><code>break ;</code></pre>
<p><code>break文</code>は<code>for文</code>、<code>while文</code>、<code>do文</code>の中でしか使えない。</p>
<p><code>break文</code>は<code>for文</code>、<code>while文</code>、<code>do文</code>の外側に脱出する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="cf">while</span> ( <span class="kw">true</span> )
    {
        <span class="co">// 処理</span>

        <span class="cf">break</span> ;

        <span class="co">// 処理</span>
    }
}</code></pre></div>
<p>これは以下のようなコードと同じだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="cf">while</span> ( <span class="kw">true</span> )
    {
        <span class="co">// 処理</span>

        <span class="cf">goto</span> break_while ;

        <span class="co">// 処理</span>
    }
break_while : ;
}</code></pre></div>
<p><code>break文</code>は最も内側の<code>繰り返し文</code>から脱出する</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="cf">while</span> ( <span class="kw">true</span> ) <span class="co">// 外側</span>
    {
        <span class="cf">while</span> ( <span class="kw">true</span> ) <span class="co">// 内側</span>
        {
            <span class="cf">break</span> ;
        }
        <span class="co">// ここに脱出</span>
    }
}</code></pre></div>
<h2 id="continue文">continue文</h2>
<p>ループの途中で、今のループを打ち切って次のループに進みたい場合はどうすればいいのだろう。例えば、ループの途中でエラーを検出したので、そのループについては処理を打ち切りたい場合だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="cf">while</span> ( <span class="kw">true</span> )
{
    <span class="co">// 処理</span>

    <span class="cf">if</span> ( is_error() )
        <span class="co">// このループは打ち切りたい</span>

    <span class="co">// 処理</span>
}</code></pre></div>
<p><code>continue文</code>はループを打ち切って次のループに行くための文だ。</p>
<pre><code>continue ;</code></pre>
<p><code>continue文</code>は<code>for文</code>、<code>while文</code>、<code>do</code>文の中でしか使えない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="cf">while</span> ( <span class="kw">true</span> )
    {
        <span class="co">// 処理</span>

        <span class="cf">continue</span> ;

        <span class="co">// 処理</span>
    }
}</code></pre></div>
<p>これは以下のようなコードと同じだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="cf">while</span> ( <span class="kw">true</span> )
    {
        <span class="co">// 処理</span>

        <span class="cf">goto</span> continue_while ;

        <span class="co">// 処理</span>

continue_while : ;
    }
}</code></pre></div>
<p><code>continue</code>文はループの最後に処理を移す。その結果、次のループを実行するかどうかの<code>条件</code>を評価することになる。</p>
<p><code>continue文</code>は最も内側のループに対応する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="cf">while</span> ( <span class="kw">true</span> ) <span class="co">// 外側</span>
    {
        <span class="cf">while</span> ( <span class="kw">true</span> ) <span class="co">// 内側</span>
        {
            <span class="cf">continue</span> ;
            <span class="co">// continueはここに実行を移す</span>
        }
    }
}</code></pre></div>
<h2 id="再帰関数">再帰関数</h2>
<p>最後に関数でループを実装する方法を示してこの章を終わりにしよう。</p>
<p>関数は関数を呼び出すことができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f() { }

<span class="dt">void</span> g()
{
    f() ; <span class="co">// 関数fの呼び出し</span>
}

<span class="dt">int</span> main()
{
    g() ; <span class="co">// 関数gの呼び出し</span>
}</code></pre></div>
<p>ではもし、関数が自分自身を呼び出したらどうなるだろうか。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> hello()
{
    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;hello</span><span class="sc">\n</span><span class="st">&quot;</span> ;
    hello() ;
}

<span class="dt">int</span> main()
{
    hello() ;
}</code></pre></div>
<ol style="list-style-type: decimal">
<li>関数<code>main</code>は関数<code>hello</code>を呼び出す</li>
<li>関数<code>hello</code>は&quot;hello&quot;と出力して関数<code>hello</code>を呼び出す</li>
</ol>
<p>関数<code>hello</code>は必ず関数<code>hello</code>を呼び出すので、この実行は無限ループする。</p>
<p>関数が自分自身を呼び出すことを、<code>再帰(recursion)</code>という。</p>
<p>なるほど、再帰によって無限ループを実現できることはわかった。では終了条件付きループは書けるだろうか。</p>
<p>関数は<code>return文</code>によって呼び出し元に戻る。単に'return ;'と書けば再帰はしない。そして、<code>if文</code>によって実行は分岐できる。これを使えば再帰で終了条件付きループが実現できる。</p>
<p>試しに、ユーザーが0を入力するまでループし続けるプログラムを書いてみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// ユーザーからの入力を返す</span>
<span class="dt">int</span> input ()
{
    <span class="dt">int</span> x { } ;
    <span class="bu">std::</span>cin &gt;&gt; x ;
    <span class="cf">return</span> x ;
}

<span class="co">// 0の入力を終了条件としたループ</span>
<span class="dt">void</span> loop_until_zero()
{
    <span class="cf">if</span> ( input() == <span class="dv">0</span> )
        <span class="cf">return</span> ;
    <span class="cf">else</span>
        loop_until_zero() ;
}

<span class="dt">int</span> main()
{
    loop_until_zero() ;
}</code></pre></div>
<p>書けた。</p>
<p>ではインデックスループはどうだろうか。1から10までの整数を出力してみよう。</p>
<p>インデックスループを実現するには、書き換えられる変数が必要だ。関数は引数で値を渡すことができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> g( <span class="dt">int</span> x ) { }
<span class="dt">void</span> f( <span class="dt">int</span> x ) { g( x<span class="dv">+1</span> ) ; }

<span class="dt">int</span> main() { f( <span class="dv">0</span> ) ; }</code></pre></div>
<p>これをみると、関数<code>main</code>は関数<code>f</code>に引数0を渡し、関数<code>f</code>は関数<code>g</code>に引数1を渡している。これをもっと再帰的に考えよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> until_ten( <span class="dt">int</span> x )
{
    <span class="cf">if</span> ( x &gt; <span class="dv">10</span> )
        <span class="cf">return</span> ;
    <span class="cf">else</span>
    {
        <span class="bu">std::</span>cout &lt;&lt; x &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span> ;
        <span class="cf">return</span> until_ten( x + <span class="dv">1</span> ) ;
    }
}

<span class="dt">int</span> main()
{
    until_ten(<span class="dv">1</span>) ;
}</code></pre></div>
<p>関数<code>main</code>は関数<code>until_ten</code>に引数1を渡す。</p>
<p>関数<code>until_ten</code>は引数が10より大きければ何もせず処理を戻し、そうでなければ引数を出力して再起する。その時引数は+1される。</p>
<p>これによりインデックスループが実現できる。</p>
<p>関数は戻り値を返すことができる。再帰で戻り値を使うことにより面白い問題も解くことができる。</p>
<p>例えば、1と0だけを使った10進数の整数を2進数に変換するプログラムを書いてみよう。</p>
<pre><code>$ make run
&gt; 0
0
&gt; 1
1
&gt; 10
2
&gt; 11
3
&gt; 1010
10
&gt; 1111
15</code></pre>
<p>まず10進数と2進数を確認しよう。数学的に言うと「10を底にする」とか「2を底にする」という言い方をする。</p>
<p>具体的な例を出すと10進数では1,2,3,4,5,6,7,8,9,0の文字を使う。<code>1234</code>は以下のようになる。</p>
<p><span class="math display">\[
1234 = 1 \times 10^3 + 2 \times 10^2 + 3 \times 10^1 + 4 \times 10^0 = 1 \times 1000 + 2 \times 100 + 3 \times 10 + 4 \times 1
\]</span></p>
<p>10進数で<code>1010</code>は以下のようになる。</p>
<p><span class="math display">\[
1010 = 1 \times 10^3 + 0 \times 10^2 + 1 \times 10^1 + 0 \times 10^0 = 1 \times 1000 + 0 \times 100 + 1 \times 10 + 0 \times 1
\]</span></p>
<p>2進数では1,0の文字を使う。<code>1010</code>は以下のようになる。</p>
<p><span class="math display">\[
1010 = 1 \times 2^3 + 0 \times 2^2 + 1 \times 2^1 + 0 \times 2^0 = 1 \times 8 + 0 \times 4 + 1 \times 2 + 0 \times 1
\]</span></p>
<p>2進数の<code>1010</code>は10進数では<code>10</code>になる。</p>
<p>では問題を解いていこう。</p>
<p>問題を難しく考えるとかえって解けなくなる。ここではすでに10進数から2進数への変換は解決したものとして考えよう。関数<code>convert</code>によってその問題は解決した。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 2進数への変換</span>
<span class="dt">int</span> convert( <span class="dt">int</span> n ) ;</code></pre></div>
<p>まだ我々は関数<code>convert</code>の中身を書いていないが、すでに書き終わったと仮定しよう。するとプログラムの残りの部分は以下のように書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> convert( <span class="dt">int</span> n ) ;

<span class="co">// 入力</span>
<span class="dt">int</span> input()
{
    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;&gt; &quot;</span> ;
    <span class="dt">int</span> x{} ;
    <span class="bu">std::</span>cin &gt;&gt; x ;
    <span class="cf">return</span> x ;
}

<span class="co">// 出力</span>
<span class="dt">void</span> output( <span class="dt">int</span> binary )
{
    <span class="bu">std::</span>cout &lt;&lt; binary &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
}

<span class="dt">int</span> main()
{
    <span class="co">// 入力、変換、出力のループ</span>
    <span class="cf">while</span>( <span class="kw">true</span> )
    {
        <span class="kw">auto</span> decimal = input() ;
        <span class="kw">auto</span> binary = convert( decimal ) ;
        output( binary ) ;
    } 
}</code></pre></div>
<p>後は関数<code>convert</code>を実装すればよいだけだ。</p>
<p>関数<code>convert</code>に引数を渡した時の結果を考えてみよう。convert(1010)は10を返し、convert(1111)は15を返す。</p>
<p>ではconvert(-1010)の結果はどうなるだろうか。これは-10になる。</p>
<p>負数と正数の違いを考えるのは面倒だ。ここでは正数を引数として与えると10進数から2進数へ変換した答えを返してくる魔法のような関数<code>solve</code>をすでに書き終えたと仮定しよう。我々はまだ関数<code>solve</code>を書いていないが、その問題は未来の自分に押し付けよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 1,0のみを使った10進数から</span>
<span class="co">// 2進数へ変換する関数</span>
<span class="dt">int</span> solve( <span class="dt">int</span> n ) ;</code></pre></div>
<p>すると、関数<code>convert</code>がやるのは負数と正数の処理だけでよい。</p>
<ol style="list-style-type: decimal">
<li>引数が正数の場合はそのまま関数<code>solve</code>に渡してreturn</li>
<li>引数が負数の場合は絶対値を関数<code>solve</code>に渡して負数にしてreturn</li>
</ol>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> convert( <span class="dt">int</span> n )
{
    <span class="co">// 引数が正数の場合</span>
    <span class="cf">if</span> ( n &gt; <span class="dv">0</span> )
        <span class="co">// そのまま関数solveに渡してreturn</span>
        <span class="cf">return</span> solve( n ) ;
    <span class="cf">else</span> <span class="co">// 引数が負数の場合</span>
        <span class="co">// 絶対値を関数solveに渡して負数にしてreturn</span>
        <span class="cf">return</span> - solve( -n ) ;
}</code></pre></div>
<p>nが負数の場合の絶対値は-nで得られる。その場合、関数<code>solve</code>の答えは正数なので負数にする。</p>
<p>あとは関数<code>solve</code>を実装するだけだ。</p>
<p>今回、引数の整数を10進数で表現した場合に2,3,4,5,6,7,8,9が使われている場合は考えないものとする。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// OK</span>
solve(<span class="dv">10111101</span>) ;
<span class="co">// ありえない</span>
solve(<span class="dv">2</span>) ;</code></pre></div>
<p>再帰で問題を解くには再帰的な考え方が必要だ。再帰的な考え方では、問題の一部のみを解き、残りは自分自身に丸投げする。</p>
<p>まずとても簡単な1桁の変換を考えよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">solve(<span class="dv">0</span>) ; <span class="co">// 0</span>
solve(<span class="dv">1</span>) ; <span class="co">// 1</span></code></pre></div>
<p>引数が0か1の場合、単にその値を返すだけだ。関数<code>solve</code>には正数しか渡されないので、負数は考えなくてよい。すると、以下のように書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> solve( <span class="dt">int</span> n )
{
    <span class="cf">if</span> ( n &lt; <span class="dv">1</span> )
        <span class="cf">return</span> n ;
    <span class="cf">else</span>
        <span class="co">// その他の場合</span>
}</code></pre></div>
<p>その他の場合とは、桁数が多い場合だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">solve(<span class="dv">10</span>) ;  <span class="co">// 2</span>
solve(<span class="dv">11</span>) ;  <span class="co">// 3</span>
solve(<span class="dv">110</span>) ; <span class="co">// 4</span>
solve(<span class="dv">111</span>) ; <span class="co">// 5</span></code></pre></div>
<p>関数<code>solve</code>が解決するのは最下位桁だ。110の場合は0で、111の場合は1となる。最も右側の桁のみを扱う。数値から10進数で表記したときの最下位桁を取り出すには、10で割った余りが使える。覚えているだろうか。剰余演算子のoperator %を。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> solve( <span class="dt">int</span> n )
{
    <span class="cf">if</span> ( n &lt; <span class="dv">1</span> )
        <span class="cf">return</span> n ;
    <span class="cf">else</span> <span class="co">// 未完成</span>
        <span class="cf">return</span> n%<span class="dv">10</span> ;
}</code></pre></div>
<p>結果は以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">solve(<span class="dv">10</span>) ;  <span class="co">// 0</span>
solve(<span class="dv">11</span>) ;  <span class="co">// 1</span>
solve(<span class="dv">110</span>) ; <span class="co">// 0</span>
solve(<span class="dv">111</span>) ; <span class="co">// 1</span></code></pre></div>
<p>これで関数<code>solve</code>は最下位桁に完全に対応した。しかしそれ以外の桁はどうすればいいのだろう。</p>
<p>ここで再帰的な考え方が必要だ。関数<code>solve</code>はすでに最下位桁に完全に対応している。ならば次の桁を最下位桁とした数値で関数<code>solve</code>を再帰的に呼び出せばいいのではないか。</p>
<p>以下はsolve(n)が再帰的に呼び出す関数だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">solve(<span class="dv">10</span>) ;  <span class="co">// solve(1)</span>
solve(<span class="dv">11</span>) ;  <span class="co">// solve(1)</span>
solve(<span class="dv">100</span>) ; <span class="co">// solve(10)→solve(1)</span>
solve(<span class="dv">110</span>) ; <span class="co">// solve(11)→solve(1)</span>
solve(<span class="dv">111</span>) ; <span class="co">// solve(11)→solve(1)</span></code></pre></div>
<p>10進数表記された数値から最下位桁を取り除いた数値にするというのは、11を1に, 111を11にする処理だ。これは数値を10で割ればよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dv">10</span>  / <span class="dv">10</span> ; <span class="co">// 1</span>
<span class="dv">11</span>  / <span class="dv">10</span> ; <span class="co">// 1</span>
<span class="dv">100</span> / <span class="dv">10</span> ; <span class="co">// 10</span>
<span class="dv">110</span> / <span class="dv">10</span> ; <span class="co">// 11</span>
<span class="dv">111</span> / <span class="dv">10</span> ; <span class="co">// 11</span></code></pre></div>
<p>10進数表記は桁が一つあがると10倍される。だから10で割れば最下位桁が消える。ところで、我々は計算しようとしているのは2進数だ。2進数では桁が一つあがると2倍される。なので、再帰的に関数<code>solve</code>を呼び出して得られた結果は2倍しなければならない。そして足し合わせる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> solve( <span class="dt">int</span> n )
{
    <span class="co">// 1桁の場合</span>
    <span class="cf">if</span> ( n &lt;= <span class="dv">1</span> )
        <span class="cf">return</span> n ; <span class="co">// 単に返す</span>
    <span class="cf">else</span> <span class="co">// それ以外</span>
        <span class="cf">return</span>
            <span class="co">// 最下位桁の計算</span>
            n%<span class="dv">2</span>
            <span class="co">// 残りの桁を丸投げする</span>
            <span class="co">// 次の桁なので2倍する</span>
            + <span class="dv">2</span> * solve( n/<span class="dv">10</span> ) ;
}</code></pre></div>
<p>冗長なコメントを除いて短くすると以下の通り</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> solve( <span class="dt">int</span> n )
{
    <span class="cf">if</span> ( n &lt;= <span class="dv">1</span> )
        <span class="cf">return</span> n ;
    <span class="cf">else</span>
        <span class="cf">return</span> n%<span class="dv">2</span> + <span class="dv">2</span> * solve( n/<span class="dv">10</span> ) ;
}</code></pre></div>
<p>再帰ではないループで関数<code>solve</code>を実装するとどうなるのだろうか。</p>
<p>引数の数値が何桁あっても対応できるよう、ループで1桁づつ処理していくのはかわらない。</p>
<p>もういちど2進数の計算を見てみよう。</p>
<p><span class="math display">\[
1010 = 1 \times 2^3 + 0 \times 2^2 + 1 \times 2^1 + 0 \times 2^0 = 1 \times 8 + 0 \times 4 + 1 \times 2 + 0 \times 1
\]</span></p>
<p>1桁目は0で、この値は<span class="math inline">\(0 \times 2^0\)</span>、2桁目は1で、この値は<span class="math inline">\(1 \times 2^1\)</span>になる。</p>
<p>一般に、i桁目の値は<span class="math inline">\(i桁目の数字 \times 2^{i-1}\)</span>になる。</p>
<p>すると解き方としては、各桁の値を計算した和を返せばよい</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> solve( <span class="dt">int</span> n )
{
    <span class="co">// 和</span>
    <span class="dt">int</span> result = <span class="dv">0</span> ;
    <span class="co">// i桁目の数字に乗ずる値</span>
    <span class="dt">int</span> i = <span class="dv">1</span> ;

    <span class="co">// 桁がなくなれば終了</span>
    <span class="cf">while</span> ( n != <span class="dv">0</span> )
    {
        <span class="co">// 現在の桁を計算して足す</span>
        result += n%<span class="dv">10</span> * i ;
        <span class="co">// 次の桁に乗ずる値</span>
        i *= <span class="dv">2</span> ;
        <span class="co">// 桁を一つ減らす</span>
        n /= <span class="dv">10</span> ;
    }

    <span class="cf">return</span> result ;
}</code></pre></div>
<p>再帰を使うコードは、再帰を理解できれば短く簡潔でわかりやすい。ただし、再帰を理解するためにはまず再帰を理解しなければならない。</p>
<p>再帰は万能ではない。そもそも関数とは、別の関数から呼ばれるものだ。関数<code>main</code>だけは特別で、関数<code>main</code>を呼び出すことはできない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    main() ; <span class="co">// エラー</span>
}</code></pre></div>
<p>関数の実行が終了した場合、呼び出し元に処理が戻る。そのために関数は呼び出し元を覚えていなければならない。これには通常<code>スタック</code>とよばれるメモリーを消費する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f() { }            <span class="co">// gに戻る</span>
vopd g() { f() ; }      <span class="co">// mainに戻る </span>
<span class="dt">int</span> main() { g() ; }</code></pre></div>
<p>関数の中の変数も通常<code>スタック</code>に確保される。これもメモリーを消費する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f() { }

<span class="dt">void</span> g()
{
    <span class="dt">int</span> x {} ;
    <span class="bu">std::</span>cin &gt;&gt; x ;
    f() ;   <span class="co">// 関数を呼び出す</span>
    <span class="co">// 関数を呼び出した後に変数を使う</span>
    <span class="bu">std::</span>cout &lt;&lt; x ;
}</code></pre></div>
<p>このコードでは、関数<code>g</code>が変数<code>x</code>を用意し、関数<code>f</code>を呼び出し、処理が戻ったら変数<code>x</code>を使っている。このコードが動くためには、変数<code>x</code>は関数<code>f</code>が実行されている間もスタックメモリーを消費し続けなければならない。</p>
<p>スタックメモリーは有限であるので、以下のような再帰による無限ループは、いつかスタックメモリーを消費し尽して実行が止まるはずだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> hello()
{
    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;hello</span><span class="sc">\n</span><span class="st">&quot;</span> ;
    hello() ;
}

<span class="dt">int</span> main() { hello() ; }</code></pre></div>
<p>しかし、大半の読者の環境ではプログラムの実行が止まらないはずだ。これはコンパイラーの末尾再帰の最適化によるものだ。</p>
<p>末尾再帰とは、関数のすべての条件分岐の末尾が再帰で終わっている再帰のことだ。</p>
<p>例えば以下は階乗を計算する再帰で書かれたループだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> factorial( <span class="dt">int</span> n )
{
    <span class="cf">if</span> ( n &lt; <span class="dv">1</span> )
        <span class="cf">return</span> <span class="dv">0</span> ;
    <span class="cf">else</span> <span class="cf">if</span> ( n == <span class="dv">1</span> )
        <span class="cf">return</span> <span class="dv">1</span> ;
    <span class="cf">else</span>
        <span class="cf">return</span> n * factorial(n<span class="dv">-1</span>) ;
}</code></pre></div>
<p>factorial(n)は<span class="math inline">\(1 \times 2 \times 3 \times ... \times n\)</span>を計算する。</p>
<p>この関数は、引数<code>n</code>が1未満であれば引数が間違っているので0を返す。そうでない場合でnが1であれば1を返す。それ以外の場合、n * factorial(n-1)を返す。</p>
<p>このコードは末尾再帰になっている。末尾再帰は非再帰のループに機械的に変換できる特徴を持っている。例えば以下のように、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> factorial( <span class="dt">int</span> n )
{
    <span class="dt">int</span> temp = n ;

loop :
    <span class="cf">if</span> ( n &lt; <span class="dv">1</span> )
        <span class="cf">return</span> <span class="dv">0</span> ;
    <span class="cf">else</span> <span class="cf">if</span> ( n == <span class="dv">1</span> )
        <span class="cf">return</span> temp * <span class="dv">1</span> ;
    <span class="cf">else</span>
    {
        n = n<span class="dv">-1</span> ;
        temp *= n ;
        <span class="cf">goto</span> loop ;
    }
}</code></pre></div>
<p>関数のすべての条件分岐の末尾が再帰になっているため、機械的に関数呼び出しをgoto文で置き換えることができる。</p>
<p>ただし、プログラミング言語C++の標準規格は、C++の実装に末尾再帰の最適化を義務付けてはいない。そのため、末尾再帰が最適化されるかどうかはC++コンパイラー次第だ。</p>
<p>再帰は強力なループの実現方法で、再帰的な問題を解くのに最適だが、落とし穴もある。</p>
<h1 id="メモリを無限に確保する">メモリを無限に確保する</h1>
<h2 id="これまでのまとめ">これまでのまとめ</h2>
<p>ここまで読み進めてきた読者は、逐次実行、条件分岐、ループに加えて、変数と関数を理解した。これだけの要素を習得したならば、本質的にはプログラミングはほぼできるようになったと言ってよい。ただし、まだできないことがある。動的なメモリ確保だ。</p>
<p>標準入力から0が入力されるまで任意個の整数値を受け取り、小さい値から順に出力するプログラムを実装しよう。以下はそのようなプログラムの実行例だ。</p>
<pre><code>$ make run
100
-100
1
6
3
999
-5000
0
-5000
-100
1
3
6
100
999</code></pre>
<p>0が入力されるまで、1番目に、2番目に小さい値はわからない。そのため、この問題の解決には、入力をすべて保持しておく必要がある。</p>
<p>ここで必要なのは、値をいくらでも保持しておく方法と、値に順番があり、i番目の値を間接的に指定して読み書きできる方法だ。その方法としてC++には標準ライブラリ<code>std::vector</code>がある。</p>
<h2 id="vector">vector</h2>
<p><code>std::vector&lt;T&gt;</code>はT型の値をいくらでも保持できる。<code>T</code>には保持する値の型を指定する。例えばintとかdoubleとかstd::stringだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 整数型intの値を保持するvector</span>
    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; vi ;

    <span class="co">// 浮動小数点数型doubleの値を保持するvector</span>
    ~<span class="bu">std::</span>vector&lt;<span class="dt">double</span>&gt; vd ;

    <span class="co">// 文字列型std::stringの値を保持するvector</span>
    <span class="bu">std::</span>vector&lt;<span class="bu">std::</span>string&gt; vs ;
}</code></pre></div>
<p><code>std::vector&lt;T&gt;</code>というのはそれ自体が型になっている。そしてTには型を指定する。ということは、vector型の値を保持するvectorも書けるということだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 整数型intを保持するvectorを保持するvector</span>
    <span class="bu">std::</span>vector&lt; <span class="bu">std::</span>vector&lt; <span class="dt">int</span> &gt; &gt; vvi ;
}</code></pre></div>
<p>もちろん、上のvectorを保持するvectorも書ける。その場合、<code>std::vector&lt;std::vector&lt;std::vector&lt;int&gt;&gt;&gt;</code>になる。このvectorを保持するvectorも当然書けるが省略する。</p>
<p><code>std::vector</code>型の変数にはメンバー関数<code>push_back</code>を使うことで値を保持できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v  ;

    v.push_back(<span class="dv">1</span>) ;
    v.push_back(<span class="dv">2</span>) ;
    v.push_back(<span class="dv">3</span>) ;
}</code></pre></div>
<p><code>メンバー関数(member function)</code>というのは特別な関数で、詳細はまだ説明しない。ここで覚えておくべきこととしては、メンバー関数は一部の変数に使うことができること、メンバー関数<code>f</code>を変数<code>x</code>に使うには'x.f(...)'のように書くこと、を覚えておこう。</p>
<p><code>std::vector</code>はメモリの続く限りいくらでも値を保持できる。試しに1000個の整数を保持させてみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v ;

    <span class="cf">for</span> ( <span class="dt">int</span> i = <span class="dv">0</span> ; i != <span class="dv">0</span> ; ++i )
    {
        v.push_back( i ) ;
    }
}</code></pre></div>
<p>このプログラムは0から999までの1000個の整数を<code>std::vector</code>に保持させている。</p>
<p><code>std::vector</code>では保持する値のことを要素という。要素は順番を持っている。メンバー関数<code>push_back</code>は最後の要素の次に要素を追加する。最初に要素はない。もしくは0個ある空の状態だと言ってもよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v ;

    <span class="co">// vは空</span>

    <span class="co">// 要素数1、中身は{1}</span>
    v.push_back(<span class="dv">1</span>) ;
    <span class="co">// 要素数2、中身は{1,2}</span>
    v.push_back(<span class="dv">2</span>) ;
    <span class="co">// 要素数3、中身は{1,2,3}</span>
    v.push_back(<span class="dv">3</span>) ;
}</code></pre></div>
<p><code>std::vector</code>はメンバー関数<code>size()</code>で現在の要素数を取得できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v ;

    <span class="co">// 0</span>
    <span class="bu">std::</span>cout &lt;&lt; v.size() ;
    v.push_back(<span class="dv">1</span>) ;
    <span class="co">// 1</span>
    <span class="bu">std::</span>cout &lt;&lt; v.size() ;
    v.push_back(<span class="dv">2</span>) ;
    <span class="co">// 2</span>
    <span class="bu">std::</span>cout &lt;&lt; v.size() ;
}</code></pre></div>
<p>せっかく値を入れたのだから取り出したいものだ。<code>std::vector</code>ではメンバー関数<code>at(i)</code>を使うことで、i番目の要素を取り出すことができる。このiのことを添字、インデックスと呼ぶ。ここで注意してほしいのは、最初の要素は0番目で、次の要素は1番目だということだ。最後の要素は'size()-1'番目になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{

    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v ;

    <span class="cf">for</span> ( <span class="dt">int</span> i = <span class="dv">0</span> ; i != <span class="dv">10</span> ; ++i )
    {
        v.push_back(i) ;
    }

    <span class="co">// vの中身は{0,1,2,3,4,5,6,7,8,9}</span>

    <span class="co">// 0, 0番目の最初の要素</span>
    <span class="bu">std::</span>cout &lt;&lt; v.at(<span class="dv">0</span>) ;
    <span class="co">// 4, 5番目の要素</span>
    <span class="bu">std::</span>cout &lt;&lt; v.at(<span class="dv">5</span>) ;
    <span class="co">// 9, 10番目の最後の要素</span>
    <span class="bu">std::</span>cout &lt;&lt; v.at(<span class="dv">9</span>) ;
}</code></pre></div>
<p>この例ではループを使っている。読者はすでにループについては理解しているはずだ。上のコードが理解できないのであれば、もう一度ループの章に戻って学び直すべきだ。</p>
<p>もし<code>at(i)</code>に要素数を超えるiを渡してしまった場合どうなるのだろうか。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v { } ;
    v.push_back(<span class="dv">0</span>) ;
    <span class="co">// vには0番目の要素しかない</span>
    <span class="co">// 1番目はあやまり</span>
    <span class="bu">std::</span>cout &lt;&lt; v.at(<span class="dv">1</span>) ;
}</code></pre></div>
<p>実行して確かめてみよう。</p>
<pre><code>$ ./program
terminate called after throwing an instance of &#39;std::out_of_range&#39;
  what():  vector::_M_range_check: __n (which is 1) &gt;= this-&gt;size() (which is 1)
Aborted (core dumped)</code></pre>
<p>なにやら恐ろしげなメッセージが表示されるではないか。しかし心配することはない。このメッセージはむしろ嬉しいメッセージだ。変数vに1番目の要素がないことを発見してくれたという実行時のエラーメッセージだ。すでに学んだように、エラーメッセージは恐れるものではない。エラーメッセージは嬉しいものだ。エラーメッセージが出たらありがとう。エラーメッセージがあるおかげでバグの存在がわかる。</p>
<p>このメッセージの本当の意味はいずれ例外やデバッガーを解説する章で説明するとして、vectorの要素数を超える指定をしてはいけないことを肝に銘じておこう。もちろん、-1もダメだ。</p>
<p>メンバー関数<code>at(i)</code>に与える引数<code>i</code>の型は整数型ではあるのだが<code>int</code>型ではない。<code>std::size_t</code>型という特殊な型になる。メンバー関数<code>size</code>も同様に<code>std::size_t</code>型を返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v ;

    <span class="co">// std::size_t型</span>
    <span class="bu">std::</span>size_t size = v.size() ;

    v.push_back(<span class="dv">0</span>) ;

    <span class="co">// std::siz_t型</span>
    <span class="bu">std::</span>size_t index = <span class="dv">0</span> ;
    v.at( index ) ;
}</code></pre></div>
<p>なぜ<code>int</code>型ではダメなのか。その謎は整数の章で明らかになる。ここでは<code>std::size_t</code>型は負数が使えない整数型だということだけ覚えておこう。<code>std::size_t</code>型に-1はない。vectorの要素指定では負数は使えないので、負数が使えない変数を使うのは理にかなっている。</p>
<p>さて、これまでに学んだ知識だけを使って、<code>std::vector</code>のすべての要素を順番通りに出力するコードが書けるはずだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{

    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v ;

    <span class="cf">for</span> ( <span class="dt">int</span> iota = <span class="dv">0</span> ; iota != <span class="dv">10</span> ; ++iota )
    {
        v.push_back(iota) ;
    }

    <span class="cf">for</span> ( <span class="bu">std::</span>size_t index = <span class="dv">0</span> ; index != v.size() ; ++index )
    {
        <span class="bu">std::</span>cout &lt;&lt; v.at(index) &lt;&lt; <span class="st">&quot; &quot;</span>s ;
    }
}</code></pre></div>
<p>このコードが書けるということは、もう標準入力から0が入力されるまで任意個の値を受け取り、入力された順番で出力するプログラムも書けるということだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> input()
{
    <span class="dt">int</span> x{} ;
    <span class="bu">std::</span>cin &gt;&gt; x ;
    <span class="cf">return</span> x ;
}
<span class="dt">int</span> main()
{
    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v ;
    <span class="dt">int</span> x { } ;

    <span class="co">// 入力</span>
    <span class="cf">while</span> ( ( x = input() ) != <span class="dv">0</span> )
    {
        v.push_back( x ) ;
    }

    <span class="co">// 出力</span>
    <span class="cf">for</span> ( <span class="bu">std::</span>size_t index = <span class="dv">0</span> ; index != v.size() ; ++index )
    {
        <span class="bu">std::</span>cout &lt;&lt; v.at(index) &lt;&lt; <span class="st">&quot; &quot;</span>s ;
    }
}</code></pre></div>
<p>入力された順番に出力できるということは、その逆順にも出力できるということだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="cf">for</span> ( <span class="bu">std::</span>size_t index = v.size()<span class="dv">-1</span> ; index != <span class="dv">0</span> ; --index )
{
    <span class="bu">std::</span>cout &lt;&lt; v.at(index) &lt;&lt; <span class="st">&quot; &quot;</span>s ;
}

<span class="bu">std::</span>cout &lt;&lt; v.at(<span class="dv">0</span>) ;</code></pre></div>
<p>最後に'v.at(0)'を出力しているのは、ループが'i == 0'のときに終了してしまうからだ。つまり最後に出力すべきvector最初の要素である'v.at(0)'が出力されない。</p>
<p><code>std::size_t</code>型は-1が使えないため、このようなコードになってしまう。<code>int</code>型を使えば負数は使えるのだが、<code>int</code>型と<code>std::size_t</code>型の比較は様々な理由で問題がある。その理由は整数の章で深く学ぶことになるだろう。</p>
<p>ところで、問題は入力された整数を小さい順に出力することだった。この問題を考えるために、まずvectorの中に入っている要素から最も小さい整数の場所を探すプログラムを考えよう。</p>
<p>問題を考えるに当たって、いちいち標準入力から入力を取るのも面倒なので、あらかじめvectorに要素をいれておく方法を学ぶ。実は、vectorの要素は以下のように書けば指定することができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 要素{1, 2, 3}</span>
    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = { <span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span> } ;

    <span class="co">// 1</span>
    <span class="kw">auto</span> x = v.at(<span class="dv">0</span>) ;
    <span class="co">// 2</span>
    <span class="kw">auto</span> y = v.at(<span class="dv">1</span>) ;
    <span class="co">// 3</span>
    <span class="kw">auto</span> z = v.at(<span class="dv">2</span>) ;
}</code></pre></div>
<p>この例では、1, 2, 3の整数が書かれた順番であらかじめvectorの要素として入った状態になる。</p>
<p>さて、以下のような要素のvectorから最も小さい整数を探すプログラムを考えよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = { <span class="dv">8</span>, <span class="dv">3</span>, <span class="dv">7</span>, <span class="dv">4</span>, <span class="dv">2</span>, <span class="dv">9</span>, <span class="dv">3</span> } ;</code></pre></div>
<p>これを見ると、最も小さい整数は4番目(最初の要素は0番目なので4番目)にある2だ。ではどうやって探すのだろうか。</p>
<p>解決方法としては先頭から末尾まで要素を一つづつ比較して、最も小さい要素を見つけ出す。まず0番目の8が最も小さいと仮定する。現在わかっている中で最も小さい要素のインデックスを記録するために変数minを作っておこう</p>
<pre><code>min = 0
8 3 7 4 2 9 3
^</code></pre>
<p>次に1番目の3とmin番目を比較する。1番目の方が小さいので変数minに1を代入する。</p>
<pre><code>min = 1
8 3 7 4 2 9 3
  ^</code></pre>
<p>2番目の7とmin番目を比較するとまだ1番目のほうが小さい。3番目の4と比較してもまだmin番目の方が小さい。</p>
<p>4番目の2とmin番目を比較すると、4番目の方が小さい。変数minに4を代入しよう。</p>
<pre><code>min = 4
8 3 7 4 2 9 3
        ^</code></pre>
<p>5番目と6番目もmin番目より大きいので、これで変数minに代入された4番目の要素が最も小さいことがわかる。</p>
<p>vectorの変数をv、要素数をsizeとする。変数minには現在わかっている中で最も小さい要素へのインデックスが代入される。</p>
<ol style="list-style-type: decimal">
<li>変数minに0を代入する。</li>
<li>size回のループを実行する</li>
<li>変数indexに0からsize-1までの整数を代入する</li>
<li>'v.at(index) &lt; v.at(min)'ならばmin = index</li>
</ol>
<p>さっそく書いてみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// vecotrの変数をv</span>
    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = { <span class="dv">8</span>, <span class="dv">3</span>, <span class="dv">7</span>, <span class="dv">4</span>, <span class="dv">2</span>, <span class="dv">9</span>, <span class="dv">3</span> } ;
    <span class="co">// 要素数をsizeとする</span>
    <span class="bu">std::</span>size_t size = v.size() ;

    <span class="co">// 変数minに0を代入する</span>
    <span class="bu">std::</span>size_t min = <span class="dv">0</span> ;

    <span class="co">// size回のループを実行する</span>
    <span class="co">// 変数iに0からsize-1までの整数を代入する</span>
    <span class="cf">for</span> ( <span class="bu">std::</span>size_t index = <span class="dv">1</span> ; index != size ; ++index )
    {
        <span class="co">// &#39;v.at(index) &lt; v.at(min)&#39;ならばmin = index</span>
        <span class="cf">if</span> ( v.at(index) &lt; v.at(min) )
            min = index ;
    }

    <span class="co">// 一番小さい値を出力</span>
    <span class="bu">std::</span>cout &lt;&lt; v.at(min) ;
}</code></pre></div>
<p>うまくいった。</p>
<p>ところで、最終的に解きたい問題とは、vectorのすべての要素を小さい順に出力するということだ。すると、もっと小さい要素を出力した次に、2番目に小さい要素、3番目に小さい要素・・・と出力していく必要がある。</p>
<p>2番目に小さい要素を見つけるためには、1番目に小さい要素を探さなければよい。そこで、発見した最も小さい要素と先頭の要素を交換してしまい、先頭は無視して最も小さい要素を探すことを繰り返すと実現できる。</p>
<p>例えば以下のような要素があるとして、</p>
<pre><code>8 3 7 4 2 9 3
        ^</code></pre>
<p>最も小さい要素である4番目の2と0番目の8を交換する。</p>
<pre><code>2 3 7 4 8 9 3
^       ^
+-------+</code></pre>
<p>そして、0番目は無視して最も小さい要素を探す。</p>
<pre><code>3 7 4 8 9 3
^</code></pre>
<p>この場合、最も小さいのは0番目と5番目の3だ。どちらも同じだが今回は0番目を選ぶ。もともと0番目にあるので0番目と0番目を交換した結果は変わらない。</p>
<p>そして、新しい0番目は無視して最も小さい要素を探す。</p>
<pre><code>7 4 8 9 3
        ^</code></pre>
<p>こんどは4番目の3だ。これも先頭と交換する</p>
<pre><code>3 4 8 9 7
^       ^
+-------+</code></pre>
<p>これを繰り返していけば、小さい順に要素を探していくことができる。</p>
<p>この処理を行うコードを考えるために、先ほどと似たようなコードを見てみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = { <span class="dv">8</span>, <span class="dv">3</span>, <span class="dv">7</span>, <span class="dv">4</span>, <span class="dv">2</span>, <span class="dv">9</span>, <span class="dv">3</span> } ;
    <span class="bu">std::</span>size_t size = v.size() ;

    <span class="co">// この部分を繰り返す？ </span>
    { <span class="co">// これ全体がひとつのブロック文</span>
        <span class="bu">std::</span>size_t min = <span class="dv">0</span> ;

        <span class="cf">for</span> ( <span class="bu">std::</span>size_t index = <span class="dv">1</span> ; index != size ; ++index )
        {
            <span class="cf">if</span> ( v.at(index) &lt; v.at(min) )
                min = index ;
        }

        <span class="co">// 出力</span>
        <span class="bu">std::</span>cout &lt;&lt; v.at(min) &lt;&lt; <span class="st">&quot; &quot;</span>s ;

        <span class="co">// 先頭と交換</span>
    }
}</code></pre></div>
<p>このコードはそのまま使えない。今回考えた方法では、先頭が一つづつずれていく。そのために、最も小さい要素を探すループを、更にループさせる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 現在の先頭</span>
<span class="cf">for</span> ( <span class="bu">std::</span>size_t head = <span class="dv">0</span> ; head != size ; ++head )
{
    <span class="co">// 現在の先頭であるmin番目を仮の最小の要素とみなすのでhead</span>
    <span class="bu">std::</span>size_t min = head ;    
    <span class="co">// 現在の先頭の次の要素から探すのでhead + 1</span>
    <span class="cf">for</span> ( <span class="bu">std::</span>size_t index = head + <span class="dv">1</span> ; index != size ; ++index )
    {
        <span class="cf">if</span> ( v.at(index) &lt; v.at(min)
            min = index ;
    }

    <span class="bu">std::</span>cout &lt;&lt; v.at(min) &lt;&lt; <span class="st">&quot; &quot;</span>s ;

    <span class="co">// 先頭と交換</span>
}</code></pre></div>
<p>次に先頭(0番目)と現在見つけた最小の要素(min番目)を交換する方法を考えよう。</p>
<p>vectorのn番目の要素の値をxに変更するには、単に<code>v.at(n) = x</code>と書けばよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;

    v.at(<span class="dv">0</span>) = <span class="dv">4</span> ;
    <span class="co">// vは{4,2,3}</span>
}</code></pre></div>
<p>すると、vectorのi番目の要素にj番目の要素値を入れるには'v.at(i) = v.at(j)'と書く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;
    v.at(<span class="dv">0</span>) = v.at(<span class="dv">2</span>) ;
    <span class="co">// vは{3,2,3}</span>
}</code></pre></div>
<p>変数と全く同じだ。</p>
<p>しかし、変数aに変数bの値を代入すると、変数aの元の値は消えてしまう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> a = <span class="dv">1</span> ;
    <span class="dt">int</span> b = <span class="dv">2</span> ;

    <span class="co">// aの元の値は上書きされる</span>
    a = b ;
    <span class="co">// a == 2</span>
    b = a ;
    <span class="co">// b == 2</span>
}</code></pre></div>
<p>変数a, bの値を交換するためには、変数への代入の前に、別の変数に値を一時退避しておく必要がある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> a = <span class="dv">1</span> ;
    <span class="dt">int</span> b = <span class="dv">2</span> ;

    <span class="co">// 退避</span>
    <span class="kw">auto</span> temp = a ;

    a = b ;
    b = temp ;

    <span class="co">// a == 2</span>
    <span class="co">// b == 1</span>
}</code></pre></div>
<p>さて、これで問題を解く準備は全て整った。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = { <span class="dv">8</span>, <span class="dv">3</span>, <span class="dv">7</span>, <span class="dv">4</span>, <span class="dv">2</span>, <span class="dv">9</span>, <span class="dv">3</span> } ;
    <span class="bu">std::</span>size_t size = v.size() ;
   
    <span class="co">// 先頭をずらすループ </span>
    <span class="cf">for</span> ( <span class="bu">std::</span>size_t head = <span class="dv">0</span> ; head != size ; ++head )
    {
        <span class="bu">std::</span>size_t min = head ;
        <span class="co">// 現在の要素の範囲から最小値を見つけるループ</span>
        <span class="cf">for</span> ( <span class="bu">std::</span>size_t index = head<span class="dv">+1</span> ; index != size ; ++index )
        {
            <span class="cf">if</span> ( v.at(index) &lt; v.at(min) )
                min = index ;
        }
        <span class="co">// 出力</span>
        <span class="bu">std::</span>cout &lt;&lt; v.at(min) &lt;&lt; <span class="st">&quot; &quot;</span>s ;

        <span class="co">// 最小値を先頭と交換</span>
        <span class="kw">auto</span> temp = v.at(head) ;
        v.at(head) = v.at(min) ;
        v.at(min) = temp ;
    }

    <span class="co">// 実行した後</span>
}</code></pre></div>
<p>ところで、このプログラムの「実行した後」地点でのvectorの中身はどうなっているだろうか。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = { <span class="dv">8</span>,<span class="dv">3</span>,<span class="dv">7</span>,<span class="dv">4</span>,<span class="dv">2</span>,<span class="dv">9</span>,<span class="dv">3</span> } ;

    <span class="co">// 上と同じコードなので省略</span>

    <span class="co">// 実行した後</span>
    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
    
    <span class="cf">for</span> ( <span class="bu">std::</span>size_t index = <span class="dv">0</span>, size = v.size() ; index != size ; ++index )
    {
        <span class="bu">std::</span>cout &lt;&lt; v.at(index) &lt;&lt; <span class="st">&quot; &quot;</span>s ;
    }
}</code></pre></div>
<p>これを実行すると以下のようになる。</p>
<pre><code>$ make run
2 3 3 4 7 8 9
2 3 3 4 7 8 9</code></pre>
<p>なんとvectorの要素も小さい順に並んでいる。この状態のことを、ソートされているという。ループの中で最も小さい値を出力していく代わりに、まずソートして先頭から値を出力してもよいということだ。</p>
<p>ソートには様々な方法があるが、今回使ったのは選択ソート(selection sort)というアルゴリズムだ。</p>
<p>vectorを使う方法には、イテレーターというもっと便利な方法があるが、それはイテレーターの章で説明する。</p>
<h1 id="デバッグprintfデバッグ">デバッグ：printfデバッグ</h1>
<p>ループと多数の要素の集合を扱えるようになったので、読者はもう相当複雑な処理をするプログラムでも書けるようになった。処理が複雑になってくると増えるのがバグだ。</p>
<p>この章では、伝統ある<code>printfデバッグ</code>を紹介する。</p>
<p><code>printfデバッグ</code>とは、プログラムの実行中に知りたい情報を出力することだ。<code>printf</code>とはC言語の伝統ある出力用のライブラリに由来する名前だが、本書ではiostreamを使う。</p>
<h2 id="実践例">実践例</h2>
<p>例えば前章で実装したようにvectorの要素を選択ソートでソートしたいとする。</p>
<p>選択ソートとは、要素の集合の中から0番目に来るべき要素の場所を探し、0番目の要素と交換し、1番目に来るべき要素の場所を探し、1番目の要素と交換し・・・を要素の数だけ繰り返すことによって要素全体をソートする方法だ。</p>
<p>以下のように書いたとする。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = { <span class="dv">3</span>,<span class="dv">8</span>,<span class="dv">2</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">9</span>,<span class="dv">4</span>,<span class="dv">1</span>,<span class="dv">7</span> } ;
    <span class="kw">auto</span> size = v.size() ;

    <span class="cf">for</span> ( <span class="bu">std::</span>size_t head = <span class="dv">0</span> ; head != size ; ++head )
    {
        <span class="kw">auto</span> min = head ;
        <span class="cf">for</span> ( <span class="bu">std::</span>size_t index = head<span class="dv">+1</span> ; index != size ; ++index )
        {
            <span class="cf">if</span> ( v.at(index) &lt; v.at(min) )
                min = index ;
        }
        
        <span class="kw">auto</span> temp = v.at(head) ;
        v.at(head) = v.at(min) ;
        v.at(min) = v.at(head) ;
    }

    <span class="cf">for</span> ( <span class="bu">std::</span>size_t i = <span class="dv">0</span> ; i != size ; ++i )
    {
        <span class="bu">std::</span>cout &lt;&lt; v.at(i) &lt;&lt; <span class="st">&quot; &quot;</span>s ;
    }
}</code></pre></div>
<p>早速実行してみよう。</p>
<pre><code>$ make run
1 1 1 1 1 1 1 1 7</code></pre>
<p>コンパイルはできるが、なぜかうまく動かない。コードのどこかが間違っているのはわかる。しかしどこが間違っているのかはわからない。さっそく<code>printfデバッグ</code>により問題のある箇所を特定してみよう。</p>
<p><code>printfデバッグ</code>を行うには、まずコード中の間違っていそうな箇所にアタリをつける必要がある。</p>
<p>問題がどこにあるかわからないが、ループのどこかで間違っていそうだ。一番外側のループにアタリをつけよう。ループが実行されるごとに変数vの中身を表示してみる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="cf">for</span> ( <span class="bu">std::</span>size_t head = <span class="dv">0</span> ; head != size ; ++head )
{
    <span class="co">// printfデバッグ</span>
        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;debug: head = &quot;</span>s &lt;&lt; head &lt;&lt; <span class="st">&quot;, v = { &quot;</span>s;
        <span class="cf">for</span> ( <span class="bu">std::</span>size_t i = <span class="dv">0</span> ; i != v.size() ; ++i )
        {
            <span class="bu">std::</span>cout &lt;&lt; v.at(i) &lt;&lt; <span class="st">&quot; &quot;</span>s ;
        }
        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;}</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
    <span class="co">// printfデバッグ</span></code></pre></div>
<p>そして実行した結果が以下だ。</p>
<pre><code>$ make run
debug: v = { 3, 8, 2, 5, 6, 9, 4, 1, 7, }
debug: v = { 1, 8, 2, 5, 6, 9, 4, 1, 7, }
debug: v = { 1, 1, 2, 5, 6, 9, 4, 1, 7, }
debug: v = { 1, 1, 1, 5, 6, 9, 4, 1, 7, }
debug: v = { 1, 1, 1, 1, 6, 9, 4, 1, 7, }
debug: v = { 1, 1, 1, 1, 1, 9, 4, 1, 7, }
debug: v = { 1, 1, 1, 1, 1, 1, 4, 1, 7, }
debug: v = { 1, 1, 1, 1, 1, 1, 1, 1, 7, }
debug: v = { 1, 1, 1, 1, 1, 1, 1, 1, 7, }
1 1 1 1 1 1 1 1 7 </code></pre>
<p>何故か1が増えている。明らかにおかしい。しかしまだ問題の特定にまでは至らない。</p>
<p>内側のループにも<code>printfデバッグ</code>を追加してみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> min = head ;
<span class="cf">for</span> ( <span class="bu">std::</span>size_t index = head<span class="dv">+1</span> ; index != size ; ++index )
{
    <span class="co">// printfデバッグ</span>
        <span class="bu">std::</span>cout &lt;&lt; v.at(index) &lt;&lt; <span class="st">&quot;, &quot;</span>s ;
    <span class="co">// printfデバッグ</span>

    <span class="cf">if</span> ( v.at(index) &lt; v.at(min) )
        min = index ;
}
<span class="co">// printfデバッグ</span>
    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
<span class="co">// printfデバッグ</span></code></pre></div>
<p>そして実行する。</p>
<pre><code>debug: v = { 3, 8, 2, 5, 6, 9, 4, 1, 7, }
8, 2, 5, 6, 9, 4, 1, 7, 
debug: v = { 1, 8, 2, 5, 6, 9, 4, 1, 7, }
2, 5, 6, 9, 4, 1, 7, 
debug: v = { 1, 1, 2, 5, 6, 9, 4, 1, 7, }
5, 6, 9, 4, 1, 7, 
debug: v = { 1, 1, 1, 5, 6, 9, 4, 1, 7, }
6, 9, 4, 1, 7, 
debug: v = { 1, 1, 1, 1, 6, 9, 4, 1, 7, }
9, 4, 1, 7, 
debug: v = { 1, 1, 1, 1, 1, 9, 4, 1, 7, }
4, 1, 7, 
debug: v = { 1, 1, 1, 1, 1, 1, 4, 1, 7, }
1, 7, 
debug: v = { 1, 1, 1, 1, 1, 1, 1, 1, 7, }
7, 
debug: v = { 1, 1, 1, 1, 1, 1, 1, 1, 7, }

1 1 1 1 1 1 1 1 7 </code></pre>
<p>あまりいい情報は得られないようだ。問題はここではないらしい。</p>
<p>ひょっとしたら大小比較が間違っているのかもしれない。確かめてみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="cf">for</span> ( <span class="bu">std::</span>size_t index = head<span class="dv">+1</span> ; index != size ; ++index )
{

    <span class="cf">if</span> ( v.at(index) &lt; v.at(min) )
    {
        <span class="bu">std::</span>cout &lt;&lt; v.at(index) &lt;&lt; <span class="st">&quot; &lt; &quot;</span>s &lt;&lt; v.at(min) &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
        min = index ;
    }
    <span class="cf">else</span>
    {
        <span class="bu">std::</span>cout &lt;&lt; v.at(index) &lt;&lt; <span class="st">&quot; &gt;= &quot;</span>s &lt;&lt; v.at(min) &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
    }
}</code></pre></div>
<p>実行結果は長いので一部だけ記載しておく。</p>
<pre><code>debug: v = { 3, 8, 2, 5, 6, 9, 4, 1, 7, }
8 &gt;= 3
2 &lt; 3
5 &gt;= 2
6 &gt;= 2
9 &gt;= 2
4 &gt;= 2
1 &lt; 2
7 &gt;= 1

debug: v = { 1, 8, 2, 5, 6, 9, 4, 1, 7, }
2 &lt; 8
5 &gt;= 2
6 &gt;= 2
9 &gt;= 2
4 &gt;= 2
1 &lt; 2
7 &gt;= 1</code></pre>
<p>大小比較も問題ないようだ。では最終的に見つけた最も小さい値は、本当に最も小さい値だろうか。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 最小値を探すループ</span>
<span class="cf">for</span> ( <span class="bu">std::</span>size_t index = head<span class="dv">+1</span> ; index != size ; ++index )
{
    <span class="co">// より小さい値があればそれを現在の最小値とする</span>
    <span class="cf">if</span> ( v.at(index) &lt; v.at(min) )
        min = index ;
}

<span class="co">// printfデバッグ</span>
    <span class="bu">std::</span>cout &lt;&lt; v.at(min) &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
<span class="co">// printfデバッグ </span></code></pre></div>
<pre><code>debug: v = { 3, 8, 2, 5, 6, 9, 4, 1, 7, }
1
debug: v = { 1, 8, 2, 5, 6, 9, 4, 1, 7, }
1
debug: v = { 1, 1, 2, 5, 6, 9, 4, 1, 7, }
1
debug: v = { 1, 1, 1, 5, 6, 9, 4, 1, 7, }
1
debug: v = { 1, 1, 1, 1, 6, 9, 4, 1, 7, }
1
debug: v = { 1, 1, 1, 1, 1, 9, 4, 1, 7, }
1
debug: v = { 1, 1, 1, 1, 1, 1, 4, 1, 7, }
1
debug: v = { 1, 1, 1, 1, 1, 1, 1, 1, 7, }
1
debug: v = { 1, 1, 1, 1, 1, 1, 1, 1, 7, }
7
1 1 1 1 1 1 1 1 7 </code></pre>
<p>見つけた値は最も小さいようだ。しかし毎回1になる。1が残っているのだから当然だが、なぜ残っているのだろう。</p>
<p>ひょっとしたら要素の交換が間違っているのかもしれない。<code>printfデバッグ</code>してみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// printfデバッグ </span>
    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;debug before: &quot;</span>s &lt;&lt;  v.at(head) &lt;&lt; <span class="st">&quot;,  &quot;</span> &lt;&lt; v.at(min) &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
<span class="co">// printfデバッグ</span>

v.at(head) = v.at(min) ;
v.at(min) = v.at(head) ;

<span class="co">// printfデバッグ</span>
    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;debug after : &quot;</span>s &lt;&lt; v.at(head) &lt;&lt; <span class="st">&quot;, &quot;</span> &lt;&lt; v.at(min) &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
<span class="co">// printfデバッグ</span></code></pre></div>
<p>&quot;debug before:&quot;は交換前、&quot;debug after:&quot;は交換後の2つの要素の値だ。</p>
<p>以下は実行結果の一部だ。</p>
<pre><code>debug: v = { 3, 8, 2, 5, 6, 9, 4, 1, 7, }
debug before: 3,  1
debug after : 1, 1
debug: v = { 1, 8, 2, 5, 6, 9, 4, 1, 7, }
debug before: 8,  1
debug after : 1, 1
debug: v = { 1, 1, 2, 5, 6, 9, 4, 1, 7, }
debug before: 2,  1
debug after : 1, 1
debug: v = { 1, 1, 1, 5, 6, 9, 4, 1, 7, }</code></pre>
<p>これをみると、要素の値の交換が正しく行われていないことがわかる。</p>
<p>問題の場所がわかったので、早速コードを見てみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">v.at(head) = v.at(min) ;
v.at(min) = v.at(head) ;</code></pre></div>
<p>これは要するに以下のコードと同じだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> a = <span class="dv">0</span> ;
<span class="dt">int</span> b = <span class="dv">1</span> ;

a = b ; <span class="co">// a = 1</span>
b = a ; <span class="co">// b = 1</span></code></pre></div>
<p>変数a, bの値を交換したい場合、変数aに変数bを代入した後に、変数bに変数aを代入する処理は誤りだ。なぜならば、変数bの代入のときには、変数aの値は変数bの値になってしまっているからだ。</p>
<p>前章で学んだように、こういう場合、別の変数に値を代入して退避させておく。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> a = <span class="dv">0</span> ;
<span class="dt">int</span> b = <span class="dv">1</span> ;

<span class="dt">int</span> temp = a ;
a = b ;
b = temp ;</code></pre></div>
<p>こうして<code>printfデバッグ</code>によって問題が解決した。</p>
<h2 id="stdcerr"><code>std::cerr</code></h2>
<p><code>printfデバッグ</code>として標準出力である<code>std::cout</code>に出力すると、プログラムの通常の標準出力と混ざって見づらくなる。例えば以下のプログラムを見てみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 1 * 2 * 3 * ... * nを計算するプログラム</span>
<span class="dt">int</span> main()
{
    <span class="dt">int</span> n{} ;
    <span class="bu">std::</span>cin &gt;&gt; n ;
    <span class="cf">if</span> ( n &lt; <span class="dv">1</span> )
        <span class="cf">return</span> <span class="dv">-1</span> ;

    <span class="dt">int</span> sum = <span class="dv">1</span> ;  
    <span class="cf">for</span> ( <span class="dt">int</span> i = <span class="dv">2</span> ; i &lt;= n ; ++i )
    {
        sum *= i ;

        <span class="co">// printfデバッグ</span>
            <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;debug: &quot;</span>s &lt;&lt; i &lt;&lt; <span class="st">&quot;, &quot;</span> &lt;&lt; sum &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
        <span class="co">// printfデバッグ</span>
    }

    <span class="bu">std::</span>cout &lt;&lt; sum ;
}</code></pre></div>
<p>この場合、標準エラー出力を使うとプログラムの通常の出力と<code>printfデバッグ</code>用の出力を分けることができる。</p>
<p>標準エラー出力を使うには、<code>std::cout</code>の代わりに<code>std::cerr</code>を使う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 標準出力</span>
    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;standard output</span><span class="sc">\n</span><span class="st">&quot;</span>s ;

    <span class="co">// 標準エラー出力</span>
    <span class="bu">std::</span>cerr &lt;&lt; <span class="st">&quot;standard error output</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
}</code></pre></div>
<p>このプログラムを実行すると一見すべて同じように出力されているように見える。</p>
<pre><code>$ make run
standard output
standard error output</code></pre>
<p>違いはリダイレクトやパイプを使うとわかる。</p>
<pre><code>$ ./program &gt; /dev/null
standard error output
$ ./program | grep error
standard error output </code></pre>
<p>標準出力には&quot;standard output&quot;しか出力されていない。通常のリダイレクトやパイプで扱われるのも標準出力だけだ。そのため、<code>/dev/null</code>にリダイレクトすると標準エラー出力しか見えないし、grepにパイプしても標準出力しか受け取らない。</p>
<p>標準出力と標準エラー出力を別々にリダイレクトする方法もある。</p>
<pre><code>$ ./program &gt; cout.txt 2&gt; cerr.txt</code></pre>
<p>これを実行すると、ファイルcout.txtには&quot;standard output&quot;が、ファイルcerr.txtには&quot;standard error output&quot;が出力されている。</p>
<p>これを使って先程のプログラムを書き直すと以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">
<span class="co">// 1 * 2 * 3 * ... * nを計算するプログラム</span>
<span class="dt">int</span> main()
{
    <span class="dt">int</span> n{} ;
    <span class="bu">std::</span>cin &gt;&gt; n ;
    <span class="cf">if</span> ( n &lt; <span class="dv">1</span> )
        <span class="cf">return</span> <span class="dv">-1</span> ;

    <span class="dt">int</span> sum = <span class="dv">1</span> ;  
    <span class="cf">for</span> ( <span class="dt">int</span> i = <span class="dv">2</span> ; i &lt;= n ; ++i )
    {
        sum *= i ;

        <span class="co">// printfデバッグ</span>
            <span class="co">// 標準エラー出力</span>
            <span class="bu">std::</span>cerr &lt;&lt; <span class="st">&quot;debug: &quot;</span>s &lt;&lt; i &lt;&lt; <span class="st">&quot;, &quot;</span> &lt;&lt; sum &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
        <span class="co">// printfデバッグ</span>
    }
    <span class="co">// 標準出力</span>
    <span class="bu">std::</span>cout &lt;&lt; sum ;
}</code></pre></div>
<h2 id="まとめ">まとめ</h2>
<p><code>printfデバッグ</code>はコード中のどこに問題があるかを絞り込むための方法だ。プログラムに問題が存在し、問題の発生の有無はプログラムの状態を調べることで判断できるが、コード中のどこに問題が存在するかわからない時、<code>printfデバッグ</code>で問題の箇所を絞り込むことができる。</p>
<p><code>printfデバッグ</code>のやり方は以下の通り。</p>
<ol style="list-style-type: decimal">
<li>コード中の間違っていそうな箇所にアタリをつける</li>
<li>プログラムの状態を出力する</li>
<li>出力結果が期待通りかどうかを調べる</li>
</ol>
<p><code>printfデバッグ</code>は原始的だが効果的なデバッグ方法だ。後の章ではデバッガーというより高級でプログラマーらしいデバッグ方法も紹介するが、そのような高級なデバッグ方法が使えない環境でも、<code>printfデバッグ</code>ならば使えることは多い。</p>
<h1 id="整数">整数</h1>
<p>始めに書いておくがこの章はユーモア欠落症患者によって書かれており極めて退屈だ。しかし、整数の詳細はすべてのプログラマーが理解すべきものだ。心して読むとよい。</p>
<h2 id="整数リテラル">整数リテラル</h2>
<p>整数リテラルとは整数の値を直接ソースファイルに記述する機能だ。本書ではここまで何の説明もなくリテラルを使っていた。例えば以下のように。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> a = <span class="dv">123</span> ;
    <span class="dt">int</span> b = <span class="dv">0</span> ;
    <span class="dt">int</span> c = <span class="dv">-123</span> ;
}</code></pre></div>
<p>ここでは、'123', '0'がリテラルだ。'-123'というのは演算子operator -に整数リテラル123を適用したものだ。リテラルは<code>123</code>だけだ。ただしこれは細かい詳細なので今はそれほど気にしなくてもよい。</p>
<h3 id="進数リテラル">10進数リテラル</h3>
<p>10進数リテラルは最も簡単で我々が日常的に使っている数の表記方法と同じものだ。接頭語は何も使わず数字には0,1,2,3,4,5,6,7,8,9が使える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 10進数で123</span>
<span class="dt">int</span> decimal = <span class="dv">123</span> ;</code></pre></div>
<p>ただし、10進数リテラルの先頭を0にしてはならない。これは8進数リテラルになってしまう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 10進数で83</span>
<span class="dt">int</span> octal = <span class="bn">0123</span> ;</code></pre></div>
<h3 id="進数リテラル-1">2進数リテラル</h3>
<p>2進数リテラルは接頭語'0b', '0B'から始まる。数字には0, 1を使うことができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 10進数で5</span>
<span class="dt">int</span> binary = <span class="bn">0b1010</span>

<span class="co">// 0bと0Bは同じ</span>
<span class="dt">int</span> a = <span class="bn">0B1010</span> ;</code></pre></div>
<h3 id="進数リテラル-2">8進数リテラル</h3>
<p>8進数リテラルは接頭語'0'から始まる。数字には0,1,2,3,4,5,6,7を使うことができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 10進数で83</span>
<span class="dt">int</span> octal = <span class="bn">0123</span> ;

<span class="co">// 10進数で342391</span>
<span class="dt">int</span> a = <span class="bn">01234567</span> ;</code></pre></div>
<h3 id="進数リテラル-3">16進数リテラル</h3>
<p>16進数リテラルは接頭語'0x', '0X'から始まる。数字には0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f,A,B,C,D,E,Fが使える。ローマ字の大文字と小文字は意味が同じだ。a,b,c,d,e,fがそれぞれ10,11,12,13,14,15を意味する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 10進数で291</span>
<span class="dt">int</span> hexadecimal = <span class="bn">0x123</span> ;

<span class="co">// 0xと0Xは同じ</span>
<span class="dt">int</span> a = <span class="er">0X123</span> ;

<span class="co">// 10進数で10</span>
<span class="dt">int</span> b = <span class="bn">0xa</span> ;

<span class="co">// 10進数で15</span>
<span class="dt">int</span> c = <span class="bn">0xf</span> ;</code></pre></div>
<h3 id="数値区切り">数値区切り</h3>
<p>長い整数リテラルは読みにくい。例えば<code>10000000</code>と<code>100000000</code>はどちらが大きくて具体的にどのくらいの値なのかがわからない。C++には整数リテラルを読みやすいように区切ることのできる数値区切りという機能がある。整数リテラルはシングルクオート文字(')で区切ることができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> a =   <span class="dv">1000&#39;0000</span> ;
    <span class="dt">int</span> b = <span class="dv">1&#39;0000&#39;0000</span> ;
}</code></pre></div>
<p>区切り幅は何文字でもよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> a = <span class="dv">1&#39;22&#39;333&#39;4444&#39;55555</span> ;
}</code></pre></div>
<p>10進数整数リテラル以外でも使える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> a = <span class="bn">0b10101010&#39;11110000&#39;00001111</span> ;
    <span class="kw">auto</span> b = <span class="bn">07&#39;7&#39;5</span> ;
    <span class="kw">auto</span> c = <span class="bn">0xde&#39;ad&#39;be&#39;ef</span> ;
}</code></pre></div>
<h2 id="整数の仕組み">整数の仕組み</h2>
<h3 id="情報の単位">情報の単位</h3>
<p>0から100までの整数を表現するには101種類の状態を表現できる必要がある。コンピューターはどうやって整数を表現しているのかをここで学ぶ。</p>
<p>情報の最小単位はビット(bit)だ。ビットは2種類の状態を表現できる。たとえばbool型はtrue/falseという2種類の状態を表現できる。</p>
<p>しかし、2種類の状態しか表現できない整数は使いづらい。0もしくは1しか表現できない整数とか、100もしく1000しか表現できない整数は使い物にならない。</p>
<p>また、ビットという単位も扱いづらい。コンピューターは膨大な情報を扱うので、ビットをいくつかまとめたバイト(byte)を単位として情報を扱っている。1バイトが何ビットであるかは環境により異なる。本書では最も普及している1バイトは8ビットを前提にする。</p>
<p>1ビットは2種類の状態を表現できるので、1バイトの中の8ビットは<span class="math inline">\(2^8 = 256\)</span>種類の状態を表現できる。2バイトならば16ビットとなり、<span class="math inline">\(2^8 = 65536\)</span>種類の状態を表現できる。</p>
<h3 id="バイトで表現された整数">1バイトで表現された整数</h3>
<p>整数の表現方法について理解するために、1バイトで表現された整数を考えよう。</p>
<p>1バイトは8ビットであり256種類の状態を表現できる。整数を0から正の方向の数だけ表現したいとすると、0から255までの値を表現できることになる。</p>
<p>その場合、1バイトの整数の中の8ビットはちょうど2進数8桁で表現できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 0</span>
<span class="kw">auto</span> zero = <span class="bn">0b00000000</span> ;
<span class="co">// 255</span>
<span class="kw">auto</span> max  = <span class="bn">0b11111111</span> ;</code></pre></div>
<p>一番左側の桁が最上位桁で、一番右側の桁が最下位桁だ。これを最上位ビット、最下位ビットともいう。</p>
<p>正数だけを表現するならば話は簡単だ。1バイトの整数は0から255までの値を表現できる。これを符号なし整数(unsigned integer)という。</p>
<p>では負数を表現するにはどうしたらいいだろう。正数と負数を両方扱える整数表現のことを、符号付き正数(signed integer)という。1バイトは256種類の状態しか表現できないので、もし-1を表現したい場合、-1から254までの値を扱えることになる。</p>
<p>-1しか扱えないのでは実用的ではないので、負数と正数を同じ種類ぐらい表現したい。256の半分は128だが、1バイトで表現された整数は-128から128までを表現することはできない。0があるからだ。0を含めると、1バイトの整数は最大で-128から127までか、-127から128までを表現できる。どちらかに偏ってしまう。</p>
<p>では実際に1バイトで負数も表現できる正数表現を考えてみよう。</p>
<h4 id="符号ビット">符号ビット</h4>
<p>誰でも思いつきそうな表現方法に、符号ビットがある。これは最上位ビットを符号の有無を管理するフラグとして用いることにより、下位7ビットの値の符号を指定する方法だ。</p>
<p>符号ビット表現では-1と1は以下のように表現できる。</p>
<pre><code>// 1
0b0&#39;0000001
// -1
0b1&#39;0000001</code></pre>
<p>最上位ビットが0であれば正数、1であれば負数だ。</p>
<p>この一見わかりやすい表現方法には問題がある。まず表現できる値の範囲は-127から+127だ。さきほど、1バイトで正負になるべく均等に値を割り振る場合、-128から+127、もしくは-127から+128までを扱えると書いた。しかし符号ビット表現では-127から+127しか扱えない。残りの1はどこにいったのか。</p>
<p>答えはゼロにある。符号ビット表現ではゼロに二通りの表現がある。+0と-0だ。</p>
<pre><code>// +0
0b0&#39;0000000
// -0
0b1&#39;0000000</code></pre>
<p>+0も-0もゼロには違いない。しかし符号ビットが独立して存在しているために、ゼロが2種類ある。</p>
<p>符号ビットは電子回路で実装するには複雑という問題もある。</p>
<h4 id="の補数">1の補数</h4>
<p>1の補数は負数を絶対値を2進数で表したときの各ビットを反転させた値で表現する。たとえば-1は1(0b00000001)の1の補数の0b11111110で表現される。</p>
<pre><code>// -1
0b11111110

// -2
0b11111101</code></pre>
<p>-1と-2を足すと結果は-3だ。この計算を1の補数で行うとどうなるか。</p>
<p>まず1の補数表現による-1と-2を足す。</p>
<pre><code>   11111110
+) 11111101
-----------
 1`11111011</code></pre>
<p>この結果は9ビットになる。この整数は8ビットなので、9ビット目を表現することはできない。ただし1の補数表現の計算では、もし9ビット目が繰り上がった場合は、演算結果に1を足す取り決めがある。</p>
<pre><code>   11111011
+)        1</code></pre>
<p>11111100 <sub>~</sub></p>
<p>1の補数による-3は3の各ビットを反転したものだ。3は0b00000011で、そのビットを反転させたものは0b11111100だ。上の計算結果は-3の1の補数表現になった。</p>
<p>もう一つ例を見てみよう。5と-2を足すと3になる。</p>
<pre><code>   00000101
+) 11111101
-----------
 1`00000010</code></pre>
<p>繰り上がりが発生したので1を足すと</p>
<pre><code>   00000010
+)        1
-----------
   00000011</code></pre>
<p>3になった。</p>
<p>1の補数は引き算も足し算で表現できるので電子回路での実装が符号ビットよりもやや簡単になる。</p>
<p>ただし、1の補数にも問題がある。0の表現だ。0というのは0b00000000だが1の補数では-xはxの各ビット反転ということを適用すると、-0は0b11111111になる。すると、符号ビット表現と同じく、+0と-0が存在することになる。したがって、1の補数8ビットで表現できる範囲は-127から+127になる。</p>
<h4 id="の補数-1">2の補数</h4>
<p>符号ビットと1の補数による負数表現にある問題は、2の補数表現で解決できる。</p>
<p>2の補数表現による負数は1の補数表現の負数に、繰り上がり時に足すべき1を加えた値になる。</p>
<p>-1は1の補数表現では、1(0b00000001)の各ビットを反転させた値になる(0b11111110)。2の補数表現では、1の補数表現に1を加えた値になるので、0b11111111になる。</p>
<p>同様に、-2は0b11111110に、-3は0b11111101になる。</p>
<p>00000011 11111100</p>
<p>2の補数表現の-1と-2を足すと以下のようになる。</p>
<pre><code>   11111111
+) 11111110
-----------
 1&#39;11111101</code></pre>
<p>9ビット目の繰り上がりを無視すると、計算結果は0b11111101になる。これは2の補数表現による-3と同じだ。</p>
<p>5と-2の計算も見てみよう。</p>
<pre><code>   00000101
+) 11111110
-----------
 1&#39;00000011</code></pre>
<p>結果は3(0b00000011)だ。</p>
<p>2の補数表現は引き算も足し算で実装できる上に、ゼロの表現方法は一つで、+0と-0が存在しない。8ビットの2の補数表現された整数の範囲は-128から+127になる。とても便利な負数の表現方法なので殆どのコンピューターで採用されている。</p>
<h2 id="整数型">整数型</h2>
<p>C++には様々な整数型が存在する。C++はCから引き継いだ歴史的な経緯により、整数型の文法がわかりにくくなっている。</p>
<p>基本的には、符号付き整数型と符号なし整数型にわかれている。</p>
<p>符号付き整数型としては、<code>signed char</code>, <code>short int</code>, <code>int</code>, <code>long int</code>, <code>long long int</code>が存在する。符号付き整数型は負数を表現できる。</p>
<p>符号なし整数型としては、<code>unsigned char</code>, <code>unsigned short int</code>, <code>unsigned int</code>, <code>unsigned long int</code>, <code>unsigned long long int</code>が存在する。符号なし整数型はふ数を表現できない。</p>
<h3 id="int型">int型</h3>
<p><code>int型</code>は最も基本となる整数型だ。C++で数値を扱う場合、多くはint型になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> x = <span class="dv">123</span> ;</code></pre></div>
<p>整数リテラルの型は通常はint型になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// int</span>
<span class="kw">auto</span> x = <span class="dv">123</span> ;</code></pre></div>
<p><code>unsigned int型</code>は符号のないint型だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">unsigned</span> <span class="dt">int</span> x = <span class="dv">123</span> ;</code></pre></div>
<p>整数リテラルの末尾にu/Uと書いた場合、unsigned int型になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// int</span>
<span class="kw">auto</span> x = <span class="dv">123</span> ;
<span class="co">// unsigned int</span>
<span class="kw">auto</span> y = <span class="dv">123u</span> ;</code></pre></div>
<p>特殊なルールとして、単に<code>signed</code>と書いた場合、それは<code>int</code>になる。<code>unsigned</code>と書いた場合は、<code>unsigned int</code>になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// int</span>
<span class="dt">signed</span> a = <span class="dv">1</span> ;
<span class="co">// unsigned int</span>
<span class="dt">unsigned</span> b = <span class="dv">1</span> ;</code></pre></div>
<p><code>signed int</code>と書いた場合、<code>int型</code>になる。<code>signed int</code>は<code>int</code>の冗長な書き方だ。</p>
<h3 id="long-int型">long int型</h3>
<p><code>long int型</code>は<code>int型</code>以上の範囲の整数を扱える型だ。具体的な整数型の値の範囲は実装依存だが、<code>long int型</code>は<code>int型</code>の表現できる整数の範囲はすべて表現でき、かつ<code>int型</code>以上の範囲の整数型を表現できるかもしれない型だ。</p>
<p><code>unsigned long int型</code>は符号なしの<code>long int</code>だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">long</span> <span class="dt">int</span> a = <span class="dv">123</span> ;
<span class="dt">unsigned</span> lont <span class="dt">int</span> b = <span class="dv">123</span> ;</code></pre></div>
<p>特殊なルールとして、単に<code>long</code>と書いた場合、それは<code>long int</code>になる。<code>unsigned long</code>と書いた場合、<code>unsigned long int</code>になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// long int</span>
<span class="dt">long</span> a = <span class="dv">1</span> ;
<span class="co">// unsigned long int</span>
<span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">int</span> b = <span class="dv">1</span> ;</code></pre></div>
<p>通常、intを省略して単に<code>long</code>と書くことが多い。</p>
<p>整数リテラルの値が<code>int型</code>で表現できない場合、<code>long型</code>になる。例えば、<code>int型</code>で100億を表現できないが、<code>long型</code>では表現できる実装の場合、以下の変数aは<code>long型</code>になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 100億</span>
<span class="kw">auto</span> a = <span class="dv">100&#39;0000&#39;0000</span> ;</code></pre></div>
<p>整数リテラルの値が<code>long</code>では表現できないが<code>unsigned long</code>では表現できる場合、<code>unsigned long型</code>になる。</p>
<p>整数リテラルの末尾にl/Lと書いた場合、値にかかわらず<code>long型</code>になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// int</span>
<span class="kw">auto</span> a = <span class="dv">123</span> ;
<span class="co">// long</span>
<span class="kw">auto</span> b = <span class="dv">123l</span> ;
<span class="co">// long</span>
<span class="kw">auto</span> c = <span class="dv">123L</span> ;</code></pre></div>
<p>符号なし整数型を意味するu/Uと組み合わせることもできる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// unsigned long</span>
<span class="kw">auto</span> a = <span class="dv">123ul</span> ;
<span class="kw">auto</span> b = <span class="dv">123lu</span> ;</code></pre></div>
<p>順番と大文字小文字の組み合わせは自由だ。</p>
<h3 id="long-long-int型">long long int型</h3>
<p><code>long long int型</code>は<code>long int型</code>以上の範囲の整数を扱える型だ。<code>long</code>と同じく<code>long long</code>は<code>long long int</code>と同じで、<code>unsigned long long int</code>もある。</p>
<pre><code>// long long int
long long a = 1 ;
// unsigned long long int
unsinged long long b = 1 ;</code></pre>
<p>整数リテラルの値が<code>long型</code>でも表現できないときは、<code>long long</code>が使われる。<code>long long</code>でも表現できない場合は<code>unsigned long long</code>が使われる。</p>
<p>整数リテラルの末尾にll/LLと書くと<code>long long int型</code>になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// long long int</span>
<span class="kw">auto</span> a = <span class="dv">123ll</span> ;
<span class="co">// long long int</span>
<span class="kw">auto</span> b = <span class="dv">123LL</span> ;
<span class="co">// unsigned long long int</span>
<span class="kw">auto</span> c = <span class="dv">123ull</span></code></pre></div>
<h3 id="short-int型">short int型</h3>
<p><code>short int型</code>は<code>int型</code>より小さい範囲の値を扱う整数型だ。<code>long</code>, <code>long long</code>と同様に、<code>unsigned short int</code>型もある。単に<code>short</code>と書くと、<code>short int</code>と同じ意味になる。</p>
<p>整数リテラルでは末尾にs/Sと書くと<code>short int型</code>になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// short int</span>
<span class="kw">auto</span> a = <span class="er">123s</span> ;
<span class="co">// short int</span>
<span class="kw">auto</span> b = <span class="er">123S</span> ;
<span class="co">// unsigned short int ;</span>
<span class="kw">auto</span> c = <span class="er">123us</span> ;</code></pre></div>
<h3 id="char型">char型</h3>
<p><code>char型</code>はやや特殊で、<code>char</code>, <code>signed char</code>, <code>unsigned char</code>の三種類の型がある。<code>signed char</code>と<code>char</code>は別物だ。<code>char型</code>は整数型であり、後で説明するように文字型でもある。<code>char型</code>の符号の有無は実装ごとに異なる。</p>
<h2 id="整数型のサイズ">整数型のサイズ</h2>
<p>整数型を含む変数のサイズは、<code>sizeof演算子</code>で確認することができる。sizeof(T)はTに型名や変数名を入れることで、サイズを取得することができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>cout &lt;&lt; <span class="kw">sizeof</span>(<span class="dt">int</span>) &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;

    <span class="dt">int</span> x{} ;
    <span class="bu">std::</span>cout &lt;&lt; <span class="kw">sizeof</span>(x) ;
}</code></pre></div>
<p><code>sizeof演算子</code>は<code>std::size_t型</code>を返す。vectorの章でも出てきたこの型は実装依存の符号なし型であると定義されている。単位はバイトだ。</p>
<p>以下が各種整数型のサイズを出力するプログラムだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> print = []( <span class="bu">std::</span>size_t s )
    { <span class="bu">std::</span>cout &lt;&lt; s &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ; } ;

    print( <span class="kw">sizeof</span>(<span class="dt">char</span>) ) ;
    print( <span class="kw">sizeof</span>(<span class="dt">short</span>) ) ;
    print( <span class="kw">sizeof</span>(<span class="dt">int</span>) ) ;
    print( <span class="kw">sizeof</span>(<span class="dt">long</span>) ) ;
    print( <span class="kw">sizeof</span>(<span class="dt">long</span> <span class="dt">long</span> ) ) ;
}</code></pre></div>
<p>このプログラムを筆者の環境で実行した結果が以下になる。</p>
<pre><code>1
2
4
8
8</code></pre>
<p>どうやら筆者の環境では、charが1バイト、shortが2バイト、intが4バイト、longとlong longが8バイトのようだ。この結果は環境ごとに異なるので読者も自分でsizeof演算子を様々な型に適用して試してほしい。</p>
<h2 id="整数型の表現できる値の範囲">整数型の表現できる値の範囲</h2>
<p>整数型の表現できる値の最小値と最大値は<code>std::numeric_limits&lt;T&gt;</code>で取得できる。最小値は::min()を、最大値は::max()で得られる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">
<span class="dt">int</span> main()
{
    <span class="bu">std::</span>cout
        &lt;&lt; <span class="bu">std::</span>numeric_limits&lt;<span class="dt">int</span>&gt;::min() &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s
        &lt;&lt; <span class="bu">std::</span>numeric_limits&lt;<span class="dt">int</span>&gt;::max() ;
}</code></pre></div>
<p>実行結果</p>
<pre><code>-2147483648
2147483647</code></pre>
<p>どうやら筆者の環境ではint型は−21億4748万3648から21億4748万3647までの範囲の値を表現できるようだ。</p>
<p><code>unsigned int</code>はどうだろうか。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>cout
        &lt;&lt; <span class="bu">std::</span>numeric_limits&lt;<span class="dt">unsigned</span> <span class="dt">int</span>&gt;::min() &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s
        &lt;&lt; <span class="bu">std::</span>numeric_limits&lt;<span class="dt">unsigned</span> <span class="dt">int</span>&gt;::max() ;
}</code></pre></div>
<p>実行結果</p>
<pre><code>0
4294967295</code></pre>
<p>どうやら筆者の環境ではunsigned int型は0から42億9496万7295までの範囲の値を表現できるようだ。sizeof(int)が4バイトであり、1バイトが8ビットの筆者の環境では自然な値だ。符号なしの4バイト整数型は0から<span class="math inline">\(2^{32}-1\)</span>までの範囲の値を表現できる。符号付き4バイト整数型は<span class="math inline">\(-2^{31}\)</span>から<span class="math inline">\(2^{31}-1\)</span>までの範囲の値を表現できる。</p>
<p>整数の最小値を-1したり、最大値を+1した場合、何が起こるのだろうか。</p>
<p>符号なし整数型の場合は簡単だ。最小値-1は最大値になる。最大値+1は最小値になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">unsigned</span> <span class="dt">int</span> min = <span class="bu">std::</span>numeric_limits&lt;<span class="dt">unsigned</span> <span class="dt">int</span>&gt;::min() ;
    <span class="dt">unsigned</span> <span class="dt">int</span> max = <span class="bu">std::</span>numeric_limits&lt;<span class="dt">unsigned</span> <span class="dt">int</span>&gt;::max() ;

    <span class="dt">unsigned</span> <span class="dt">int</span> min_minus_one = min - <span class="dv">1u</span> ;
    <span class="dt">unsigned</span> <span class="dt">int</span> max_plus_one = max + <span class="dv">1u</span> ;

    <span class="bu">std::</span>cout &lt;&lt; min &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s &lt;&lt; max &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s
        &lt;&lt; min_minus_one &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s &lt;&lt; max_plus_one ;
}</code></pre></div>
<p>8ビットの符号なし整数型があるとして、最小値は0b00000000(0)になるが、この値を-1すると0b11111111(255)となり、これは最大値になる。逆に、最大値である0b11111111(255)に+1すると0b00000000(0)となり、これは最小値になる。</p>
<p>これを数学的に厳密に書くと、「符号なし整数は算術モジュロ<span class="math inline">\(2^n\)</span>の法に従う。ただしnは整数を表現する値のビット数である」となる。</p>
<p>符号付き整数型の場合、挙動は定められていない。ただし、一般に普及している2の補数表現の場合は、以下のような挙動になることが多い。</p>
<p>符号付き整数型の最小値を-1すると最大値になり、最大値を+1すると最小値になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
     <span class="dt">int</span> min = <span class="bu">std::</span>numeric_limits&lt; <span class="dt">int</span>&gt;::min() ;
     <span class="dt">int</span> max = <span class="bu">std::</span>numeric_limits&lt; <span class="dt">int</span>&gt;::max() ;

     <span class="dt">int</span> min_minus_one = min - <span class="dv">1</span> ;
     <span class="dt">int</span> max_plus_one = max + <span class="dv">1</span> ;

    <span class="bu">std::</span>cout &lt;&lt; min &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s &lt;&lt; max &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s
        &lt;&lt; min_minus_one &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s &lt;&lt; max_plus_one ;
}</code></pre></div>
<p>これはなぜか。2の補数表現の8ビットの符号付き整数の最小値は0b10000000(-128)だが、これを-1すると0b01111111(127)となり、これは最大値となる。逆に最大値0b01111111(127)を+1すると0b10000000(-128)となり、これは最小値となる。</p>
<h2 id="整数型の変換">整数型の変換</h2>
<p>整数型にはここで紹介しただけでも、様々な型がある。同じ型同士を使ったほうがよい。</p>
<p>以下は型が一致している例だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> a = <span class="dv">123</span> ;
    <span class="dt">long</span> b = <span class="dv">123l</span> ;
    <span class="dt">long</span> <span class="dt">long</span> c = <span class="dv">123ll</span> ;

    <span class="dt">unsigned</span> <span class="dt">int</span> d = <span class="dv">123u</span> ; 
}</code></pre></div>
<p>以下は型が一致していない例だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// intからshort</span>
    <span class="dt">short</span> a = <span class="dv">123</span> ;
    <span class="co">// longからint</span>
    <span class="dt">int</span> b = <span class="dv">123l</span> ;

    <span class="co">// intからunsigned int</span>
    <span class="dt">unsigned</span> <span class="dt">int</span> c = <span class="dv">123</span> ;
    <span class="co">// unsigned intからint</span>
    <span class="dt">int</span> d = <span class="dv">123u</span> ;
}</code></pre></div>
<p>代入や演算で整数型が一致しない場合、整数型の変換が行われる。</p>
<p>整数型の変換で注意すべきこととしては、変換元の値を変換先の型で表現できない場合の挙動だ。</p>
<p>たとえばshort型とint型の表現できる最大値を調べるプログラムを書いてみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;short: &quot;</span>s &lt;&lt; <span class="bu">std::</span>numeric_limits&lt;<span class="dt">short</span>&gt;::max() &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s
        &lt;&lt; <span class="st">&quot;int: &quot;</span>s &lt;&lt; <span class="bu">std::</span>numeric_limits&lt;<span class="dt">int</span>&gt;::max() ;
}</code></pre></div>
<p>これを実行すると筆者の環境では以下のようになる。</p>
<pre><code>short: 32767
int: 2147483647</code></pre>
<p>どうやら筆者の環境ではshort型は約3万、int型は約21億ぐらいの値を表現できるようだ。</p>
<p>では約3万までしか表現できないshort型に4万を代入しようとするとどうなるのか。これは一つ前の整数型の表現できる値の範囲で説明したものと同じことがおこる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">short</span> x = <span class="dv">40000</span> ;
    <span class="bu">std::</span>cout &lt;&lt; x ;
}</code></pre></div>
<p>このプログラムを実行した結果は実装ごとに異なる。例えば筆者の環境では以下のようになる。</p>
<pre><code>-25536</code></pre>
<p>整数型の変換は暗黙的に行われるが、明示的に行うこともできる。明示的な変換には<code>static_cast&lt;T&gt;(e)</code>を使う。<code>static_cast</code>は値eを型Tの値に変換する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> x = <span class="dv">123</span> ;
    <span class="dt">short</span> y = <span class="kw">static_cast</span>&lt;T&gt;(x) ;
}</code></pre></div>
<h1 id="浮動小数点数">浮動小数点数</h1>
<p>浮動小数点数の型には<code>float</code>, <code>double</code>, <code>long double</code>がある。<code>float</code>が最も精度が低く、<code>double</code>はfloatと同等以上の精度を持ち、<code>long double</code>はdoubleと同等以上の精度を持つ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">float</span> f = <span class="fl">1.0</span> ;
<span class="dt">double</span> d = <span class="fl">1.0</span> ;
<span class="dt">long</span> <span class="dt">double</span> ld = <span class="fl">1.0</span> ;</code></pre></div>
<p>以下は浮動小数点数型の変数のサイズを調べるコードだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> print = [](<span class="bu">std::</span>size_t s )
    { <span class="bu">std::</span>cout &lt;&lt; s &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ; } ;

    print( <span class="kw">sizeof</span>(<span class="dt">float</span>) ) ;
    print( <span class="kw">sizeof</span>(<span class="dt">double</span>) ) ;
    print( <span class="kw">sizeof</span>(<span class="dt">long</span> <span class="dt">double</span>) ) ;
}</code></pre></div>
<p>筆者の環境では以下のように出力される。</p>
<pre><code>4
8
16</code></pre>
<p>浮動小数点数は一見整数と同じように扱える上、小数点以下の値も扱える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span> a = <span class="fl">1.23</span> ;
<span class="dt">double</span> b = <span class="fl">0.00001</span> ;</code></pre></div>
<p>浮動小数点数が表現できる最大値は実装依存だが、通常はかなり大きな値を表現できる。</p>
<p>しかし、浮動小数点数は値を正確に表現しているわけではない。例えば以下のコードを実行してみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// １万</span>
    <span class="dt">float</span> a = <span class="fl">10000.0</span> ;
    <span class="co">// １万分の1</span>
    <span class="dt">float</span> b = <span class="fl">0.0001</span> ;

    <span class="co">// １万足す１万分の1</span>
    <span class="dt">float</span> c = a + b ;

    <span class="bu">std::</span>cout &lt;&lt; a &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s &lt;&lt; b &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s &lt;&lt; c ;
}</code></pre></div>
<p>変数aの値は１万、変数bの値は１万分の1だ。変数cの値はa+bで10000.0001となるはずだが結果はどうだろう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dv">10000</span>
<span class="fl">0.0001</span>
<span class="dv">10000</span></code></pre></div>
<p>変数cの値は10000.0001ではない。</p>
<h2 id="浮動小数点数リテラル">浮動小数点数リテラル</h2>
<h2 id="進浮動小数点数リテラル">10進浮動小数点数リテラル</h2>
<p>浮動小数点数リテラルの最も簡単な書き方は10進数で整数部を書き、小数点'.'を書き、続けて小数部を書く。末尾がf/Fならfloat型、末尾がなければdouble型、末尾がl/Lならlong double型だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// float</span>
<span class="kw">auto</span> a = <span class="fl">123.456f</span> ;
<span class="kw">auto</span> b = <span class="fl">123.456F</span> ;

<span class="co">// double</span>
<span class="kw">auto</span> c = <span class="fl">123.456</span> ;

<span class="co">// long double</span>
<span class="kw">auto</span> d = <span class="fl">123.456l</span> ;
<span class="kw">auto</span> e = <span class="fl">123.456L</span> ;</code></pre></div>
<h3 id="進数の仮数と指数による表記">10進数の仮数と指数による表記</h3>
<p><code>123.456</code>という値について考えてみよう。この値は以下のように表現することができる。</p>
<p><span class="math display">\[1.23456 \times 10^{2}\]</span></p>
<p>あるいは以下のように表現することもできる。</p>
<p><span class="math display">\[123456 \times 10^{-3}\]</span></p>
<p>あるいは以下のようにも表現できる。</p>
<p><span class="math display">\[123.456 \times 10^{0}\]</span></p>
<p>一般に、値は以下のように表現できるということだ。</p>
<p><span class="math display">\[a \times 10^{b}\]</span></p>
<p>浮動小数点数リテラルのもう一つの文法として、この<code>a</code>と<code>b</code>を指定するものがある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 値はすべて123.456</span>
<span class="kw">auto</span> a = <span class="fl">1.23456e2</span> ;
<span class="kw">auto</span> b = <span class="fl">123456e-3</span> ;
<span class="kw">auto</span> c = <span class="fl">123.456e0</span> ;
<span class="kw">auto</span> d = <span class="fl">123.456E0</span></code></pre></div>
<p>この文法は、<code>a</code>と<code>b</code>をe/Eで挟むことによって浮動小数点数の値を指定する。</p>
<p>この<code>a</code>を仮数部(fractional part)、bを指数部(exponent part)と言う。仮数のことは他にも、coefficient, significand, mantissaなどと呼ばれたりもする。</p>
<p>そして、指数は底が10になる。</p>
<p>浮動小数点数は、値を正確に表現しているのではなく、仮数と指数の組み合わせで表現している。浮動小数点数が浮動と呼ばれる理由は、指数の存在によって少数点数が浮いているかのように動くからだ。</p>
<p>例えば、仮数と指数がともに符号付き1バイトの整数で表現された2バイトの浮動小数点数があるとする。指数、仮数ともに、-128から127までの範囲の整数を表現できる。この浮動小数点数は10000(1万)も100000000(1億)も1000000000000(1兆)も表現できる。それぞれ、<code>1e4</code>, <code>1e8</code>, '1e12'だ。</p>
<p>しかし、この浮動小数点数では1000100010000(1兆1億1万)を表現できない。なぜならば、この値を正確に表現するには、<code>100010001e4</code>を表現できる必要があるが、仮数は100010001を表現できないからだ。</p>
<p>浮動小数点数は値を必ずしも正確に表現できない。その代わり、とても大きな値や、とても小さな値を表現できる。</p>
<p>浮動小数点数の型を表す末尾のf/F/l/Lは同じように使える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// float</span>
<span class="kw">auto</span> a = <span class="fl">1.0e0f</span> ;
<span class="co">// double</span>
<span class="kw">auto</span> b = <span class="fl">1.0e0</span> ;
<span class="co">// long double</span>
<span class="kw">auto</span> c = <span class="fl">1.0e0l</span> ;</code></pre></div>
<h3 id="進数の仮数と指数による表記-1">16進数の仮数と指数による表記</h3>
<p>浮動小数点数の仮数部と指数部によるリテラルは、16進数で記述することもできる。</p>
<p>文法は、0xからはじめ、16進数の仮数部を書き、e/Eの代わりにp/Pを使い、指数部を10進数で指定する。このときの指数部の底は2になる。</p>
<p>値は</p>
<p><span class="math display">\[仮数 \times 2^{指数}\]</span></p>
<p>になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 5496</span>
<span class="dt">double</span> a = <span class="bn">0xabc</span><span class="fl">.0</span>p0 ;
<span class="co">// 7134</span>
<span class="dt">double</span> b = <span class="bn">0xde</span>.fp5 ;</code></pre></div>
<h2 id="浮動小数点数の表現と特性">浮動小数点数の表現と特性</h2>
<p>浮動小数点数は指数と仮数で表現される。浮動小数点数の表現は様々だが、多くのアーキテクチャーでは国際標準規格のISO/IEC/IEEE 60559:2011が使われている。これは米国電気電子学会の規格IEEE 754-2008と同じ内容になっている。その大本はIntelが立案した規格、IEEE 754-1985だ。一般にはIEEE 754(アイトリプルイー 754)という名称で知られている。</p>
<p>IEEE 754では、浮動小数点数は符号ビット、仮数部、指数部からなる。本書ではIEEE 754のを前提として、浮動小数点数で気をつけるべき特性を説明する。</p>
<h3 id="と-0.0">+0.0と-0.0</h3>
<p>i IEEE 754では符号ビットがあるので、ゼロには2種類ある。正のゼロと負のゼロだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>cout &lt;&lt; <span class="fl">0.0</span> &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s &lt;&lt; <span class="fl">-0.0</span> ;
}</code></pre></div>
<p>+0.0と-0.0の違いを浮動小数点数で表現することはできるが、値を比較すると同じものだとみなされる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// a, bは異なるビットパターンを持つ</span>
    <span class="dt">double</span> a = <span class="fl">+0.0</span> ;
    <span class="dt">double</span> b = <span class="fl">-0.0</span> ;

    <span class="co">// true</span>
    <span class="dt">bool</span> c = a == b ;
}</code></pre></div>
<h3 id="と-無限大">+∞と-∞(無限大)</h3>
<p>IEEE 754の浮動小数点数は正の無限と負の無限を表現できる。</p>
<p>浮動小数点数の値としての無限は、計算の結果として現れるほか、<code>numeric_limits&lt;T&gt;::infinity()</code>を使って取得できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">double</span> a = <span class="bu">std::</span>numeric_limits&lt;<span class="dt">double</span>&gt;::infinity() ;
    <span class="dt">double</span> b = -<span class="bu">std::</span>numeric_limits&lt;<span class="dt">double</span>&gt;::infinity() ;

    <span class="bu">std::</span>cout &lt;&lt; a &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s &lt;&lt; b ;
}</code></pre></div>
<h3 id="nannot-a-number">NaN(Not a Number)</h3>
<p>NaN(Not a Number)は計算結果が未定義の場合を表現する浮動小数点数の特別な値だ。</p>
<p>計算結果が未定義な場合とは、例えばゼロで除算する場合だ。</p>
<p>値としてのNaNは<code>numeric_limits&lt;T&gt;::quiet_NaN()</code>で取得できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">double</span> NaN = <span class="bu">std::</span>numeric_limits&lt;<span class="dt">double</span>&gt;::quiet_NaN() ;
    <span class="bu">std::</span>cout &lt;&lt; NaN ;
}</code></pre></div>
<p>NaNとの比較結果はすべてfalseとなる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">double</span> NaN = <span class="bu">std::</span>numeric_limits&lt;<span class="dt">double</span>&gt;::quiet_NaN() ;

    <span class="co">// すべてfalse</span>
    <span class="dt">bool</span> a = NaN == <span class="fl">0.0</span> ;
    <span class="dt">bool</span> b = NaN != <span class="fl">0.0</span> ;
    <span class="dt">bool</span> c = NaN == NaN ;
    <span class="dt">bool</span> d = NaN != NaN ;
    <span class="dt">bool</span> e = Nan &lt; <span class="fl">0.0</span> ;
}</code></pre></div>
<p>整数であれば、'a == b'がfalesであるならば、'a != b'なのだと仮定してもよいが、こと浮動小数点数の場合、NaNの存在があるために必ずしもそうとは限らない。上の例でわかるように、NaNとの比較はすべてfalseになる。</p>
<h3 id="有効桁数">有効桁数</h3>
<p>浮動小数点数は正確な値のすべての桁数を表現できない。表現できるのは仮数部が何桁を正確に表現できるかに依存している。この有効桁数は、<code>numeric_limits&lt;T&gt;::digits10</code>で取得できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>cout
        &lt;&lt; <span class="st">&quot;float: &quot;</span>s &lt;&lt; <span class="bu">std::</span>numeric_limits&lt;<span class="dt">float</span>&gt;::digits10 &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s
        &lt;&lt; <span class="st">&quot;double: &quot;</span>s &lt;&lt; <span class="bu">std::</span>numeric_limits&lt;<span class="dt">double</span>&gt;::digits10 &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s
        &lt;&lt; <span class="st">&quot;long double: &quot;</span>s &lt;&lt; <span class="bu">std::</span>numeric_limits&lt;<span class="dt">long</span> <span class="dt">double</span>&gt;::digits10 &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
}</code></pre></div>
<p>浮動小数点数型Tの<code>numeric_limits&lt;T&gt;</code>にはもう一つ、max_digits10がある。これは浮動小数点数を10進数表記にして、その10進数表記を浮動小数点数に戻したときに、浮動小数点数としての値を精度が落ちることなく再現できる桁数のことだ。</p>
<p>もうひとつ興味深い値としては、<code>numeric_limits&lt;T&gt;::epsilon()</code>がある。これは浮動小数点数の1と比較可能な最小の値との差だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>cout
        &lt;&lt; <span class="st">&quot;float: &quot;</span>s &lt;&lt; <span class="bu">std::</span>numeric_limits&lt;<span class="dt">float</span>&gt;::digits10 &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s
        &lt;&lt; <span class="st">&quot;double: &quot;</span>s &lt;&lt; <span class="bu">std::</span>numeric_limits&lt;<span class="dt">double</span>&gt;::digits10 &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s
        &lt;&lt; <span class="st">&quot;long double: &quot;</span>s &lt;&lt; <span class="bu">std::</span>numeric_limits&lt;<span class="dt">long</span> <span class="dt">double</span>&gt;::digits10 &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
}</code></pre></div>
<h2 id="浮動小数点数同士の変換">浮動小数点数同士の変換</h2>
<p>浮動小数点数型は相互に変換できる。変換先の浮動小数点数型が変換元の値を完全に表現できるならばその値に、できないのであれば近い値に変換される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">double</span> a = <span class="fl">1.23456789</span> ;

    <span class="co">// 変換</span>
    <span class="dt">float</span> b = a ;
    <span class="co">// 変換</span>
    <span class="dt">long</span> <span class="dt">double</span> c = a ;
}</code></pre></div>
<p>異なる浮動小数点数同士を演算すると、<code>float&lt;double&lt;long doube</code>の順で大きい浮動小数点数型に合わせて変換される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// float</span>
    <span class="kw">auto</span> a = <span class="fl">1.0f</span> + <span class="fl">1.0f</span> ;
    <span class="co">// double</span>
    <span class="kw">auto</span> b = <span class="fl">1.0f</span> + <span class="fl">1.0</span> ;
    <span class="co">// long double</span>
    <span class="kw">auto</span> c = <span class="fl">1.0f</span> + <span class="fl">1.0l</span> ;
}</code></pre></div>
<h2 id="浮動小数点数と整数の変換">浮動小数点数と整数の変換</h2>
<p>浮動小数点数型を整数型に変換すると、小数部が切り捨てられる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">double</span> a = <span class="fl">1.9999</span> ;
    <span class="co">// 1</span>
    <span class="dt">int</span> x = a ;
}</code></pre></div>
<p>変換元の浮動小数点数から小数部を切り捨てた値が変換先の整数型で表現できなかった場合は、何が起こるかわからない。</p>
<p>整数型を浮動小数点数型に変換すると、変換元の整数の値が変換先の浮動小数点数型で正確に表現できる場合はその値に、そうでない場合は表現できる最も近い値になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> a = <span class="dv">1</span> ;
    <span class="co">// 1.0</span>
    <span class="dt">double</span> b = a ;
}</code></pre></div>
<p>浮動小数点数と整数を演算した場合、浮動小数点数型になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// double</span>
    <span class="kw">auto</span> a = <span class="fl">1.0</span> + <span class="dv">1</span> ;
    <span class="kw">auto</span> b = <span class="dv">1</span> + <span class="fl">1.0</span> ;

    <span class="co">// float</span>
    <span class="kw">auto</span> c = <span class="fl">1.0f</span> + <span class="dv">1</span> ;
}</code></pre></div>
<h1 id="名前">名前</h1>
<p>プログラミング言語C++には様々な名前が出てくる。変数、関数、型など、さまざまなものに名前がついている。この章では名前について学ぶ。</p>
<h2 id="キーワード">キーワード</h2>
<p>一部の名前はキーワードとして予約され、特別な意味を持つ。キーワードは名前として使うことができない。</p>
<p>キーワードの一覧は以下の通り。</p>
<pre><code>alignas         alignof     asm         auto        bool            break
case            catch       char        char16_t    char32_t        class
concept         const       constexpr   const_cast  continue        decltype
default         delete      do          double      dynamic_cast    else
enum            explicit    export      extern      false           float
for             friend      goto        if          inline          int
long            mutable     namespace   new         noexcept        nullptr
operator        private     protected   public      register        reinterpret_cast
requires        return      short       signed      sizeof          static
static_assert   static_cast struct      switch      template        this
thread_local    throw       true        try         typedef         typeid
typename        union       unsigned    using       virtual         void
volatile        wchar_t     while</code></pre>
<h2 id="名前に使える文字">名前に使える文字</h2>
<p>名前というのは根本的には識別子と呼ばれる文字列でなりたっている。</p>
<p>C++では識別子にラテンアルファベット小文字、大文字、アラビア数字、アンダースコア、を使うことができる。以下がその文字の一覧だ。</p>
<pre><code>a b c d e f g h i j k l m
n o p q r s t u v w x y z
A B C D E F G H I J K L M
N O P Q R S T U V W X Y Z
0 1 2 3 4 5 6 7 8 9
_</code></pre>
<p>小文字と大文字は区別される。名前<code>a</code>と名前<code>A</code>は別の名前だ。</p>
<p>ただし、名前はアラビア数字で始まってはならない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> <span class="er">123abc</span> = <span class="dv">0</span> ; <span class="co">// エラー</span></code></pre></div>
<p>名前にダブルアンダースコア(<code>__</code>)が含まれているものは予約されているので使ってはならない。ダブルアンダースコアとはアンダースコア文字が2つ連続したものをいう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 使ってはならない</span>
<span class="co">// すべてダブルアンダースコアを含む</span>
<span class="dt">int</span> __ = <span class="dv">0</span> ;
<span class="dt">int</span> a__ = <span class="dv">0</span> ;
<span class="dt">int</span> __a = <span class="dv">0</span> ;</code></pre></div>
<p>アンダースコアに大文字から始まる名前も予約されているので使ってはならない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 使ってはならない</span>
<span class="co">// アンダースコアに大文字から始まる</span>
<span class="dt">int</span> _A = <span class="dv">0</span> ;</code></pre></div>
<p>アンダースコアに小文字から始まる名前もグローバル名前空間で予約されているので使ってはならない。グローバル名前空間についてはこの後説明する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 使ってはならない</span>
<span class="co">// アンダースコアに小文字から始まる</span>
<span class="dt">int</span> _a = <span class="dv">0</span> ;</code></pre></div>
<p>予約されているというのは、C++コンパイラーがその名前をC++の実装のために使うかもしれないということだ。例えばC++コンパイラーは<code>_A</code>という名前を特別な意味を持つものとして使うかもしれないし、その名前の変数や関数をプログラムに追加するかもしれない。</p>
<h2 id="宣言と定義">宣言と定義</h2>
<p>C++では、名前は使う前に宣言しなければならない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> x = <span class="dv">0</span> ; <span class="co">// 宣言</span>
    x = <span class="dv">1</span> ; <span class="co">// 使用</span>
}</code></pre></div>
<p>宣言する前に使うことはできない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// エラー、名前xは宣言されていない。</span>
    x = <span class="dv">1</span> ; 

    <span class="dt">int</span> x = <span class="dv">0</span> ;
}</code></pre></div>
<p>C++では多くの名前は宣言と定義に分かれている。宣言と定義の分離は関数が一番わかりやすい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 関数の宣言</span>
<span class="dt">int</span> plus_one( <span class="dt">int</span> x ) ;

<span class="co">// 関数の定義</span>
inf plus_one( <span class="dt">int</span> x ) <span class="co">// 宣言部分</span>
<span class="co">// 定義部分</span>
<span class="co">// 関数の本体</span>
{
    <span class="cf">return</span> x + <span class="dv">1</span> ;
}</code></pre></div>
<p>関数の定義は宣言をかねる。</p>
<p>宣言は何度でも書くことができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> plus_one( <span class="dt">int</span> x ) ; <span class="co">// 初出</span>
<span class="dt">int</span> plus_one( <span class="dt">int</span> x ) ; <span class="co">// OK</span>
<span class="dt">int</span> plus_one( <span class="dt">int</span> x ) ; <span class="co">// OK</span></code></pre></div>
<p>定義はプログラム中に一度しか書くことができない</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 定義</span>
<span class="dt">int</span> odr() { }

<span class="co">// エラー、定義の重複</span>
<span class="dt">int</span> odr() { }</code></pre></div>
<p>名前を使うのに事前に必要なのは宣言だ。定義は名前を使った後に書いてもよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 宣言</span>
<span class="dt">int</span> plus_one( <span class="dt">int</span> x ) ;

<span class="dt">int</span> main()
{
    plus_one( <span class="dv">1</span> ) ;
}

<span class="co">// 定義</span>
<span class="dt">int</span> plus_one( <span class="dt">int</span> x ) ;
{
    <span class="cf">return</span> x + <span class="dv">1</span> ;
}</code></pre></div>
<p>ほとんどの変数は宣言と定義が同時に行われる。変数でも宣言と定義を分割して行う方法もあるのだが、解説は分割コンパイルの章で行う。</p>
<h2 id="名前空間">名前空間</h2>
<p>本書をここまで読んだ読者は、一部の型名の記述がすこし変なことに気がついているだろう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="bu">std::</span>string a ;
<span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; b ;</code></pre></div>
<p>コロンやアングルブラケットは名前に使える文字ではない。信じられない読者は試してみるとよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// エラー</span>
<span class="dt">int</span> :: = <span class="dv">0</span> ;
<span class="dt">int</span> &lt;<span class="dt">int</span>&gt; = <span class="dv">0</span> ;</code></pre></div>
<p>莫大なエラーが表示されるだろうが、すでに学んだようにとてもいいことだ。コンパイラーが間違いを見つけてくれたのだから。わからないことがあったらどんどんコンパイルエラーを出すとよい。</p>
<p>実は<code>std</code>というのは名前空間(namespace)の名前だ。ダブルコロン(<code>::</code>)は名前空間を指定する文法だ。</p>
<p>名前空間の文法は以下の通り</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> ns {
<span class="co">// コード</span>
}</code></pre></div>
<p>名前空間の中の名前を参照するには<code>::</code>を使う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">ns::name ;</code></pre></div>
<p>名前空間の中には変数も書ける。この変数は関数の内部に限定されたローカル変数とは違い、どの関数からでも参照できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> ns {
    <span class="dt">int</span> name{} ;
}

<span class="dt">int</span> f()
{
    <span class="cf">return</span> ns::name ;
}

<span class="dt">int</span> main()
{
    ns::name = <span class="dv">1</span> ;
}</code></pre></div>
<p>名前空間の中で宣言された名前は、名前空間を指定しなければ使えなくなる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> ns {
    <span class="dt">int</span> f() { <span class="cf">return</span> <span class="dv">0</span> ; }
}

<span class="dt">int</span> main()
{
    ns::f() ;

    f() ; <span class="co">// エラー</span>
}</code></pre></div>
<p>異なる名前空間名の下の名前は別の名前になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> a {
    <span class="dt">int</span> f() { <span class="cf">return</span> <span class="dv">0</span> ; }
}


<span class="kw">namespace</span> b {
    <span class="dt">int</span> f() { <span class="cf">return</span> <span class="dv">1</span> ; }
}

<span class="dt">int</span> main()
{
    a::f() ; <span class="co">// 0</span>
    b::f() ; <span class="co">// 1</span>
}</code></pre></div>
<p>これだけを見ると、名前空間というのはわざわざ名前空間名を指定しなければ使えない面倒な機能に見えるだろう。名前空間の価値は複数人で同じプログラムのソースファイルを編集するときに出てくる。</p>
<p>例えば、アリスとボブがプログラムを共同で開発しているとする。あるプログラムのソースファイル<code>f</code>という名前の関数を書いたとする。ここで、同じプログラムを共同開発している他人も<code>func</code>という名前の関数を書いたらどうなるか。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// アリスの書いた関数f</span>
<span class="dt">int</span> f() { <span class="cf">return</span> <span class="dv">0</span> ; }

<span class="co">// ボブの書いた関数f</span>
<span class="dt">int</span> f() { <span class="cf">return</span> <span class="dv">1</span> ; }</code></pre></div>
<p>すでに宣言と定義で学んだように、このコードはエラーになる。なぜならば、同じ名前に対して定義が2つあるからだ。</p>
<p>名前空間なしでこの問題を解決するためはに、アリスとボブが事前の申し合わせて、名前が衝突しないように調整する必要がある。</p>
<p>しかし名前空間があるC++では、そのような面倒な調整は必要がない。アリスとボブが別の名前空間を使えばいいのだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// アリスの名前空間</span>
<span class="kw">namespace</span> alice {
    <span class="co">// アリスの書いた関数f</span>
    <span class="dt">int</span> f() { <span class="cf">return</span> <span class="dv">0</span> ; }
}

<span class="co">// ボブの名前空間</span>
<span class="kw">namespace</span> bob {
    <span class="co">// ボブの書いた関数f</span>
    <span class="dt">int</span> f() { <span class="cf">return</span> <span class="dv">1</span> ; }
}</code></pre></div>
<p><code>alice::f</code>と<code>bob::f</code>は別の名前なので定義の衝突は起こらない。</p>
<h3 id="グローバル名前空間">グローバル名前空間</h3>
<p>名前空間に包まれていないソースファイルのトップレベルの場所は、実はグローバル名前空間(global name space)という名前のない名前空間で包まれているという扱いになっている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// グローバル名前空間</span>
<span class="dt">int</span> f() { <span class="cf">return</span> <span class="dv">0</span> ; }

<span class="kw">namespace</span> ns {
    <span class="dt">int</span> f() { <span class="cf">return</span> <span class="dv">1</span> ; }
}

<span class="dt">int</span> main()
{
    f() ; <span class="co">// 0</span>
    ns::f() ; <span class="co">// 1</span>
}</code></pre></div>
<p>グローバル名前空間は名前の指定のない単なる<code>::</code>で指定することもできる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> x { } ;

<span class="dt">int</span> main()
{
    x ; <span class="co">// ::xと同じ</span>
    ::x ;
}</code></pre></div>
<p>すでに名前空間の中では変数を宣言できることは学んだ。グローバル名前空間は名前空間なので同じように変数を宣言できる。</p>
<p>main関数はグローバル名前空間に存在しなければならない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// グローバル名前空間</span>
<span class="dt">int</span> main() { }</code></pre></div>
<h3 id="名前空間のネスト">名前空間のネスト</h3>
<p>名前空間の中に名前空間を書くことができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> A { <span class="kw">namespace</span> B { <span class="kw">namespace</span> C {
    <span class="dt">int</span> name {} ;
} } }

<span class="dt">int</span> main()
{
    A::B::C::name = <span class="dv">0</span> ;
}</code></pre></div>
<p>名前空間のネストは省略して書くこともできる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> A::B::C {
    <span class="dt">int</span> name { } ;
}

<span class="dt">int</span> main()
{
    A::B::C::name = <span class="dv">0</span> ;
}</code></pre></div>
<h3 id="名前空間名の別名を宣言する名前空間エイリアス">名前空間名の別名を宣言する名前空間エイリアス</h3>
<p>名前空間名には別名をつけることができる。これを名前空間エイリアスと呼ぶ。</p>
<p>たとえば名前空間名が重複することを恐れるあまり、とても長い名前空間名を付けたライブラリがあるとする。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> very_long_name {
    <span class="dt">int</span> f() { <span class="cf">return</span> <span class="dv">0</span> ; }
}

<span class="dt">int</span> main()
{
    very_long_name::f() ;
}</code></pre></div>
<p>この関数fを使うために毎回<code>very_long_name::f</code>と書くのは面倒だ。こういうときには名前空間エイリアスを使うとよい。名前空間エイリアスは名前空間名の別名を宣言できる。</p>
<pre><code>namespace 別名 = 名前空間名 ;</code></pre>
<p>使い方。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> very_long_name {
    <span class="dt">int</span> f() { <span class="cf">return</span> <span class="dv">0</span> ; }
}

<span class="dt">int</span> main()
{
    <span class="co">// 名前空間エイリアス</span>
    <span class="kw">namespace</span> vln = very_long_name ;
    <span class="co">// vlnはvery_long_nameのエイリアス</span>
    vln::f() ;
}</code></pre></div>
<p>名前空間エイリアスは元の名前空間名と同じように使える。意味も同じだ。</p>
<p>名前空間エイリアスはネストされた名前空間にも使える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> A::B::C {
    <span class="dt">int</span> f() { <span class="cf">return</span> <span class="dv">0</span> ; }
}

<span class="dt">int</span> main()
{
    <span class="kw">namespace</span> D = A::B::C ;
    <span class="co">// DはA::B::Cのエイリアス</span>
    D::f() ;
}</code></pre></div>
<p>名前空間エイリアスを関数の中で宣言すると、その関数の中でだけ有効になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> A { <span class="dt">int</span> x { } ; }

<span class="dt">int</span> f()
{
    <span class="co">// Bの宣言</span>
    <span class="kw">namespace</span> B = A ;
    <span class="co">// OK、Bは宣言されている</span>
    <span class="cf">return</span> B::x ;
}

<span class="dt">int</span> g()
{
    <span class="co">// エラー、Bは宣言されていない</span>
    <span class="cf">return</span> B::x ;
}</code></pre></div>
<p>名前空間エイリアスを名前空間の中で宣言すると、宣言以降の名前空間内で有効になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> ns {
    <span class="kw">namespace</span> A { <span class="dt">int</span> x { } ; }
    <span class="kw">namespace</span> B = A ;

    <span class="co">// OK</span>
    <span class="dt">int</span> f(){ <span class="cf">return</span> B::x ; }
    <span class="co">// OK</span>
    <span class="dt">int</span> g(){ <span class="cf">return</span> B::x ; }

} <span class="co">// end namespace ns</span>

<span class="co">// エラー、Bは宣言されていない</span>
<span class="dt">int</span> h(){ <span class="cf">return</span> B::x ; }</code></pre></div>
<p>グローバル名前空間は名前空間なので、名前空間エイリアスを宣言できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> long_name_is_loooong { } ;
<span class="kw">namespace</span> cat = long_name_is_loooong ;</code></pre></div>
<h3 id="名前空間名の指定を省略するusingディレクティブ">名前空間名の指定を省略するusingディレクティブ</h3>
<p>名前空間は名前の衝突を防ぐ機能だが、名前空間名をわざわざ指定するのは面倒だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// std名前空間のstring</span>
    <span class="bu">std::</span>string s ;
    <span class="co">// std名前空間のvector&lt;int&gt;</span>
    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v ;

    <span class="co">// std名前空間のcout</span>
    <span class="bu">std::</span>cout &lt;&lt; <span class="dv">123</span> ;
}</code></pre></div>
<p>もし自分のソースファイルが<code>string</code>, <code>vector&lt;int&gt;</code>, <code>cout</code>、その他std名前空間で使われる名前を一切使っていない場合、名前の衝突は発生しないことになる。その場合でも名前空間名を指定しなければならないのは面倒だ。</p>
<p>C++では指定した名前空間を省略できる機能が存在する。usingディレクティブだ。</p>
<pre><code>using namespace 名前空間名 ;</code></pre>
<p>これを使えば、先程のコードは以下のように書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> std ;
    <span class="co">// std名前空間のstring</span>
    string s ;
    <span class="co">// std名前空間のvector&lt;int&gt;</span>
    vector&lt;<span class="dt">int</span>&gt; v ;

    <span class="co">// std名前空間のcout</span>
    cout &lt;&lt; <span class="dv">123</span> ;
}</code></pre></div>
<p>では名前が衝突した場合はどうなるのか。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> abc {
    <span class="dt">int</span> f() { <span class="cf">return</span> <span class="dv">0</span> ; }
}

<span class="dt">int</span> f() { <span class="cf">return</span> <span class="dv">1</span> ; }

<span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> std ;

    <span class="co">// エラー、名前が曖昧</span>
    f() ;
}</code></pre></div>
<p>名前<code>f</code>に対してどの名前を使用するのか曖昧になってエラーになる。このエラーを回避するためには、名前空間を直接指定する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> abc {
    <span class="dt">int</span> f() { <span class="cf">return</span> <span class="dv">0</span> ; }
}

<span class="dt">int</span> f() { <span class="cf">return</span> <span class="dv">1</span> ; }

<span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> std ;

    <span class="co">// OK、名前空間abcのf</span>
    abc::f() ;

    <span class="co">// OK、グローバル名前空間のf</span>
    ::f() ;
}</code></pre></div>
<p>usingディレクティブは関数の中だけではなく、名前空間の中にも書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> A {
    <span class="dt">int</span> f(){ <span class="cf">return</span> <span class="dv">0</span> ; }
}

<span class="kw">namespace</span> B {
    <span class="kw">using</span> <span class="kw">namespace</span> A ;
    <span class="dt">int</span> g()
    {
        <span class="co">// OK、A::f</span>
        f() ;
    }
}</code></pre></div>
<p>名前空間のなかにusingディレクティブを書くと、その名前空間の中では指定した名前空間を省略できる。</p>
<p>グローバル名前空間は名前空間なのでusingディレクティブが書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> <span class="kw">namespace</span> std ;</code></pre></div>
<p>ただし、グローバル名前空間の中にusingディレクティブを書くと、それ以降全ての箇所で指定した名前空間の省略ができてしまうので注意が必要だ。</p>
<h3 id="名前空間を指定しなくてもよいinline名前空間">名前空間を指定しなくてもよいinline名前空間</h3>
<p><code>inline名前空間</code>は<code>inline namespace</code>で定義する。</p>
<pre><code>inline namespace name { }</code></pre>
<p>inline名前空間内の名前は名前空間名を指定して使うこともできるし、名前空間を指定せずとも使うことができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">inline</span> <span class="kw">namespace</span> A {
    <span class="dt">int</span> a { } ;
}

<span class="kw">namespace</span> B {
    <span class="dt">int</span> b { } ;
}

<span class="dt">int</span> main()
{
    a = <span class="dv">0</span> ;     <span class="co">// A::a</span>
    A::a = <span class="dv">0</span> ;  <span class="co">// A::a</span>

    b = <span class="dv">0</span> ;     <span class="co">// エラー、名前bは宣言されていない</span>
    B::b = <span class="dv">0</span> ;  <span class="co">// B::b</span>
}</code></pre></div>
<p>読者がinline名前空間を使うことはほとんど無いだろうが、ライブラリのソースファイルを読むときには出てくるだろう。</p>
<h2 id="型名">型名</h2>
<p>型名とは型を表す名前だ。</p>
<p>型名はintやdoubleのように言語組み込みのキーワードを使うこともあれば、独自に作った型名を使うこともある。この独自に作った型名を専門用語ではユーザー定義された型(user-defined type)という。ユーザー定義された型を作る方法は様々だ。具体的に説明するのは本書のだいぶ後の方になるだろう。例としては、<code>std::string</code>や<code>std::vector&lt;T&gt;</code>がある。標準ライブラリによってユーザー定義された型だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 組み込みの型名</span>
<span class="dt">int</span> i = <span class="dv">0</span> ;
<span class="dt">double</span> d = <span class="fl">0.0</span> ;

<span class="co">// ユーザー定義された型名</span>
<span class="bu">std::</span>string s ;
<span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v ;</code></pre></div>
<h3 id="型名の別名を宣言するエイリアス宣言">型名の別名を宣言するエイリアス宣言</h3>
<p>長い名前空間名を書くのが煩わしいように、長い型名を書くのも煩わしい。名前空間名の別名を宣言できるように、型名も別名を宣言できる。</p>
<p>型名の別名を宣言するにはエイリアス宣言を使う。</p>
<pre><code>using 別名 = 型名 ;</code></pre>
<p>使い方。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// エイリアス宣言</span>
    <span class="kw">using</span> Number = <span class="dt">int</span> ;

    <span class="co">// Numberはintの別名</span>
    Number x = <span class="dv">0</span> ;
}</code></pre></div>
<p>型名の別名は型名と同じように使える。意味も同じだ。</p>
<p>歴史的な経緯により、エイリアス宣言による型名の別名のことを、typedef名(typedef name)という。これはtypedef名を宣言する文法が、かつてはtypedefキーワードを使ったものだったからだ。typedefキーワードを使ったtypedef名の宣言方法は、昔のコードによく出てくるので現代でも覚えておく必要はある。</p>
<pre><code>typedef 型名 typedef名 ;</code></pre>
<p>使い方。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// typedef名による型名の宣言</span>
    <span class="kw">typedef</span> <span class="dt">int</span> Number ;

    Number x = <span class="dv">0</span> ;
}</code></pre></div>
<p>これは変数の宣言と同じ文法だ。変数の宣言が以下のような文法で、</p>
<pre><code>型名 変数名 ;</code></pre>
<p>これにtypedefキーワードを使えばtypedef名の宣言になる。</p>
<p>しかしtypedefキーワードによるtypdef名の宣言は罠が多い。例えば熟練のC++プログラマーでも、以下のコードが合法だということに驚くだろう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> <span class="kw">typedef</span> Number ;
    Number x = <span class="dv">0</span> ;
}</code></pre></div>
<p>しかし本書ではまだ教えていない複雑な型名について、このようなコードを書こうとするとコンパイルエラーになることに熟練のC++プログラマーは気がつくはずだ。その理由はとても難しい。</p>
<p>エイリアス宣言にはこのような罠はない。</p>
<h2 id="スコープ">スコープ</h2>
<p>スコープ(scope)というのはやや説明が難しい概念だ。名前空間や関数はスコープを持っている。とてもおざっぱに説明するとカーリブラケット<code>{}</code>で囲まれた範囲がスコープだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> ns
{ <span class="co">// 名前空間スコープの始まり</span>
} <span class="co">// 関数スコープの終わり</span>

<span class="dt">void</span> f()
{ <span class="co">// 関数スコープの始まり</span>

} <span class="co">// 関数スコープの終わり</span></code></pre></div>
<p>これとは別にブロック文のスコープもある。ブロックとは関数の中で複数の文をたばねて一つの文として扱う機能だ。覚えているだろうか。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f()
{ <span class="co">// 関数スコープ</span>

    { <span class="co">// 外側のブロックスコープ</span>
        { <span class="co">// 内側のブロックスコープ</span>
        }
    }
}</code></pre></div>
<p>スコープは<code>{</code>に始まり<code>}</code>に終わる。</p>
<p>なぜスコープという概念について説明したかと言うと、宣言された名前が有効な範囲は、宣言された最も内側のスコープの範囲だからだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> ns
{<span class="co">// aの所属するスコープ</span>
    <span class="dt">int</span> a {} ;

    <span class="dt">void</span> f()
    { <span class="co">// bの所属するスコープ</span>
        <span class="dt">int</span> b {} ;

        { <span class="co">// cの所属するスコープ</span>
            <span class="dt">int</span> c {} ;
        }<span class="co">// cの範囲終わり</span>

        
    }<span class="co">// bの範囲終わり</span>

} <span class="co">// aの範囲終わり</span></code></pre></div>
<p>名前が有効な範囲は、宣言された最も内側のスコープだ。</p>
<p>外側のスコープで宣言された名前は内側のスコープで使える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f()
{
    <span class="dt">int</span> a {} ;
    {<span class="co">// 新たなスコープ</span>
        a = <span class="dv">0</span> ;
    }
}</code></pre></div>
<p>その逆はできない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f()
{
    { <span class="dt">int</span> a {} ; }
    <span class="co">// エラー</span>
    a = <span class="dv">0</span> ;
}</code></pre></div>
<p>名前空間も同じだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// グローバル名前空間スコープ</span>

<span class="kw">namespace</span> ns {
    <span class="dt">int</span> a {} ;
    <span class="dt">void</span> f()
    {
        a = <span class="dv">0</span> ; <span class="co">// OK</span>
    }
} <span class="co">// 名前空間nsのスコープの終了</span>

<span class="dt">int</span> main()
{
    <span class="co">// エラー</span>
    a = <span class="dv">0</span> ;
    <span class="co">// OK </span>
    ns::a ;
}</code></pre></div>
<p>名前空間スコープと関数スコープには違う点もあるが、名前の有効な範囲としては同じスコープだ。</p>
<p>外側のスコープで宣言された名前と同じ名前を内側で宣言すると、内側の名前が外側の名前を隠す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// グローバル名前空間のf</span>
<span class="kw">auto</span> f =  []()
{ <span class="bu">std::</span>cout &lt;&lt; <span class="dv">1</span> ; } ;

<span class="dt">int</span> main()
{
    f() ; <span class="co">// 1</span>

    <span class="co">// 関数mainのf</span>
    <span class="kw">auto</span> f = []()
    { <span class="bu">std::</span>cout &lt;&lt; <span class="dv">2</span> ; } ;

    f() ; <span class="co">// 2</span>

    {
        f() ; <span class="co">// 2</span>

        <span class="co">// ブロックのf</span>
        <span class="kw">auto</span> f = []()
        { <span class="bu">std::</span>cout &lt;&lt; <span class="dv">3</span> ; } ;
        f() ; <span class="co">// 3</span>
    }

    f() ; <span class="co">// 2</span>
}</code></pre></div>
<p>宣言されている場所に注意が必要だ。名前fは3つある。最初の関数呼び出しの時点ではグローバル名前空間のfが呼ばれる。まだ名前fは関数mainの中で宣言されていないからだ。そして関数mainのスコープの中で名前fが宣言される。このときグローバル名前空間のfは隠される。そのため、次の関数fの呼び出しでは関数mainのfが呼ばれる。次にブロックの中に入る。ここで関数fが呼ばれるが、まだこのfは関数mainのfだ。その後にブロックの中で名前fが宣言される。すると次の関数fの呼び出しはブロックのfだ。ブロックから抜けた後の関数fの呼び出しは関数mainのfだ。</p>
<p>この章では名前について解説した。名前は難しい。難しいが、プログラミングにおいては名前を向き合わなければならない。</p>
<h1 id="イテレーターの基礎">イテレーターの基礎</h1>
<p>vectorの章ではvectorの要素にアクセスする方法としてメンバー関数<code>at(i)</code>を学んだ。<code>at(i)</code>はi番目の要素にアクセスできる。ただし最初の要素は0番目だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    <span class="dt">int</span> x = v.at(<span class="dv">2</span>) ; <span class="co">// 3</span>
    v.at(<span class="dv">2</span>) = <span class="dv">0</span> ;
    <span class="co">// vは{1,2,0,4,5}</span>
}</code></pre></div>
<p>この章ではvectorの要素にアクセスする方法としてイテレーター(iterator)を学ぶ。</p>
<h2 id="イテレーターの取得方法">イテレーターの取得方法</h2>
<p>イテレーターは<code>std::begin(v)</code>で取得する。vはvectorの変数だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;
    <span class="kw">auto</span> i = <span class="bu">std::</span>begin(v) ;
}</code></pre></div>
<h2 id="イテレーターの参照する要素に対する読み書き">イテレーターの参照する要素に対する読み書き。</h2>
<p>イテレーターはvectorの先頭の要素を指し示している。イテレーターの指し示す要素を参照するには<code>*</code>を使う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    <span class="kw">auto</span> i = <span class="bu">std::</span>begin(v) ;

    <span class="dt">int</span> x = *i ; <span class="co">// 1</span>

    *i = <span class="dv">0</span> ;
    <span class="co">// vは{0,2,3,4,5} </span>
}</code></pre></div>
<p><code>*i</code>を読み込むと指し示す要素の値を読むことができ、<code>*i</code>に代入をすると指し示す要素の値を変えることができる。</p>
<h2 id="イテレーターの参照する要素を変更">イテレーターの参照する要素を変更</h2>
<p>現在指している要素の次の要素を指すように変更するには<code>++</code>を使う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    <span class="kw">auto</span> i = <span class="bu">std::</span>begin(v) ;

    *i ; <span class="co">// 1</span>
    ++i ;
    *i ; <span class="co">// 2</span>
    ++i ;
    *i ; <span class="co">// 3</span>
}</code></pre></div>
<p>現在指している要素の前の要素を指すように変更するには<code>--</code>を使う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    <span class="kw">auto</span> i = <span class="bu">std::</span>begin(v) ;

    *i ; <span class="co">// 1</span>
    ++i ;
    *i ; <span class="co">// 2</span>
    --i ;
    *i ; <span class="co">// 1</span>
}</code></pre></div>
<p>vectorの全要素を先頭からイテレーターでアクセスするには、要素数だけ<code>++i</code>すればよいことになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;
    <span class="kw">auto</span> iter = <span class="bu">std::</span>begin(v) ;

    <span class="cf">for</span> ( <span class="bu">std::</span>size_t i = <span class="dv">0</span> ; i != <span class="bu">std::</span>size(v) ; ++i, ++iter )
    {
        <span class="bu">std::</span>cout &lt;&lt; *iter &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
    }
}</code></pre></div>
<p>これは動く。ただしもっとマシな方法がある。イテレーターの比較だ。</p>
<h2 id="イテレーターの比較">イテレーターの比較</h2>
<p>イテレーターは比較できる。同じ順番の要素を指すイテレーターは等しく、そうではないイテレーターは等しくない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    <span class="kw">auto</span> x = <span class="bu">std::</span>begin(v) ;
    <span class="kw">auto</span> y = x ;

    <span class="co">// x, yは0番目の要素を指す</span>

    <span class="dt">bool</span> b1 = (x == y) ; <span class="co">// true</span>
    <span class="dt">bool</span> b2 = (x != y) ; <span class="co">// false</span>

    ++x ; <span class="co">// xは1番目の要素を指す。</span>

    <span class="dt">bool</span> b1 = (x == y) ; <span class="co">// false</span>
    <span class="dt">bool</span> b2 = (x != y) ; <span class="co">// true</span>
}</code></pre></div>
<h2 id="最後の次の要素へのイテレーター">最後の次の要素へのイテレーター</h2>
<p><code>std::begin(v)</code>はvectorの変数vの最初の要素を指し示すイテレーターを取得する。</p>
<p><code>std::end(v)</code>はvectorの変数vの最後の次の要素を指し示すイテレーターを取得する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = { <span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span> };

    <span class="co">// 最後の次の要素を指し示すイテレーター</span>
    <span class="kw">auto</span> i = <span class="bu">std::</span>end(v) ;
}</code></pre></div>
<p>最後の次の要素とは何か。ある<code>vector&lt;int&gt;</code>の変数の中身が<code>{1,2,3,4,5}</code>のとき、最初の0番目の要素の値は1だ。最後の4番目の要素の値は5だ。最後の次の要素とは、値が5の最後の要素の次の要素だ。そのような要素は実際には存在しないが、<code>std::end</code>は概念として最後の次の要素を返す。</p>
<p>最後の次の要素を指し示すイテレーターに対して、<code>*</code>で要素にアクセスを試みるとエラーになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    <span class="kw">auto</span> i = <span class="bu">std::</span>end(v) ;

    *i ; <span class="co">// エラー</span>
}</code></pre></div>
<p>最後の次の要素を<code>++</code>しようとするとエラーになる。<code>--</code>することはできる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;
    <span class="kw">auto</span> i = <span class="bu">std::</span>end(v) ;

    --i ; <span class="co">// 最後の要素を指す</span>
    *i ; <span class="co">// 5</span>
    ++i ; 最後の次の要素を指す
    *i ; <span class="co">// エラー</span>

}</code></pre></div>
<p>実際には存在しない最後の次の要素を指し示すイテレーターは何の役に立つのか。答えはイテレーターの比較だ。</p>
<p>実際には存在しない最後の次の要素を指すイテレーターに'*'を使って要素にアクセスするのはエラーだが、イテレーター同士の比較はできる。すでに説明したように、イテレーターの比較は同じ要素を指す場合はtrue、違う要素を指す場合はfalseになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;

    <span class="co">// xは最初の要素を指す</span>
    <span class="kw">auto</span> x = <span class="bu">std::</span>begin(v) ;
    <span class="co">// yは最後の次の要素を指す</span>
    <span class="kw">auto</span> y = <span class="bu">std::</span>end(v) ;


    x == y ; <span class="co">// false</span>
    ++x ; <span class="co">// xは最初の次の要素を指す</span>
    x == y ; <span class="co">// false</span>
    ++x ; <span class="co">// xは最後の要素を指す</span>
    x == y ; <span class="co">// false</span>
    ++x ; <span class="co">// xは最後の次の要素を指す</span>
    x == y ; <span class="co">// true</span>
}</code></pre></div>
<p><code>std::end</code>で取得する最後の次の要素を指すイテレーターと比較することで、イテレーターが最後の次の要素を指し示す状態に到達したことを判定できる。</p>
<p>ということは、<code>vector</code>の要素を先頭から最後まで順番に出力するプログラムは、以下のように書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    <span class="cf">for</span> ( <span class="kw">auto</span> iter = <span class="bu">std::</span>begin(v), last = <span class="bu">std::</span>end(v) ;
          iter != last ; ++iter )
    {
        <span class="bu">std::</span>cout &lt;&lt; *iter &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
    }
}</code></pre></div>
<h2 id="なんでもイテレーター">なんでもイテレーター</h2>
<p>イテレーターというのは要素にアクセスする回りくどくて面倒な方法に見える。イテレーターという面倒なものを使わずに、<code>vector::at(i)</code>でi番目の要素にアクセスするほうが楽ではないか。そう考える読者もいるだろう。イテレーターの利点はその汎用性にある。イテレーターの作法に従うことで、様々な処理が同じコードで書けるようになるのだ。</p>
<p>たとえば、vectorの要素を先頭から順番に出力する処理を振り返ってみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    <span class="cf">for</span> ( <span class="bu">std::</span>size_t i = <span class="dv">0</span> ; i != <span class="bu">std::</span>size(v) ; ++i )
    {
        <span class="bu">std::</span>cout &lt;&lt; v.at(i) &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
    }
}</code></pre></div>
<p>このコードは<code>vector</code>にしか使えないコードだ。イテレーターで書き直してみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    <span class="cf">for</span> ( <span class="kw">auto</span> iter = <span class="bu">std::</span>begin(v), last = <span class="bu">std::</span>end(v) ;
          iter != last ; ++iter )
    {
        <span class="bu">std::</span>cout &lt;&lt; *iter &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
    }
}</code></pre></div>
<p>そして、この要素を先頭から出力する処理を関数にしてみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> output_all = []( <span class="kw">auto</span> first, <span class="kw">auto</span> last )
{
    <span class="cf">for</span> ( <span class="kw">auto</span> iter = first ; iter != last ; ++iter )
    {
        <span class="bu">std::</span>cout &lt;&lt; *iter &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;
    }
} ;

<span class="dt">int</span> main()
{
    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    output_all( <span class="bu">std::</span>begin(v), <span class="bu">std::</span>end(v) ) ;
}</code></pre></div>
<p>この<code>関数output_all</code>は<code>vector</code>以外のイテレーターにも対応している。C++には様々なイテレーターがある。例えば標準入力から値を受け取るイテレーターがある。早速使ってみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>istream_iterator&lt;<span class="dt">int</span>&gt; first( <span class="bu">std::</span>cin ), last ;

    output_all( first, last ) ;
}</code></pre></div>
<p>このプログラムは標準入力から<code>int</code>型の値を受け取り、それをそのまま標準出力する。</p>
<p>C++には他にも、カレントディレクトリーにあるファイルの一覧を取得するイテレーターがある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>filesystem<span class="bu">::</span>directory_iterator first(<span class="st">&quot;./&quot;</span>), last ;

    output_all( first, last ) ;
}</code></pre></div>
<p><code>関数output_all</code>のコードは何も変えていないのに、様々なイテレーターに対応できる。イテレーターというお作法に乗っ取ることで、様々な処理が可能になるのだ。</p>
<p>これは出力にも言えることだ。<code>関数output_all</code>は<code>std::cout</code>に出力していた。これをイテレーターに対する書き込みに変えてみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> output_all = []( <span class="kw">auto</span> first, <span class="kw">auto</span> last, <span class="kw">auto</span> output_iter )
{
    <span class="cf">for</span> ( <span class="kw">auto</span> iter = first ; iter != last ; ++iter, ++output_iter )
    {
        *output_iter = *iter ;
    }
} ;</code></pre></div>
<p>書き換えた<code>関数output_iter</code>は新しく<code>output_iter</code>という引数を取る。これはイテレーターだ。<code>std::cout</code>に出力する代わりに、このイテレーターに書き込むように変更している。</p>
<p>こうすることによって、出力にも様々なイテレーターが使える。</p>
<p>標準出力に出力するイテレーターがある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;
    
    output_all( <span class="bu">std::</span>begin(v), <span class="bu">std::</span>end(v),
                <span class="bu">std::</span>ostream_iterator&lt;<span class="dt">int</span>&gt;(<span class="bu">std::</span>cout) ) ;
}</code></pre></div>
<p>vectorも出力先にできる。つまりvectorのコピーだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; source = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;
    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; destination(<span class="dv">5</span>) ;

    output_all( <span class="bu">std::</span>begin(source), <span class="bu">std::</span>end(source), <span class="bu">std::</span>begin( destination ) ) ;
}</code></pre></div>
<p><code>desitination(5)</code>というのは、<code>vector</code>にあらかじめ5個の要素を入れておくという意味だ。あらかじめ入っている要素の値はintの場合ゼロになる。</p>
<p>この他にもイテレーターは様々ある。自分でイテレーターを作ることもできる。そして、<code>関数output_all</code>はイテレーターにさえ対応していれば様々な処理にコードを一行たりとも変えずに使えるのだ。</p>
<h2 id="イテレーターと添字の範囲">イテレーターと添字の範囲</h2>
<p>イテレーターは順序のある値の集合を表現するために、最初の要素への参照と、最後の次の要素への参照のペアを用いる。</p>
<p>たとえば、{1,2,3,4,5}という順序の値の集合があった場合、イテレーターは最初の要素である1と最後の一つ次の要素である5の次の架空の要素を指し示す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    <span class="kw">auto</span> i = <span class="bu">std::</span>begin(v) ;
    <span class="kw">auto</span> j = <span class="bu">std::</span>end(v) ;
}</code></pre></div>
<p>このようにして範囲を表現することを、<code>半閉鎖(half-closed)</code>とか、<code>[i,j)</code>などと表現する。</p>
<p>この状態から{2,3,4,5}のような値の集合を表現したい場合、イテレーターiをインクリメントすればよい。</p>
<pre><code>++i ;</code></pre>
<p>これで<code>[i,j)</code>は{2,3,4,5}になった。</p>
<p>このような範囲の表現方法に疑問を感じる読者もいるだろう。なぜ最後の次の要素という本来存在しない架空の要素をあたかも参照しているかのようなイテレーターが必要なのか。最後の要素を参照するのではだめなのか。</p>
<p>そのような範囲の表現方法は、<code>閉鎖(closed)</code>とか<code>[i,j]</code>などと表現する。</p>
<p>実はこの方法はvectorの要素の順番を指定する方法と同じなのだ。</p>
<p>{1,2,3,4,5}と5個の順序ある要素からなるvectorでは、最初の要素は0番目で、最後の要素は4番目だ。1番目から5番目ではない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    v.at(<span class="dv">0</span>) ; <span class="co">// 最初の要素: 1</span>
    v.at(<span class="dv">4</span>) ; <span class="co">// 最後の要素: 5</span>
}</code></pre></div>
<p>ではなぜなのか。なぜvectorではn個の要素の順番を0番目からn-1番目として表現するのか。</p>
<p>実はC++に限らず、現在使われているすべてのプログラミングはインデックスを0から始めている。かつてはインデックスを1からはじめる言語も存在したが、そのような言語は今は使われていない。</p>
<p>この疑問はエドガー・ダイクストラがWhy numbering should start at zero(EWD831)で解説している。</p>
<p>2, 3, ..., 12の範囲の自然数を表現するのに、慣習的に以下の4つの表記がある。</p>
<p><span class="math display">\[
a) 2 \le i \lt 13
\]</span></p>
<p><span class="math display">\[
b) 1 \lt i \le 12
\]</span></p>
<p><span class="math display">\[
c) 2 \le i \le 12
\]</span></p>
<p><span class="math display">\[
d) 2 \lt i \lt 13
\]</span></p>
<p>C++のイテレーターはa)を元にしている。</p>
<p>この4つのうち、a)とb)は上限から下限を引くと、範囲にある自然数の個数である11になる。</p>
<p>この性質はとても便利なのでC++でも、イテレーター同士の引き算ができるようになっている。イテレーターi, j(<span class="math inline">\(i \le j\)</span>)で<code>j - i</code>をした結果はイテレーターの範囲の要素の個数だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>,<span class="dv">11</span>,<span class="dv">12</span>} ;

    <span class="kw">auto</span> i = <span class="bu">std::</span>begin(v) ;
    <span class="kw">auto</span> j = <span class="bu">std::</span>end(v) ;

    <span class="co">// 11</span>
    <span class="co">// イテレーターの範囲の要素の個数</span>
    <span class="bu">std::</span>cout &lt;&lt; j - i &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>s ;

    ++i ; <span class="co">// 先頭の次の要素を指す</span>
    <span class="co">// 10</span>
    <span class="bu">std::</span>cout &lt;&lt; j - i ; 
}</code></pre></div>
<p>a)とb)はどちらがいいのだろうか。b)を元にイテレーターを設計すると以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// b)案を採用する場合</span>
<span class="dt">int</span> main()
{
    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    <span class="co">// 最初の一つ前の架空の要素を指す</span>
    <span class="kw">auto</span> i = <span class="bu">std::</span>begin(v) ;
    <span class="co">// 最後の要素を指す</span>
    <span class="kw">auto</span> j = <span class="bu">std::</span>end(v) ;

    <span class="co">// 最初の要素を指すようにする。</span>
    ++i ;

    <span class="co">// iが最後の要素を指すとループを抜ける</span>
    <span class="cf">for</span> ( ; i != j ; ++i )
    {
        <span class="bu">std::</span>cout &lt;&lt; *i ;
    }
    <span class="co">// 最後の要素を処理する</span>
    <span class="bu">std::</span>cout &lt;&lt; *i ;
    

}</code></pre></div>
<p>a)の方がよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// a)案を採用する場合</span>
<span class="dt">int</span> main()
{
    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    <span class="co">// 最初の要素を指す</span>
    <span class="kw">auto</span> i = <span class="bu">std::</span>begin(v) ;
    <span class="co">// 最後の次の要素を指す</span>
    <span class="kw">auto</span> j = <span class="bu">std::</span>end(v) ;

    <span class="co">// iが最後の次の要素を指すとループを抜ける</span>
    <span class="cf">for</span> ( ; i != j ; ++i )
    {
        <span class="bu">std::</span>cout &lt;&lt; *i ;
    }

    <span class="co">// すべての要素について処理を終えている</span>
}</code></pre></div>
<p>b)案では末尾から先頭まで後ろ向きに要素を一巡する操作はやりやすいが、実際には先頭から末尾まで一巡する操作の方が多い。</p>
<p>C++では要素の順番を数値で指し示す時、最初の要素は0番目であり、次の要素は1番目であり、N個目の要素はN-1番目になっている。この数値で指し示すことを<code>添字</code>とか<code>インデックス</code>というがなぜ最初の要素を1番目にしないのか。</p>
<p>C++では様々なところでa)を採用している。これを添字に適用すると、最初の要素が1番目から始まる場合、N個の要素を参照する添字の範囲は<span class="math inline">\(1 \le i \lt N+1\)</span>になる。そのような場合、以下のようなコードになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 最初の要素が1番目の場合</span>
<span class="dt">int</span> main()
{
    <span class="co">// 5個の要素を持つvector</span>
    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    <span class="co">// iの値の範囲は1から5まで</span>
    <span class="cf">for</span> ( <span class="bu">std::</span>size_t i = <span class="dv">1</span> ; i &lt; <span class="dv">6</span> ; ++i )
    {
        <span class="bu">std::</span>cout &lt;&lt; v.at(i) ;
    }    
}</code></pre></div>
<p>要素数は5個なのに6が出てくる。最初の要素が0番目の場合、N個の要素を参照する添字の範囲は<span class="math inline">\(0 \le i \lt N\)</span>になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 最初の要素が0番目の場合</span>
<span class="dt">int</span> main()
{
    <span class="co">// 5個の要素を持つvector</span>
    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    <span class="co">// iの値の範囲は0から5まで</span>
    <span class="cf">for</span> ( <span class="bu">std::</span>size_t i = <span class="dv">0</span> ; i &lt; <span class="dv">5</span> ; ++i )
    {
        <span class="bu">std::</span>cout &lt;&lt; v.at(i) ;
    }    
}</code></pre></div>
<p>一貫性のために最初の要素は0番目となっている。</p>
<p>また、空の集合にも対応できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 空</span>
    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v ;

    <span class="co">// 空なので何も出力されない</span>
    <span class="cf">for</span> (   <span class="kw">auto</span> i = <span class="bu">std::</span>begin(v), j = <span class="bu">std::</span>end(v) ;
            i != j ; ++i )
    {
        <span class="bu">std::</span>cout &lt;&lt; i ;
    }
}</code></pre></div>
<p>変数vは空なので<code>i != j</code>はfalseとなり、for文の中の文は一度も実行されない。</p>
<h1 id="ポップカルチャーリファレンス">ポップカルチャーリファレンス</h1>
<pre><code>ポップカルチャーリファレンスというのは流行の要素をさり気なく作品中に取り入れることで、流行作品を知っている読者の笑いを誘う手法である
-- キャプテン・オブビウス ポップカルチャーリファレンスについて</code></pre>
<h1 id="cプリプロセッサー">Cプリプロセッサー</h1>
<p>CプリプロセッサーはC++がC言語から受け継いだ機能だ。CプリプロセッサーはソースコードをC++としてパースする前に、テキストをトークン単位で変形する処理のことだ。この処理はソースファイルをC++としてパースする前処理として行われる。CプリプロセッサーはC++ではなく別言語として認識すべきで、そもそもプログラミング言語ではなくマクロ言語だ。</p>
<p>C++ではCプリプロセッサーが広く使われており、今後もしばらくは使われるだろう。読者がC++で書かれた既存のコードを読む時、Cプリプロセッサーは避けて通れない。Cプリプロセッサーはいずれ廃止したい機能ではあるが、C++は未だに廃止できていない。</p>
<p>Cプリプロセッサーはプリプロセッシングディレクティブ(preprocessing directive)を認識し、トークン列を処理する。ディレクティブはソースファイルの文頭に文字<code>#</code>から始まり、改行文字で終わる。<code>#</code>とディレクティブの間に空白文字を入れてもよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#define NOSPACE</span>
<span class="pp">#    define SPACE</span></code></pre></div>
<h2 id="includeディレクティブ">#includeディレクティブ</h2>
<p><code>#include</code>は指定したファイルの内容をその場に挿入する。本質的にはコピペだ。C++では<code>#include</code>はライブラリを利用するのに使われる。</p>
<p><code>#include</code>は以下のいずれかの文法を持つ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&lt;ヘッダーファイルパス&gt;</span><span class="pp"> 改行文字</span>
<span class="pp">#include </span><span class="im">&quot;ヘッダーファイルパス&quot;</span><span class="pp"> 改行文字</span></code></pre></div>
<p><code>#include</code>は指定したファイルパスのファイルの内容をその場所に挿入する。このファイルをヘッダーファイルという。<code>&lt;&gt;</code>によるファイルパスは、標準ライブラリやシステムのヘッダーファイルを格納したディレクトリーからヘッダーファイルを探す。<code>&quot;&quot;</code>によるファイルパスは、システム以外のディレクトリーからもヘッダーファイルを探す。例えばカレントディレクトリーなどだ。</p>
<p>例えば、以下のようなヘッダーファイル<code>foo.h</code>があり、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// foo.h</span>
foo foo foo</code></pre></div>
<p>以下のようなソースファイル<code>bar.cpp</code>がある場合、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// bar.cpp</span>

<span class="pp">#include </span><span class="im">&quot;foo.h&quot;</span>

<span class="co">// end bar.cpp</span></code></pre></div>
<p><code>bar.cpp</code>をCプリプロセッサーにかけると、以下のようなソースファイルが出力される</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// bar.cpp</span>

<span class="co">// foo.h</span>
foo foo foo

<span class="co">// end bar.h</span></code></pre></div>
<p>このソースファイルはC++のソースファイルとしてはエラーとなるが、Cプリプロセッサーは単純にトークン列で分割したテキストファイルとしてソースファイルを処理するため、Cプリプロセッサーとしてはエラーにはならない。</p>
<p>冒頭で述べたように、<code>#include</code>の本質はコンパイラーによるコピペである。あるテキストファイルの内容をその場に挿入するコピペ機能を提供する。</p>
<p><code>#include</code>は、他の言語でモジュール、importなどと呼ばれている機能を簡易的に提供する。C++の標準ライブラリを使うには、<code>&lt;iostream&gt;</code>や<code>&lt;string&gt;</code>や<code>&lt;vector&gt;</code>のようなヘッダーファイルを<code>#include</code>する必要がある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// iostreamライブラリを使う</span>
<span class="pp">#include </span><span class="im">&lt;iostream&gt;</span>
<span class="co">// stringライブラリを使う</span>
<span class="pp">#include </span><span class="im">&lt;string&gt;</span>

<span class="dt">int</span> main()
{
    <span class="co">// &lt;string&gt;のライブラリ</span>
    <span class="bu">std::</span>string s(<span class="st">&quot;hello&quot;</span>) ;
    <span class="co">// iostreamのライブラリ</span>
    <span class="bu">std::</span>cout &lt;&lt; s ;
}</code></pre></div>
<p>すでに述べたように<code>#include</code>はファイルの内容をその場に挿入するだけであり、他の言語にあるモジュールのための高級な機能ではない。本書を執筆時点で規格策定中のC++20では、より高級なモジュール機能を追加する予定がある。</p>
<p>同じヘッダーファイルを複数回<code>#include</code>すると、当然複数回挿入される。</p>
<p>以下のような<code>val.h</code>を、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// val.h</span>
<span class="kw">inline</span> <span class="dt">int</span> val ;</code></pre></div>
<p>以下のように複数回<code>#include</code>すると、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&quot;val.h&quot;</span>
<span class="pp">#include </span><span class="im">&quot;val.h&quot;</span></code></pre></div>
<p>以下のように置換される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// val.h</span>
<span class="kw">inline</span> <span class="dt">int</span> val ;
<span class="co">// val.h</span>
<span class="kw">inline</span> <span class="dt">int</span> val ;</code></pre></div>
<p>これはvalの定義が重複しているためエラーとなる。</p>
<p>しかし、ヘッダーファイルを一度しか<code>#include</code>しないようにするのは困難だ。なぜならば、ヘッダーファイルは他のヘッダーファイルから間接的に<code>#include</code>されることもあるからだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// lib_f.h</span>

<span class="pp">#include </span><span class="im">&quot;val.h&quot;</span>

<span class="dt">int</span> f() ;</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// lib_g.h</span>

<span class="pp">#include </span><span class="im">&quot;val.h&quot;</span>

<span class="dt">int</span> g() ;</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// main.cpp</span>

<span class="pp">#include </span><span class="im">&quot;lib_f.h&quot;</span>
<span class="pp">#include </span><span class="im">&quot;lib_g.h&quot;</span>

<span class="dt">int</span> main()
{
    <span class="dt">int</span> result = f() + g() ;
}</code></pre></div>
<p>この<code>main.cpp</code>をCプリプロセッサーにかけると以下のように置換される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// main.cpp</span>

<span class="co">// lib_f.h</span>

<span class="co">// val.h</span>
<span class="kw">inline</span> <span class="dt">int</span> val ;

<span class="dt">int</span> f() ;

<span class="co">// lib_g.h</span>

<span class="co">// val.h</span>
<span class="kw">inline</span> <span class="dt">int</span> val ;

<span class="dt">int</span> g() ;


<span class="dt">int</span> main()
{
    <span class="dt">int</span> result = f() + g() ;
}</code></pre></div>
<p>これはvalの定義が重複しているためエラーとなる。</p>
<p>この問題に対処するためには、複数回<code>#include</code>されると困るヘッダーファイルでは、インクルードガード(include guard)と呼ばれている方法を使う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// val.h</span>

<span class="pp">#ifdef INCLUDE_GUARD_HEADER_VAL_H</span>
<span class="pp">#define INCLUDE_GUARD_HEADER_VAL_H</span>

<span class="kw">inline</span> <span class="dt">int</span> val ;

<span class="pp">#endif</span></code></pre></div>
<p>このように記述した<code>val.h</code>を複数回<code>#include</code>しても、最初のifdefのみがコンパイル対象になるため、問題は起こらない。</p>
<p>インクルードガードは以下の様式を持つ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#ifdef 十分にユニークなマクロ名</span>
<span class="pp">#define 十分にユニークなマクロ名 </span>

<span class="co">// 重複してコンパイルされたくないコードをここに書く</span>

<span class="pp">#endif</span></code></pre></div>
<p><code>十分にユニークなマクロ名</code>は全ソースファイル中で衝突しないそのヘッダーに固有のマクロ名を使う。慣習的に推奨される方法としてはすべて大文字を使い、十分に長いマクロ名にすることだ。</p>
<h2 id="define">#define</h2>
<p><code>#define</code>はマクロ置換を行う。マクロにはオブジェクト風マクロ(object-like macro)と関数風マクロ(function-like macro)がある。風というのは、マクロはオブジェクトでも関数でもないからだ。ただ、文法上オブジェクトや関数の似ているだけで、実態はトークン列の愚直な置換だ。</p>
<h3 id="オブジェクト風マクロ">オブジェクト風マクロ</h3>
<p>オブジェクト風マクロの文法は以下の通り</p>
<pre><code>#define マクロ名 置換リスト　改行文字</code></pre>
<p><code>#define</code>以降の行では、マクロ名が置換リストに置き換わる</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#define ONE             1</span>
<span class="pp">#define ONE_PLUS_ONE    ONE + ONE</span>
<span class="pp">#define GNU GNU&#39;s is NOT UNIX</span>

ONE
ONE_PLUS_ONE</code></pre></div>
<p>これをプリプロセスすると以下のソースコードになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dv">1</span>
<span class="dv">1</span> + <span class="dv">1</span></code></pre></div>
<p>マクロ名<code>ONE</code>は<code>1</code>に置換される。</p>
<p>マクロ名<code>ONE_PLUS_ONE</code>は<code>ONE + ONE</code>に置換される。置換された結果に別のマクロ名があれば、そのマクロ名も置換される。</p>
<p>あるマクロ名を置換した結果、そのマクロ名が現れても再帰的に置換されることはない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#define GNU GNU&#39;s NOT UNIX!</span>

GNU</code></pre></div>
<p>これは以下のように置換される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">GNU<span class="st">&#39;s NOT UNIX!</span></code></pre></div>
<p>マクロ名<code>GNU</code>を展開するとトークン`GNU'が現れるが、これは置換されたマクロ名と同じなので、再帰的に置換されることはない。</p>
<h3 id="関数風マクロ">関数風マクロ</h3>
<p>関数風マクロの文法は以下の通り。</p>
<pre><code>#define マクロ名( 識別子リスト ) 置換リスト 改行文字</code></pre>
<p>関数風マクロはあたかも関数のように記述できる。関数風マクロに実引数として渡したトークン列は、置換リスト内で仮引数としての識別子で参照できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#define NO_ARGUMENT()           No argument</span>
<span class="pp">#define ONE_ARGUMENT( ARG )     begin ARG end</span>
<span class="pp">#define MAKE_IT_DOUBLE( ARG )   ONE_ARGUMENT( ARG ARG )</span>

NO_ARGUMENT()
ONE_ARGUMENT( foo bar )
MAKE_IT_DOUBLE( foo bar )</code></pre></div>
<p>これは以下のように置換される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">No argument
begin foo bar end
begin foo bar foo bar end</code></pre></div>
<p>複数の引数を取るマクロへの実引数は、カンマで区切られたトークン列を渡す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#define TWO( A, B ) A B</span>
<span class="pp">#define THREE( A, B, C ) C B A</span>

TWO( <span class="dv">1</span> <span class="dv">2</span>, <span class="dv">3</span> <span class="dv">4</span> )
THREE( <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span> )</code></pre></div>
<p>これは以下のように置換される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>
<span class="dv">3</span> <span class="dv">2</span> <span class="dv">1</span></code></pre></div>
<p>ただし、括弧で囲まれたトークン列の中にあるカンマは、マクロの実引数の区切りとはみなされない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#define MACRO( A ) A</span>

MACRO( (a,b) )</code></pre></div>
<p>これは以下のように置換される。</p>
<pre><code>(a,b)</code></pre>
<h3 id="va_args__可変長引数マクロ"><code>__VA_ARGS__</code>(可変長引数マクロ)</h3>
<p><code>#define</code>の識別子リストを<code>...</code>だけにしたマクロは、可変長引数マクロになる。このときマクロの実引数のトークン列は、置換リストのなかで<code>__VA_ARGS__</code>として参照できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#define MACRO(...) </span><span class="ot">__VA_ARGS__</span>

MACRO( You can write , <span class="kw">and</span> ,, <span class="kw">or</span> even ,,,, )</code></pre></div>
<p>これは以下のように置換される。</p>
<pre><code>You can write , and ,, or even ,,,,</code></pre>
<p>カンマも含めてすべてのトークン列がそのまま<code>__VA_ARGS__</code>で参照できる。</p>
<p>可変長引数マクロの識別子リストに仮引数と<code>...</code>を書いたマクロの置換リストでは、仮引数の数だけの実引数は仮引数で参照され、残りが<code>__VA_ARGS__</code>で参照される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#define MACRO( X, Y, Z, ... ) X Y Z and </span><span class="ot">__VA_ARGS__</span>

MACRO( <span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span> )</code></pre></div>
<p>これは以下のように置換される</p>
<pre><code>1 2 3 and 4,5,6</code></pre>
<p>X, Y, Zにそれぞれ1, 2, 3が入り、<code>__VA_ARGS__</code>には<code>4,5,6</code>が入る。</p>
<h3 id="va_opt__"><code>__VA_OPT__</code></h3>
<p><code>__VA_OPT__</code>は可変長引数マクロで<code>__VA_ARGS__</code>にトークン列が渡されたかどうかで置換結果を変えることができる。</p>
<p><code>__VA_OPT__</code>は可変引数マクロの置換リストでのみ使える。<code>__VA_OPT__(content)</code>は<code>__VA_ARGS__</code>にトークンがない場合はトークンなしに置換され、トークンがある場合はトークン列<code>content</code>に置換される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#define MACRO( X, ... ) f( X __VA_OPT__(,) </span><span class="ot">__VA_ARGS__</span><span class="pp"> )</span>

MACRO(<span class="dv">1</span>)
MACRO(<span class="dv">1</span>,<span class="dv">2</span>)</code></pre></div>
<p>これは以下のように置換される。</p>
<pre><code>f( 1 )
f( 1, 2 )</code></pre>
<p><code>MACRO(1)</code>は<code>X</code>が<code>1</code>になり、<code>__VA_ARGS__</code>にはトークンがないので、<code>__VA_OPT__(,)</code>は空に置換される。結果として<code>f(1)</code>となる。</p>
<p><code>MACRO(1,2)</code>は、Xが1になり、<code>__VA_ARGS__'にはトークン</code>2<code>が入るので、</code><strong>VA_OPT</strong>(,)<code>は</code>,<code>に置換される。結果として</code>f(1,2)`となる。</p>
<p><code>__VA_OPT__</code>は<code>__VA_ARGS__</code>に実引数となるトークン列がなければ空に置換されるので、このようにトークン列の有無によってカンマなどの文法上必須のトークン列の有無を切り替えたい場合に使うことができる。</p>
<h3 id="演算子">#演算子</h3>
<p><code>#</code>はマクロ実引数を文字列リテラルにする。</p>
<p><code>#</code>は関数風マクロの置換リストの中のみで使うことができる。<code>#</code>は関数風マクロの仮引数の識別子の直前に書くことができる。<code>#</code>が直前に書かれた識別子は、マクロ実引数のトークン列の文字列リテラルになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#define STRING( X ) # X</span>

STRING( hello )
STRING( hello world )</code></pre></div>
<p>これは以下のように置換される。</p>
<pre><code>&quot;hello&quot;
&quot;hello world&quot;</code></pre>
<p>また、可変長マクロと組み合わせた場合、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#define STRING( ... ) # </span><span class="ot">__VA_ARGS__</span>

STRING()
STRING( hello,world )</code></pre></div>
<p>以下のように置換される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="st">&quot;&quot;</span>
<span class="st">&quot;hello,world&quot;</span></code></pre></div>
<h3 id="演算子-1">##演算子</h3>
<p><code>##</code>はマクロ実引数の結合を行う。</p>
<p><code>##</code>は関数風マクロの置換リストの中にしか書けない。<code>##</code>は両端にマクロの仮引数の識別子を書かなければならない。<code>##</code>は両端の識別子の参照するマクロ実引数のトークン列を結合した置換を行う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#define CONCAT( A, B ) A ## B</span>

CONCAT( foo, bar )
CONCAT( aaa bbb, ccc ddd)</code></pre></div>
<p>これは以下のように置換される。</p>
<pre><code>foobar
aaa bbbccc ddd</code></pre>
<p>結合した結果のトークンは更にマクロ置換の対象となる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#define CONCAT( A, B ) A ## B</span>
<span class="pp">#define FOOBAR hello</span>

CONCAT( FOO, BAR )</code></pre></div>
<p>これは以下のように置換される。</p>
<pre><code>hello</code></pre>
<p><code>CONCAT(FOO,BAR)</code>は<code>FOOBAR</code>に置換され、FOOBARという名前のマクロ名があるためにさらに<code>hello</code>に置換される。</p>
<h3 id="複数行の置換リスト">複数行の置換リスト</h3>
<p><code>#define</code>ディレクティブの置換リストは複数行に渡って書くことができない。これは文法上の制約によるものだ。<code>#define</code>ディレクティブは改行文字で終端される。</p>
<p>しかし、関数やクラスを生成するような複雑なマクロは、複数行に分けて書きたい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#define LIST_NAME2( PREFIX, TYPE ) PREFIX ## TYPE</span>
<span class="pp">#define LIST_NAME( TYPE ) LIST_NAME2( list_, TYPE )</span>

<span class="pp">#define DEFINE_LIST( TYPE ) struct LIST_NAME(TYPE){TYPE value ;LIST_NAME(TYPE) * prev ;LIST_NAME(TYPE) * next ;} ; </span>

DEFINE_LIST(<span class="dt">int</span>)
DEFINE_LIST(<span class="dt">double</span>)</code></pre></div>
<p>この場合、行末にバックスラッシュに続けて改行を書くと、バックスラッシュと改行がプリプロセッサーによって削除される。</p>
<p>上の例は以下のように、プリプロセッサーとしては比較的わかりやすく書くことができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#define LIST_NAME2( PREFIX, TYPE ) PREFIX ## TYPE</span>
<span class="pp">#define LIST_NAME( TYPE ) LIST_NAME2( list_, TYPE )</span>

<span class="pp">#define DEFINE_LIST( TYPE )</span>\
<span class="pp">struct LIST_NAME(TYPE)</span>\
<span class="pp">{</span>\
<span class="pp">    TYPE value ;</span>\
<span class="pp">    LIST_NAME(TYPE) * prev ;</span>\
<span class="pp">    LIST_NAME(TYPE) * next ;</span>\
<span class="pp">} ; </span>

DEFINE_LIST(<span class="dt">int</span>)
DEFINE_LIST(<span class="dt">double</span>)</code></pre></div>
<p>C++ではテンプレートがあるために、このようなマクロを書く必要はない。</p>
<h3 id="undefディレクティブ">#undefディレクティブ</h3>
<p><code>#undef</code>はそれ以前に定義されたマクロを削除する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#define FOO BAR</span>
FOO
<span class="pp">#undef FOO</span>
FOO</code></pre></div>
<p>これは以下のように置換される。</p>
<pre><code>BAR
FOO</code></pre>
<h2 id="条件付きソースファイル選択">条件付きソースファイル選択</h2>
<p><code>#if</code>, <code>#elif</code>, <code>#else</code>, <code>#endif</code>, <code>#ifdef</code>, <code>#ifndef</code>は条件付きのソースファイルの選択(conditinal inclusion)を行う。これは条件付きコンパイルに近い機能を提供する。</p>
<h3 id="プリプロセッサーの定数式">プリプロセッサーの定数式</h3>
<p>プリプロセッサーで使える条件式は、C++の条件式とは比べてだいぶ制限がある。基本的には整数定数式で、<code>true</code>, <code>false</code>が使える他、<code>123</code>, <code>1+1</code>, <code>1 == 1</code>, <code>1 &lt; 1</code>のような式も使える。ただし、識別子はすべてマクロ名として置換できるものは置換され、置換できない識別子は、<code>true</code>, <code>false</code>以外はキーワードも含めてすべて0に置換される。</p>
<p>したがって、プリプロセッサーで以下のように書くと、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#if UNDEFINED</span>
<span class="pp">#endif</span></code></pre></div>
<p>以下のように書いたものと同じになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#if 0</span>
<span class="pp">#endif</span></code></pre></div>
<p>プリプロセッサーであるので、C++としてのconstexpr変数やconstexpr関数も使えない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">constexpr</span> <span class="dt">int</span> x = <span class="dv">1</span> ;

<span class="pp">#if x</span>
hello
<span class="pp">#endif</span></code></pre></div>
<p>これは以下のように置換される。</p>
<pre><code>constexpr int x = 1 ;</code></pre>
<p>プリプロセッサーはC++の文法と意味を理解しない。単にトークン列として処理する。</p>
<p>以下の例はエラーになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">constexpr</span> <span class="dt">int</span> f() { <span class="cf">return</span> <span class="dv">1</span> ; }

<span class="pp">#if f()</span>
<span class="pp">#endif</span></code></pre></div>
<p>なぜならば、<code>0()</code>は整数定数式として合法なコードではないからだ。何度も言うように、プリプロセッサーはC++の文法と意味を理解しない。</p>
<p>プリプロセッサーの定数式では、特殊なマクロ風の式を使うことができる。<code>defined</code>と<code>__has_include</code>だ。</p>
<p><code>defined</code>は以下の文法を持つ</p>
<pre><code>defined 識別子
defined ( 識別子 )</code></pre>
<p><code>defined</code>は識別子がそれ以前の行で<code>#define</code>でマクロとして定義されていて<code>#undef</code>で取り消されていない場合<code>1</code>になり、それ以外の場合0になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// #if 0</span>
<span class="pp">#if defined MACRO</span>
<span class="pp">#endif</span>

<span class="pp">#define MACRO</span>

<span class="co">// #if 1</span>
<span class="pp">#if defined MACRO</span>
<span class="pp">#endif</span>

<span class="pp">#undef MACRO</span>

<span class="co">// #if 0</span>
<span class="pp">#if defined MACRO</span>
<span class="pp">#endif</span></code></pre></div>
<p><code>__has_include</code>は以下の文法を持つ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">__has_include ( &lt; ヘッダーファイル名 &gt; )
__has_include ( <span class="st">&quot; ヘッダーファイル名 &quot;</span> )
__has_include ( 文字列リテラル )
__has_include ( &lt; マクロ &gt; )</code></pre></div>
<p>1番目と2番目は、指定されたヘッダーファイル名がシステムに存在する場合<code>1</code>に、そうでない場合0になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// &lt;filesystem&gt;の存在を確認してから#includeする</span>
<span class="pp">#if __has_include(&lt;filesystem&gt;)</span>
<span class="pp">#   include </span><span class="im">&lt;filesystem&gt;</span>
<span class="pp">#endif</span>

<span class="co">// &quot;mylibrary.h&quot;の存在を確認してから#includeする</span>
<span class="pp">#if __has_include(&quot;mylibrary.h&quot;)</span>
<span class="pp">#   include </span><span class="im">&quot;mylibrary.h&quot;</span>
<span class="pp">#endif</span></code></pre></div>
<p>3番目と4番目は、1番目と2番目が適用できない場合に初めて考慮される。その場合、まず通常通りにプリプロセッサーのマクロ置換が行われる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#define STDIO &quot;stdio.h&quot;</span>

<span class="pp">#if __has_include( STDIO )</span>
<span class="pp">#endif</span>

<span class="pp">#define STDLIB stdlib.h</span>

<span class="pp">#if __has_include( &lt;STDLIB&gt; )</span>
<span class="pp">#endif</span></code></pre></div>
<h3 id="ifディレクティブ">#ifディレクティブ</h3>
<p><code>#if</code>ディレクティブは以下の文法を持つ。</p>
<pre><code>#if 定数式 改行文字

#endif</code></pre>
<p>もし定数式がゼロの場合、<code>#if</code>と<code>#endif</code>で囲まれたトークン列は処理されない。定数式が非ゼロの場合、処理される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#if 0</span>
<span class="co">This line will be skipped.</span>
<span class="pp">#endif</span>

<span class="pp">#if 1</span>
This line will be processed.
<span class="pp">#endif</span></code></pre></div>
<p>これをプリプロセスすると以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">This line will be processed.</code></pre></div>
<p><code>#if 0</code>は処理されないので、<code>#endif</code>までのトークン列は消える。</p>
<h3 id="elifディレクティブ">#elifディレクティブ</h3>
<p><code>#elif</code>ディレクティブは、C++でいう<code>else if</code>に相当する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">
<span class="pp">#elif 定数式 改行文字</span></code></pre></div>
<p><code>#elif</code>ディレクティブは<code>#if</code>ディレクティブと<code>#endif</code>ディレクティブの間に複数書くことができる。<code>#elif</code>のある<code>#if</code>が処理される場合、<code>#if</code>から<code>#elif</code>の間のトークン列が処理される、<code>#if</code>が処理されない場合、<code>#elif</code>が<code>#if</code>と同じように定数式を評価して処理されるかどうかが判断される。<code>#elif</code>が処理される場合、処理されるトークン列は次の<code>#elif</code>もしくは<code>#endif</code>までの間のトークン列になる。</p>
<p>以下の例は、すべてYESのトークンがある行のみ処理される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#if 1</span>
YES
<span class="pp">#elif</span><span class="co"> 1</span>
<span class="co">NO</span>
<span class="pp">#endif</span>

<span class="pp">#if 0</span>
<span class="co">NO</span>
<span class="pp">#elif</span> <span class="dv">1</span>
YES
<span class="pp">#endif</span>

<span class="pp">#if 0</span>
<span class="co">NO</span>
<span class="pp">#elif</span> <span class="dv">1</span>
YES
<span class="pp">#elif 1</span>
NO
<span class="pp">#endif</span>

<span class="pp">#if 0</span>
<span class="co">NO</span>
<span class="pp">#elif</span> <span class="dv">0</span>
NO
<span class="pp">#elif 1</span>
YES
<span class="pp">#endif</span></code></pre></div>
<p>プリプロセスした結果は以下の通り、</p>
<pre><code>YES
YES
YES
YES</code></pre>
<h3 id="elseディレクティブ">#elseディレクティブ</h3>
<p><code>#else</code>ディレクティブはC++でいう<code>else</code>に相当する。</p>
<p><code>#else</code>ディレクティブは<code>#if</code>ディレクティブと<code>#endif</code>ディレクティブの間に書くことができる。もし<code>#if</code>と<code>#elif</code>ディレクティブが処理されない場合で<code>#else</code>ディレクティブがある場合、<code>#else</code>から<code>#endif</code>までのトークン列が処理される。</p>
<p>以下の例は、YESのトークンがある行のみ処理される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#if 1</span>
YES
<span class="pp">#else</span>
<span class="co">NO</span>
<span class="pp">#endif</span>

<span class="pp">#if 0</span>
<span class="co">NO</span>
<span class="pp">#else</span>
YES
<span class="pp">#endif</span>

<span class="pp">#if 0</span>
<span class="co">NO</span>
<span class="pp">#elif</span> <span class="dv">1</span>
YES
<span class="pp">#else</span>
NO
<span class="pp">#endif</span></code></pre></div>
<h3 id="ifdef-ifndefディレクティブ">#ifdef, #ifndefディレクティブ</h3>
<pre><code>#ifdef 識別子
#ifndef 識別子</code></pre>
<p>は、それぞれ以下と同じ意味になる。</p>
<pre><code>#if defined 識別子
#if !defined 識別子</code></pre>
<p>例、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#ifdef MACRO</span>
<span class="pp">#endif</span>

<span class="co">// 上と同じ</span>
<span class="pp">#if defined MACRO</span>
<span class="pp">#endif</span>


<span class="pp">#ifndef MACRO</span>
<span class="pp">#endif</span>

<span class="co">// 上と同じ</span>
<span class="pp">#if !defined MACRO</span>
<span class="pp">#endif</span></code></pre></div>
<h2 id="lineディレクティブ">#lineディレクティブ</h2>
<p><code>#line</code>ディレクティブはディレクティブの次の行の行番号と、ソースファイル名を変更する。これは人間が使うのではなく、ツールによって生成されることを想定した機能だ。</p>
<p>以下の文法の<code>#line</code>ディレクティブは、<code>#line</code>ディレクティブの次の行の行番号をあたかも数値で指定した行番号であるかのように振る舞わせる。</p>
<pre><code>#line 数値 改行文字</code></pre>
<p>数値として0もしくは2147483647より大きい数を指定した場合の挙動は未定義となる。</p>
<p>以下の例はコンパイルエラーになるが、コンパイルエラーメッセージはあたかも102行目に問題があるかのように表示される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 1行目</span>
<span class="co">// 2行目</span>
<span class="pp">#line 100 </span><span class="co">// 3行目</span>
<span class="co">// 100行目</span>
<span class="co">// 101行目</span>
ill-formed line <span class="co">// 102行目</span></code></pre></div>
<p>以下の例は999を出力するコードだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span>
<span class="dt">int</span> main()
{
<span class="pp">#line 999</span>
    <span class="bu">std::</span>cout &lt;&lt; <span class="ot">__LINE__</span> ;
}</code></pre></div>
<p>以下の文法の<code>#line</code>ディレクティブは、次の行の行番号を数値にした上で、ソースファイル名をソースファイル名にする。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#line 数値 &quot;ソースファイル名&quot; 改行文字</span></code></pre></div>
<p>例、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#line 42 &quot;answer.cpp&quot;</span></code></pre></div>
<p>以下の文法の<code>#line</code>ディレクティブは、プリプロセッサートークン列をプリプロセスし、上の2つの文法のいずれかに合致させる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#line プリプロセッサートークン列 改行文字</span></code></pre></div>
<p>例、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#define LINE_NUMBER 123</span>
<span class="pp">#line LINE_NUMBER</span></code></pre></div>
<h2 id="errorディレクティブ">#errorディレクティブ</h2>
<p><code>#error</code>ディレクティブはコンパイルエラーを引き起こす。</p>
<pre><code>#error 改行文字
#error トークン列 改行文字</code></pre>
<p><code>#error</code>によるコンパイラーのエラーメッセージには<code>#error</code>のトークン列を含む。</p>
<p><code>#error</code>の利用例としては、<code>#if</code>と組み合わせるものがある。以下の例はCHAR_BITが8でなければコンパイルエラーになるソースファイルだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&lt;climits&gt;</span>

<span class="pp">#if CHAR_BIT != 8</span>
<span class="pp">#error CHAR_BIT != 8 implementation is not supported.</span>
<span class="pp">#endif</span></code></pre></div>
<p><code>#if</code>が処理されなければ、その中にある<code>#error</code>も処理されないので、コンパイルエラーにはならない。</p>
<h2 id="pragmra">#pragmra</h2>
<p><code>#pragmra</code>ディレクティブは実装依存の処理を行う。<code>#pragma</code>はコンパイラー独自の拡張機能を追加する文法として使われている。</p>
<p>文法は以下の通り。</p>
<pre><code>#pragma プリプロセッサートークン列 改行文字</code></pre>
<p>C++では属性が追加されたために、<code>#pragma</code>を使う必要はほとんどなくなっている。</p>
<h2 id="nullディレクティブ">Nullディレクティブ</h2>
<p><code>Null</code>ディレクティブとは何もしないプリプロセッサーディレクティブだ。</p>
<pre><code># 改行文字</code></pre>
<p>つまり、単に<code>#</code>とだけ書いた行はエラーにはならない。</p>
<h2 id="定義済みマクロ名">定義済みマクロ名</h2>
<p>いくつかのマクロ名がプリプロセッサーによって予め定義されている。</p>
<table>
<colgroup>
<col width="43%" />
<col width="17%" />
<col width="39%" />
</colgroup>
<thead>
<tr class="header">
<th>マクロ名</th>
<th align="left">値</th>
<th align="left">意味</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>__cplusplus</td>
<td align="left">201703L</td>
<td align="left">C++17時点での値<br />
将来の規格で増やされる</td>
</tr>
<tr class="even">
<td>__DATE__</td>
<td align="left">&quot;Mmm dd yyyy&quot;</td>
<td align="left">ソースファイルがプリプロセスされた日付 Mmmは月、ddは日、yyyyは年<br />
月の文字列はasctimeが生成するものと同じ<br />
日が1桁の場合、ddの最初の文字は空白文字</td>
</tr>
<tr class="odd">
<td>__FILE__</td>
<td align="left">文字列リテラル</td>
<td align="left">ソースファイルの名前の文字列リテラル</td>
</tr>
<tr class="even">
<td>__LINE__</td>
<td align="left">整数リテラル</td>
<td align="left">ソースファイルの現在の行番号</td>
</tr>
<tr class="odd">
<td>__STDC_HOSTED__</td>
<td align="left">整数リテラル</td>
<td align="left">ホスト実装の場合1<br />
フリースタンディング実装の場合0</td>
</tr>
<tr class="even">
<td>__STDCPP_DEFAULT_NEW_ALIGNMENT__</td>
<td align="left">整数リテラル</td>
<td align="left">アライメント</td>
</tr>
</tbody>
</table>
</body>
</html>
