<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="江添 亮" />
  <meta name="date" content="2018-02-27" />
  <title>江添亮のプログラマーのためのC++入門</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <style>
  pre > code
  {
      display : block ;
      font-family : monospace ;
      font-size : x-large ;
      border-style : solid ;
      border-width : medium ;
      border-color : black ;
      border-radius : 0.4em ;
      padding : 0.5em ;
      word-wrap : break-word ;
      white-space : pre-wrap ;
  }
  
  h1,h2,h3,h4,h5,h6
  {
      font-size : 2em ;
      font-weight : bold ;
  }
  
  table, th, td {
      border: 1px solid black;
      border-collapse: collapse;
      padding : 0.5em ;
  }
  </style>
</head>
<body>
<div id="header">
<h1 class="title">江添亮のプログラマーのためのC++入門</h1>
<h2 class="author">江添 亮</h2>
<h3 class="date">2018-02-27</h3>
</div>
<div id="TOC">
<ul>
<li><a href="#序">序</a></li>
<li><a href="#cの概要">C++の概要</a></li>
<li><a href="#cの実行">C++の実行</a><ul>
<li><a href="#cの実行の仕組み">C++の実行の仕組み</a></li>
<li><a href="#簡単な一つのソースファイルからなるプログラムの実行">簡単な一つのソースファイルからなるプログラムの実行</a><ul>
<li><a href="#サンプルコード">サンプルコード</a></li>
<li><a href="#コンパイル">コンパイル</a></li>
<li><a href="#実行">実行</a></li>
</ul></li>
<li><a href="#gcc-cコンパイラー">GCC: C++コンパイラー</a><ul>
<li><a href="#コンパイラーオプション">コンパイラーオプション</a></li>
<li><a href="#ヘッダーファイルの省略">ヘッダーファイルの省略</a></li>
<li><a href="#コンパイル済みヘッダーprecompiled-header">コンパイル済みヘッダー(precompiled header)</a></li>
</ul></li>
<li><a href="#make-ビルドシステム">Make: ビルドシステム</a><ul>
<li><a href="#コンパイルと実行のまとめ">コンパイルと実行のまとめ</a></li>
<li><a href="#依存関係を解決するビルドシステム">依存関係を解決するビルドシステム</a></li>
<li><a href="#依存関係を記述するルール">依存関係を記述するルール</a></li>
<li><a href="#コメント">コメント</a></li>
<li><a href="#変数">変数</a></li>
<li><a href="#自動変数">自動変数</a></li>
</ul></li>
</ul></li>
<li><a href="#cプリプロセッサー">Cプリプロセッサー</a><ul>
<li><a href="#includeディレクティブ">#includeディレクティブ</a></li>
<li><a href="#define">#define</a><ul>
<li><a href="#オブジェクト風マクロ">オブジェクト風マクロ</a></li>
<li><a href="#関数風マクロ">関数風マクロ</a></li>
<li><a href="#va_args__可変長引数マクロ"><code>__VA_ARGS__</code>(可変長引数マクロ)</a></li>
<li><a href="#va_opt__"><code>__VA_OPT__</code></a></li>
<li><a href="#演算子">#演算子</a></li>
<li><a href="#演算子-1">##演算子</a></li>
<li><a href="#複数行の置換リスト">複数行の置換リスト</a></li>
<li><a href="#undefディレクティブ">#undefディレクティブ</a></li>
</ul></li>
<li><a href="#条件付きソースファイル選択">条件付きソースファイル選択</a><ul>
<li><a href="#プリプロセッサーの定数式">プリプロセッサーの定数式</a></li>
<li><a href="#ifディレクティブ">#ifディレクティブ</a></li>
<li><a href="#elifディレクティブ">#elifディレクティブ</a></li>
<li><a href="#elseディレクティブ">#elseディレクティブ</a></li>
<li><a href="#ifdef-ifndefディレクティブ">#ifdef, #ifndefディレクティブ</a></li>
</ul></li>
<li><a href="#lineディレクティブ">#lineディレクティブ</a></li>
<li><a href="#errorディレクティブ">#errorディレクティブ</a></li>
<li><a href="#pragmra">#pragmra</a></li>
<li><a href="#nullディレクティブ">Nullディレクティブ</a></li>
<li><a href="#定義済みマクロ名">定義済みマクロ名</a></li>
</ul></li>
</ul>
</div>
<h1 id="序">序</h1>
<p>本書はプログラミング経験者向けのC++入門書である。</p>
<p>本書の対象読者は、すでに何らかの実用的なプログラミング言語を習得していることを想定し、プログラミングの初歩的な概念はすべて理解しているものとして説明しない。そのため、本書には、「変数は箱のようなものである」といったような説明は出てこない。ただし、主要な他の言語とC++として特別に注意が必要な差は解説している。</p>
<h1 id="cの概要">C++の概要</h1>
<p>C++とは何か。C++の原作者にして最初の実装者であるBjarne Stroustrupは、以下のように簡潔にまとめている。</p>
<blockquote>
<p>C++は、Simulaのプログラム構造化のための機構と、Cのシステムプログラミング用の効率性と柔軟性を提供するために設計された。C++は半年ほどで現場で使えることを見込んでいた。結果として成功した。</p>
<p>Bjarne Stroustrup, A Hisotory of C++: 1979-1991, HOPL2</p>
</blockquote>
<p>プログラミング言語史に詳しくない読者は、Simulaというプログラミング言語について知らないことだろう。Simulaというのは、初めてオブジェクト指向プログラミングを取り入れたプログラミング言語だ。当時と言えばまだ高級なプログラミング言語はほとんどなく、if else, whileなどのIBMの提唱した構造化プログラミングを可能にする文法を提供しているプログラミング言語すら、多くは研究段階であった。いわんやオブジェクト指向など、当時はまだアカデミックにおいて可能性の一つとして研究されている程度の地に足のついていない夢の機能であった。そのような粗野な時代において、Simulaは先進的なオブジェクト指向プログラミングを実現していた。</p>
<p>問題は、Simulaの設計と実装では実行速度が遅く、大規模なプログラムを開発するには適さなかった。</p>
<p>Cの効率性と柔軟性というのは、要するに実行速度が速いとかメモリ消費量が少ないということだ。なぜCは他の言語に比べて効率と柔軟に優れているのか。これには2つの理由がある。</p>
<p>ひとつ、Cのコードは直接ハードウェアがサポートする命令にまでマッピング可能であるということ。現実のハードウェアにはストレージがあり、メモリがあり、キャッシュがあり、レジスターがあり、命令は投機的に並列実行される泥臭い計算機能を提供している。</p>
<p>ひとつ、使わない機能のコストを支払う必要がないというゼロオーバーヘッドの原則。例えばあらゆるメモリ利用がGCによって管理されている言語では、たとえメモリをすべて明示的に管理していたとしても、GCのコストを支払わなければならない。実行時にメモリレイアウトを判定して実行時に分岐処理ができる言語では、たとえコンパイル時にメモリレイアウトが決定されていたとしても、実行時にメモリレイアウトを判定して条件分岐するコストを支払わなければならない。</p>
<p>C++は、「アセンブリ言語をおいて、C++より下に言語を置かない」と宣言するほど、ハードウェア機能への直接マッピングとゼロオーバーヘッドの原則を重視している。</p>
<p>C++の他の特徴としては、委員会方式による国際標準規格を定めていることがある。特定の一個人や一法人が所有する言語は、個人や法人の意思で簡単に仕様が変わってしまう。短期的な利益を追求するために長期的に問題となる変更をしたり、単一の実装が仕様だと言わんばかりの振る舞いをする。特定の個人や法人に所有されていないこと、実装が従うべき標準規格があること、独立した実装が複数あること、言語に利害関係を持つ関係者が議論して投票で変更を可決すること、これがC++が長期に渡って使われてきた理由でもある。</p>
<p>委員会方式の規格制定では、下位互換性の破壊は忌避される。なぜならば、既存の動いているコードを壊すということは、それまで存在していた資産の価値を毀損することであり、利害関係を持つ委員が反対するからだ。</p>
<p>下位互換性を壊した結果何が起こるかと言うと、単に言語が新旧2つに分断される。Python 2とPython 3がその最たる例だ。</p>
<p>C++には今日の最新で高級な言語からみれば古風な制約が数多く残っているが、いずれも理由がある。下位互換性を壊すことができないという理由。効率的な実装方法が存在しないという理由。仮に効率的な実装が存在するにしても、様々な環境で実装可能でなければ規格化はできないという理由。</p>
<p>C++には良し悪しがある。Bjarne StroustrupはC++への批判にこう答えている。</p>
<blockquote>
<p>言語には2種類ある。文句を言われる言語と、誰も使わない言語。</p>
</blockquote>
<p>C++は文句を言われる方の言語だ。</p>
<h1 id="cの実行">C++の実行</h1>
<p>プログラミング言語を学ぶには、まず書いたソースコードをプログラムとして実行できるようになることが重要だ。自分が正しく理解しているかどうかを確認するために書いたコードが期待通りに動くことを確かめてこそ、正しい理解が確認できる。</p>
<h2 id="cの実行の仕組み">C++の実行の仕組み</h2>
<p>C++は慣習的に、ソースファイルをコンパイルしてオブジェクトファイルを生成し、オブジェクトファイルをリンクして実行可能ファイルを生成し、実行可能ファイルを直接実行することで実行する言語だ。</p>
<p>他の言語では、ソースファイルをそのままパースし、解釈して実行するインタープリター形式の言語が多い。もっとも、今となってはソースファイルから中間言語に変換してVMで実行するとか、JITコンパイルしてネイティブコードを生成して実行するといった実装もあるため、昔のように単純にインタープリター型の言語ということはできなくなっている事情はある。ただし、最終的にJITコンパイルされてネイティブコードが実行される言語でも、コンパイルやコード生成はプログラマーが意識しない形で行われるため、プログラマーはコンパイラーを直接使う必要のない言語も多い。</p>
<p>C++はプログラマーが直接コンパイラーを使い、ソースファイルをプログラムに変換する言語だ。</p>
<h2 id="簡単な一つのソースファイルからなるプログラムの実行">簡単な一つのソースファイルからなるプログラムの実行</h2>
<p>ここでは、典型的なC++のソースファイルをどのようにコンパイルし実行するか、一連の流れを学ぶ。</p>
<h3 id="サンプルコード">サンプルコード</h3>
<p>以下のC++のソースファイルは標準出力にhelloと出力するものだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span>

<span class="dt">int</span> main()
{
    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;hello&quot;</span> ;
}</code></pre></div>
<p>コードの詳細な意味はさておくとして、このサンプルコードを使ってC++の実行までの流れを見ていこう。</p>
<p>まずは端末から作業用の適当な名前のディレクトリーを作る。ここでは<code>cpp</code>としておこう。ディレクトリーの作成は<code>mkdir</code>コマンドで行える。</p>
<pre><code>$ mkdir cpp
$ cd cpp</code></pre>
<p>好きなテキストエディターを使って上のサンプルコードをテキストファイルとして記述する。ファイル名は<code>hello.cpp</code>としておこう。</p>
<pre><code>$ vim hello.cpp</code></pre>
<p>C++のソースファイルの名前は何でもよいが、慣習で使われている拡張子がいくつかある。本書では<code>.cpp</code>を使う。</p>
<p>無事にソースファイルが作成できたかどうか確認してみよう。</p>
<pre><code>$ ls
hello.cpp
$ cat hello.cpp
#include &lt;iostream&gt;

int main()
{
    std::cout &lt;&lt; &quot;hello&quot; ;
}</code></pre>
<h3 id="コンパイル">コンパイル</h3>
<p>さて、ソースファイルが用意できたならば、いよいよコンパイルだ。</p>
<p>C++のソースファイルから、実行可能ファイルを生成するソフトウェアをC++コンパイラーという。C++コンパイラーとしては、GCC(GNU Compiler Collection)とClang(クラン)がある。使い方はどちらもほぼ同じだ。</p>
<p>GCCを使って先程の<code>hello.cpp</code>をコンパイルするには以下のようにする。</p>
<pre><code>$ g++ -o hello hello.cpp</code></pre>
<p>GCCという名前のC++コンパイラーなのに<code>g++</code>なのは、<code>gcc</code>はC言語コンパイラーの名前としてすでに使われているからだ。この慣習はClangも引き継いでいて、ClangのC++コンパイラーは<code>clang++</code>だ。</p>
<p>サンプルコードを間違いなくタイプしていれば、カレントディレクトリに<code>hello</code>とぃう実行可能ファイルが作成されるはずだ。確認してみよう。</p>
<pre><code>$ ls
hello hello.cpp</code></pre>
<h3 id="実行">実行</h3>
<p>さて、いよいよ実行だ。通常のOSではカレントディレクトリがPATHに含まれていないため、実行するにはカレントディレクトリからパスを指定する必要がある。</p>
<pre><code>$ ./hello
hello</code></pre>
<p>上出来だ。初めてのC++プログラムが実行できた。さっそくC++を学んでいきたいところだが、その前にC++プログラミングに必要なツールの使い方を学ぶ必要がある。</p>
<h2 id="gcc-cコンパイラー">GCC: C++コンパイラー</h2>
<p>GCCはC++のソースファイルからプログラムを生成するC++コンパイラーだ。</p>
<p>GCCの基本的な使い方は以下の通り。</p>
<pre><code>g++ その他のオプション -o 出力するファイル名 ソースファイル名</code></pre>
<p>ソースファイル名は複数指定することができる。</p>
<pre><code>g++ -o abc a.cpp b.cpp c.cpp</code></pre>
<p>これについては分割コンパイルの章で詳しく解説する。</p>
<p>コンパイラーはメッセージを出力することがある。コンパイルメッセージには、エラーメッセージと警告メッセージとがある。</p>
<p>エラーメッセージというのは、ソースコードに文法上、意味上の誤りがあるため、コンパイルできない場合に生成される。エラーメッセージはエラーの箇所も教えてくれる。ただし、文法エラーは往々にして適切な誤りの箇所を指摘できないこともある。これは、C++の文法としては正しくないテキストファイルから、妥当なC++であればどういう間違いなのかを推測する必要があるためだ。</p>
<p>警告メッセージというのは、ソースコードにコンパイルを妨げる文法上、意味上の誤りは存在しないが、誤りの可能性が疑われる場合に出力される。</p>
<h3 id="コンパイラーオプション">コンパイラーオプション</h3>
<p>GCCのコンパイラーオプションをいくつか学んでいこう。</p>
<p><code>-std=</code>はC++の規格を選択するオプションだ。C++17に準拠したいのであれば<code>-std=c++17</code>を指定する。読者が本書を読む頃には、C++20や、あるいはもっと未来の規格が発行されているかもしれない。常に最新のC++規格を選択するオプションを指定するべきだ。</p>
<p><code>-Wall</code>はコンパイラーの便利な警告メッセージのほとんどすべてを有効にするオプションだ。コンパイラーによる警告メッセージはプログラムの不具合を未然に発見できるので、このオプションは指定すべきだ。</p>
<p><code>--pedantic-errors</code>はC++の規格を厳格に守るオプションだ。規格に違反しているコードがコンパイルエラー扱いになる。</p>
<p>これをまとめると、GCCは以下のように使う。</p>
<pre><code>g++ -std=c++17 -Wall --pedantic-errors -o 出力ファイル名 入力ファイル名</code></pre>
<p>ところで、GCCのオプションはとても多い。すべてを知りたい読者は、gccのマニュアルを読むとよい。</p>
<pre><code>$ man gcc</code></pre>
<h3 id="ヘッダーファイルの省略">ヘッダーファイルの省略</h3>
<p>先程のソースコードをもう一度見てみよう。冒頭に以下のような行がある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></code></pre></div>
<p>これは<code>#includeディレクティブ</code>(#include directive)といい、プリプロセッサー(preprocessor)の一部だ。プリプロセッサーについて詳しくは煩雑になるので巻末資料を参照してもらうとして、このコードは<code>iostream</code>ライブラリを使うために必要で、その意味としてはヘッダーファイル<code>iostream</code>を取り込みだ。</p>
<p>C++の標準ライブラリを使うには、ライブラリごとに対応した<code>#includeディレクティブ</code>を書かなければならない。それはあまりにも煩雑なので、本書では標準ライブラリのヘッダーファイルをすべて<code>#include</code>した<code>ヘッダーファイル</code>(header file)を作成し、それを<code>#include</code>することで、<code>#include</code>を書かなくてすむようにする。</p>
<p>そのためにはまず標準ライブラリのヘッダーファイルのほとんどすべてを<code>#include</code>したヘッダーファイル、<code>all.h</code>を作成する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&lt;cstddef&gt;</span>
<span class="pp">#include </span><span class="im">&lt;limits&gt;</span>
<span class="pp">#include </span><span class="im">&lt;climits&gt;</span>
<span class="pp">#include </span><span class="im">&lt;cfloat&gt;</span>
<span class="pp">#include </span><span class="im">&lt;cstdint&gt;</span>
<span class="pp">#include </span><span class="im">&lt;cstdlib&gt;</span>
<span class="pp">#include </span><span class="im">&lt;new&gt;</span>
<span class="pp">#include </span><span class="im">&lt;typeinfo&gt;</span>
<span class="pp">#include </span><span class="im">&lt;exception&gt;</span>
<span class="pp">#include </span><span class="im">&lt;initializer_list&gt;</span>
<span class="pp">#include </span><span class="im">&lt;cstdalign&gt;</span>
<span class="pp">#include </span><span class="im">&lt;stdexcept&gt;</span>
<span class="pp">#include </span><span class="im">&lt;cassert&gt;</span>
<span class="pp">#include </span><span class="im">&lt;cerrno&gt;</span>
<span class="pp">#include </span><span class="im">&lt;system_error&gt;</span>
<span class="pp">#include </span><span class="im">&lt;string&gt;</span>

<span class="pp">#if __has_include(&lt;string_view&gt;)</span>
<span class="pp">#   include </span><span class="im">&lt;string_view&gt;</span>
<span class="pp">#endif</span>

<span class="pp">#include </span><span class="im">&lt;array&gt;</span>
<span class="pp">#include </span><span class="im">&lt;deque&gt;</span>
<span class="pp">#include </span><span class="im">&lt;forward_list&gt;</span>
<span class="pp">#include </span><span class="im">&lt;list&gt;</span>
<span class="pp">#include </span><span class="im">&lt;vector&gt;</span>
<span class="pp">#include </span><span class="im">&lt;map&gt;</span>
<span class="pp">#include </span><span class="im">&lt;set&gt;</span>
<span class="pp">#include </span><span class="im">&lt;unordered_map&gt;</span>
<span class="pp">#include </span><span class="im">&lt;unordered_set&gt;</span>
<span class="pp">#include </span><span class="im">&lt;queue&gt;</span>
<span class="pp">#include </span><span class="im">&lt;stack&gt;</span>
<span class="pp">#include </span><span class="im">&lt;iterator&gt;</span>
<span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span>
<span class="pp">#include </span><span class="im">&lt;cfenv&gt;</span>
<span class="pp">#include </span><span class="im">&lt;random&gt;</span>
<span class="pp">#include </span><span class="im">&lt;numeric&gt;</span>
<span class="pp">#include </span><span class="im">&lt;cmath&gt;</span>
<span class="pp">#include </span><span class="im">&lt;iosfwd&gt;</span>
<span class="pp">#include </span><span class="im">&lt;iostream&gt;</span>
<span class="pp">#include </span><span class="im">&lt;ios&gt;</span>
<span class="pp">#include </span><span class="im">&lt;streambuf&gt;</span>
<span class="pp">#include </span><span class="im">&lt;istream&gt;</span>
<span class="pp">#include </span><span class="im">&lt;ostream&gt;</span>
<span class="pp">#include </span><span class="im">&lt;iomanip&gt;</span>
<span class="pp">#include </span><span class="im">&lt;sstream&gt;</span>
<span class="pp">#include </span><span class="im">&lt;fstream&gt;</span>

<span class="pp">#if __has_include(&lt;filesystem&gt;)</span>
<span class="pp">#   include </span><span class="im">&lt;filesystem&gt;</span>
<span class="pp">#endif</span>

<span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span>
<span class="pp">#include </span><span class="im">&lt;cinttypes&gt;</span>


<span class="pp">#include </span><span class="im">&lt;regex&gt;</span>
<span class="pp">#include </span><span class="im">&lt;atomic&gt;</span>
<span class="pp">#include </span><span class="im">&lt;thread&gt;</span>
<span class="pp">#include </span><span class="im">&lt;mutex&gt;</span>
<span class="pp">#include </span><span class="im">&lt;shared_mutex&gt;</span>
<span class="pp">#include </span><span class="im">&lt;condition_variable&gt;</span>
<span class="pp">#include </span><span class="im">&lt;future&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>literals ;</code></pre></div>
<p>このようなヘッダーファイル<code>all.h</code>を作成した後に、ソースファイルで以下のように書けば、他のヘッダーファイルを<code>#include</code>する必要がなくなる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&quot;all.h&quot;</span>

<span class="co">// その他のコード</span></code></pre></div>
<p><code>//</code>から行末まではコメントで、好きなテキストを書くことができる。</p>
<p>しかし、この最初の一行の<code>#include</code>も面倒だ。そこでGCCのオプション<code>-include</code>を使い、<code>all.h</code>を常に<code>#include</code>した扱いにする。</p>
<pre><code>$ g++ -include all.h -o program main.cpp</code></pre>
<p>このようにすると、<code>main.cpp</code>が以下のコードでもコンパイルできるようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// main.cpp</span>
<span class="co">// 面倒な#includeなどなし</span>

<span class="dt">int</span> main()
{
    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;hello&quot;</span> ;
}</code></pre></div>
<p>これでヘッダーファイルが省略できるようになった。</p>
<h3 id="コンパイル済みヘッダーprecompiled-header">コンパイル済みヘッダー(precompiled header)</h3>
<p>C++はソースファイルをコンパイルする必要がある言語だ。コンパイルには時間がかかる。コンパイルにどれだけ時間がかかっているかを計測するには、以下のようにするとよい。</p>
<pre><code>$ time g++ -std=c++17 -Wall --pedantic-errors -include all.h -o program main.cpp</code></pre>
<p>どうだろうか。読者の環境にもよるが、近くできるぐらいの時間がかかっているのではないだろうか。プログラミングの習得にはコードを書いてから実行までの時間が短い方がよい。そこで本格的にC++を学ぶ前に、コンパイル時間を短縮する方法を学ぶ。</p>
<p>プログラムで変更しないファイルを事前にコンパイルしておくと、変更した部分だけコンパイルすれば良いので、コンパイル時間の短縮になる。GCCでは、ヘッダーファイルを事前にコンパイルする特別な機能がある。標準ライブラリのヘッダーファイルは変更しないので、事前にコンパイルしておけばコンパイル時間の短縮になる。</p>
<p>事前にコンパイルしたヘッダーファイルのことをコンパイル済みヘッダー(precompiled header)という。</p>
<p>すでに作成した<code>all.h</code>はコンパイル済みヘッダーとするのに適切なヘッダーファイルだ。</p>
<p>コンパイル済みヘッダーファイルを作成するには、ヘッダーファイル単体をGCCに与え、出力するファイルを<code>ヘッダーファイル名.gch</code>とする。ヘッダーファイル名が<code>all.h</code>の場合、<code>all.h.gch</code>となる。</p>
<p>GCCのオプションには他のソースファイルをコンパイルするときと同じオプションを与えるほか、ヘッダーファイルがC++で書かれていることを示すオプション<code>-x c++-header</code>を与える。</p>
<pre><code>g++ -std=c++17 -Wall --pedantic-errors -x c++-header -o all.h.gch all.h</code></pre>
<p>こうすると、コンパイル済みヘッダーファイル<code>all.h.gch</code>が生成できる。</p>
<p>GCCはヘッダーファイルを使うときに、同名の.gchファイルが存在する場合は、そちらをコンパイル済みヘッダーファイルとして使うことで、ヘッダーファイルの処理を省略する。</p>
<pre><code>g++ -std=c++17 -Wall --pedantic-errors -include all.h -o program main.cpp</code></pre>
<p>コンパイル済みヘッダーは一回のコンパイルにつき一つしか使うことができない。そのため、コンパイル済みヘッダーとするヘッダーファイルを定め、そのヘッダーファイル内に他のヘッダーをすべて記述する。本書ではコンパイル済みヘッダーファイルとする元のヘッダーファイルの名前を<code>all.h</code>とする。</p>
<p>さっそくコンパイル時間の短縮効果を確かめてみよう。</p>
<pre><code>$ ls
all.h main.cpp
$ g++ -std=c++17 -Wall --pedantic-errors -x c++-header -o all.h.gch all.h
$ ls
all.h all.h.gch main.cpp
$ time g++ -std=c++17 -Wall --pedantic-errors -include all.h -o program main.cpp</code></pre>
<h2 id="make-ビルドシステム">Make: ビルドシステム</h2>
<h3 id="コンパイルと実行のまとめ">コンパイルと実行のまとめ</h3>
<p>ここまで、我々はソースファイルをコンパイルして実行可能ファイルを生成し、プログラムを実行する方法について学んできた。これまでに学んできたことを一連のコマンドで振り返ってみよう。</p>
<pre><code>$ ls
all.h main.cpp
$ cat all.h
#include &lt;iostream&gt;
$ cat main.cpp
int main() { std::cout &lt;&lt; &quot;hello&quot;s ; }</code></pre>
<p>まず、カレントディレクトリには<code>all.h</code>と<code>main.cpp</code>がある。この2つのファイルは実行可能ファイルを生成するために必要なファイルだ。今回、その中身は最小限にしてある。本当の<code>all.h</code>は、実際には前回書いたように長い内容になる。</p>
<pre><code>$ g++ -std=c++17 -Wall --pedantic-errors -x c++-header -o all.h.gch all.h
$ ls
all.h all.h.gch main.cpp</code></pre>
<p>次に、ソースファイルのコンパイルを高速化するために、ヘッダーファイル<code>all.h</code>から、コンパイル済みヘッダーファイル<code>all.h.gch</code>を生成する。</p>
<pre><code>$ g++ -std=c++17 -Wall --pedantic-errors -include all.h -o program main.cpp
$ ls
all.h all.h.gch main.cpp program</code></pre>
<p>プリコンパイル済みヘッダーファイル<code>all.h.gch</code>とC++ソースファイル<code>main.cpp</code>から、実行可能ファイル<code>program</code>を生成する。</p>
<pre><code>$ ./program
hello</code></pre>
<p>実行可能ファイル<code>program</code>を実行する。</p>
<p>これで読者はC++のプログラミングを学び始めるに当たって必要なことは全て学んだ。さっそくC++を学んでいきたいところだが、その前にもう一つ、ビルドシステムを学ぶ必要がある。</p>
<h3 id="依存関係を解決するビルドシステム">依存関係を解決するビルドシステム</h3>
<p>以上のC++のソースファイルからプログラムを実行するまでの流れは、C++のプログラムとしてはとても単純なものだが、それでも依存関係が複雑だ。</p>
<p>プログラムの実行にあたって最終的に必要なのはファイル<code>program</code>だが、このファイルはGCCで生成しなければならない。ところでGCCでファイル<code>program</code>を生成するには、事前に<code>all.h</code>, <code>all.h.gch</code>, <code>main.cpp</code>が必要だ。<code>all.h.gch</code>は<code>all.h</code>からGCCで生成しなければならない。</p>
<p>一度コンパイルしたプログラムのソースファイルを書き換えて再びコンパイルする場合はどうすればいいだろう。<code>main.cpp</code>だけを書き換えた場合、<code>all.h</code>は何も変更されていないので、コンパイル済みヘッダーファイル<code>all.h.gch</code>の再生性は必要ない。<code>all.h</code>だけを書き換えた場合は、<code>all.h.gch</code>を生成するだけでなく、<code>program</code>も再生成しなければならない。</p>
<p>プログラムのコンパイルには、このような複雑な依存関係の解決が必要になる。依存関係の解決を人間の手で行うのは大変だ。例えば読者が他人によって書かれた何千ものソースファイルと、プログラムをコンパイルする手順書だけを渡されたとしよう。手順書に従ってコンパイルをしたとして、ソースファイルの一部だけを変更した場合、一体どの手順は省略できるのか、手順書から導き出すのは難しい。するとコンパイルを最初からやり直すべきだろうか。しかし、一つのソースファイルのコンパイルに1秒かかるとして、何千ものソースファイルがある場合、何千秒もかかってしまう。たった一つのソースファイルを変更しただけですべてをコンパイルし直すのは時間と計算資源の無駄だ。</p>
<p>この依存関係の問題は、ビルドシステムによって解決できる。本書ではGNU Makeというビルドシステムを学ぶ。読者がこれから学ぶビルドシステムによって、以下のような簡単なコマンドだけで、他人の書いた何千ものソースファイルからなるプログラムがコンパイル可能になる。</p>
<p>何千ものソースファイルから実行可能ファイルを生成したい。</p>
<pre><code>$ make</code></pre>
<p>これだけだ。<code>make</code>というコマンド一つでプログラムのコンパイルは自動的に行われる。</p>
<p>何千ものソースファイルのうち、一つのソースファイルだけを変更し、必要な部分だけを効率よく再コンパイルしたい。</p>
<pre><code>$ make</code></pre>
<p>これだけだ。<code>make</code>というコマンド一つでプログラムの再コンパイルは自動的に行われる。</p>
<p>ところで、生成される実行可能ファイルの名前はプログラムごとに様々だ。プログラムの開発中は、共通の方法でプログラムを実行したい。</p>
<pre><code>$ make run</code></pre>
<p>これでどんなプログラム名でも共通の方法で実行できる。</p>
<p>ソースファイルから生成されたプログラムなどのファイルをすべて削除したい。</p>
<pre><code>$ make clean</code></pre>
<p>これで生成されたファイルをすべて削除できる</p>
<p>テキストエディターにはVimを使っているがわざわざVimからターミナルに戻るのが面倒だ。</p>
<pre><code>:make</code></pre>
<p>VimはノーマルモードからMakeを呼び出すことができる。もちろん、<code>:make run</code>や<code>:make clean</code>もできる</p>
<h3 id="依存関係を記述するルール">依存関係を記述するルール</h3>
<p>依存関係はどのように表現したらいいのだろうか。GNU makeでは<code>Makefile</code>という名前のファイルの中に、<code>ターゲット'(targets)、</code>事前要件<code>(prerequisites)、</code>レシピ<code>(recipes)という3つの概念で依存関係を</code>ルール<code>(rules)として記述する。</code>ルール`は以下の文法だ。</p>
<pre><code>ターゲット : 事前要件
[TAB文字]レシピ</code></pre>
<p>レシピは必ず<code>TAB文字</code>を直前に書かなければならない。スペース文字ではだめだ。これは<code>make</code>の初心者を混乱させる落とし穴の一つとなっている。忘れずに<code>TAB文字</code>を打とう。</p>
<p>問題を簡単に理解するために、以下のような状況を考えよう。</p>
<pre><code>$ ls
source
$ cat source &gt; program</code></pre>
<p>この例では、ファイル<code>program</code>を生成するためにはファイル<code>source</code>が必要だ。ファイル<code>source</code>はすでに存在している。</p>
<p><code>ターゲット</code>は生成されるファイル名だ。この場合<code>program</code>となる。</p>
<pre><code>program : 事前要件
    レシピ</code></pre>
<p><code>事前要件</code>は<code>ターゲット</code>を生成するために必要なファイル名だ。この場合<code>source</code>となる。</p>
<pre><code>program : source
    レシピ</code></pre>
<p><code>レシピ</code>は<code>ターゲット</code>を生成するために必要な動作だ。この場合、<code>cat source &gt; program</code>となる</p>
<div class="sourceCode"><pre class="sourceCode makefile"><code class="sourceCode makefile"><span class="dv">program :</span><span class="dt"> source</span>
    cat source &gt; program</code></pre></div>
<p>さっそくこのルールを、ファイル<code>Makefile</code>に書き込み、makeを呼び出してみよう。</p>
<pre><code>$ ls
Makefile source 
$ cat Makefile
program : source
    cat source &gt; program
$ make
cat source &gt; program
$ ls
Makefile program source</code></pre>
<p>これがMakeの仕組みだ。<code>ターゲット</code>の生成に必要な<code>事前要件</code>と、<code>ターゲット</code>を生成する<code>レシピ</code>を組み合わせた<code>ルール</code>で依存関係を記述する。makeを実行すると、実行した<code>レシピ</code>が表示される。</p>
<p>もうすこしMakeの<code>ルール</code>を追加してみよう。例えばファイル<code>source</code>は予め存在するのではなく、ファイル<code>source01</code>, <code>source02</code>, <code>source03</code>の中身をこの順番で連結して生成するとしよう。以下のように書ける。</p>
<div class="sourceCode"><pre class="sourceCode makefile"><code class="sourceCode makefile"><span class="dv">program :</span><span class="dt"> source</span>
    cat source &gt; program

<span class="dv">source :</span><span class="dt"> source01 source02 source03</span>
    cat source01 source02 source03 &gt; source</code></pre></div>
<p>GNU Makeはカレントディレクトリにあるファイル<code>Makefile</code>の一番上に書かれたルールを実行しようとする。<code>program</code>を生成するには<code>source</code>が必要だが、<code>source</code>の生成には別のルールの実行が必要だ。Makefileはこの依存関係を自動で解決してくれる。</p>
<pre><code>$ touch source01 source02 source03
$ ls
Makefile source01 source03 source03
$ make
cat source01 source02 source03 &gt; source
cat source &gt; program
$ ls
Makefile program source source01 source02 source03</code></pre>
<p>すでに<code>make</code>を実行した後で、もう一度<code>make</code>を実行するとどうなるだろうか。</p>
<pre><code>$make
make: &#39;program&#39; is up to date.</code></pre>
<p>このメッセージの意味は「programは最新だ」という意味だ。<code>make</code>はファイルのタイムスタンプを調べ、もしファイル<code>program</code>より<code>source</code>のタイムスタンプの方が若い場合、つまり<code>program</code>が変更されたよりも後に<code>source</code>が変更された場合、<code>ルール</code>を実行する。</p>
<p>ためしにファイル<code>source02</code>のタイムスタンプを更新してみよう。</p>
<pre><code>$ touch source02
$ make
cat source01 source02 source03 &gt; source
cat source &gt; program</code></pre>
<p>ファイル<code>source</code>は<code>事前要件</code>に<code>source02</code>を含む。<code>source02</code>のタイムスタンプが<code>source</code>より若いので、<code>source</code>が再び生成される。すると、<code>source</code>のタイムスタンプが<code>program</code>のタイムスタンプよりも若くなったので、<code>program</code>も生成される。</p>
<p>もう一つ例を見てみよう。</p>
<pre><code>$ touch a b c
$ ls
a b c Makefile</code></pre>
<p>あるディレクトリにファイル<code>a</code>, <code>b</code>, <code>c</code>がある。</p>
<p><code>Makefile</code>は以下の内容になっている。</p>
<pre><code>D : A B C
    cat A B C &gt; D

A : a
    cat a &gt; A

B : b
    cat b &gt; B

C : c
    cat c &gt; C</code></pre>
<p>この<code>Makefile</code>を呼び出したときに作られるのはファイル<code>D</code>だ。ファイル<code>D</code>を作るにはファイル<code>A</code>, <code>B</code>, <code>C</code>が必要だ。このファイルはそれぞれファイル<code>a</code>, <code>b</code>, <code>c</code>から生成されるルールが記述してある。</p>
<p>これを<code>make</code>すると以下のようにファイル<code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>が作られる。</p>
<pre><code>$ ls
a b c Makefile
$ make
cat a &gt; A
cat b &gt; B
cat c &gt; C
cat A B C &gt; D</code></pre>
<p>ここで、ファイル<code>b</code>のタイムスタンプだけを更新して<code>make</code>してみよう。</p>
<pre><code>$ touch b
$ make
cat b &gt; B
cat A B C &gt; D</code></pre>
<p>ファイル<code>b</code>のタイムスタンプがファイル<code>B</code>より若くなったので、ファイル<code>B</code>がターゲットとなったルールが再び実行される。ファイル<code>A</code>, <code>C</code>のルールは実行されない。そしてファイル<code>B</code>のタイムスタンプがファイル<code>D</code>より若くなったので、ファイル<code>D</code>がターゲットとなったルールが再び実行される。</p>
<p><code>make</code>により、処理する必要のあるルールだけが部分的に処理されていることがわかる。</p>
<p><code>make</code>は適切な<code>ルール</code>さえ書けば、依存関係の解決を自動的に行ってくれる。</p>
<h3 id="コメント">コメント</h3>
<p><code>Makefile</code>にはコメントを書くことができる。<code>#</code>で始まる行はコメント扱いされる。</p>
<div class="sourceCode"><pre class="sourceCode makefile"><code class="sourceCode makefile"><span class="co"># programを生成するルール</span>
<span class="dv">program :</span><span class="dt"> source</span>
    cat source &gt; program

<span class="co"># sourceを生成するルール</span>
<span class="dv">source :</span><span class="dt"> source01 source02 source03</span>
    cat source01 source02 source03 &gt; source</code></pre></div>
<h3 id="変数">変数</h3>
<p><code>Makefile</code>には<code>変数</code>を書くことができる。</p>
<p>変数の文法は以下の通り</p>
<pre><code>variable = foobar

target : $(variable)</code></pre>
<p>これは、</p>
<pre><code>target : foobar</code></pre>
<p>と書いたものと同じように扱われる。</p>
<p>変数は<code>=</code>の左側に変数名、右側に変数の内容を書く。</p>
<p>変数を使うときは、<code>$(変数名)</code>のように、<code>$()</code>で変数名を包む。</p>
<h3 id="自動変数">自動変数</h3>
<dl>
<dt>$@</dt>
<dd>ターゲット
</dd>
<dt>$&lt;</dt>
<dd>最初の事前要件
</dd>
<dt>$^</dt>
<dd>すべての事前要件
</dd>
</dl>
<h1 id="cプリプロセッサー">Cプリプロセッサー</h1>
<p>CプリプロセッサーはC++がC言語から受け継いだ機能だ。CプリプロセッサーはソースコードをC++としてパースする前に、テキストをトークン単位で変形する処理のことだ。この処理はソースファイルをC++としてパースする前処理として行われる。CプリプロセッサーはC++ではなく別言語として認識すべきで、そもそもプログラミング言語ではなくマクロ言語だ。</p>
<p>C++ではCプリプロセッサーが広く使われており、今後もしばらくは使われるだろう。読者がC++で書かれた既存のコードを読む時、Cプリプロセッサーは避けて通れない。Cプリプロセッサーはいずれ廃止したい機能ではあるが、C++は未だに廃止できていない。</p>
<p>Cプリプロセッサーはプリプロセッシングディレクティブ(preprocessing directive)を認識し、トークン列を処理する。ディレクティブはソースファイルの文頭に文字<code>#</code>から始まり、改行文字で終わる。<code>#</code>とディレクティブの間に空白文字を入れてもよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#define NOSPACE</span>
<span class="pp">#    define SPACE</span></code></pre></div>
<h2 id="includeディレクティブ">#includeディレクティブ</h2>
<p><code>#include</code>は指定したファイルの内容をその場に挿入する。本質的にはコピペだ。C++では<code>#include</code>はライブラリを利用するのに使われる。</p>
<p><code>#include</code>は以下のいずれかの文法を持つ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&lt;ヘッダーファイルパス&gt;</span><span class="pp"> 改行文字</span>
<span class="pp">#include </span><span class="im">&quot;ヘッダーファイルパス&quot;</span><span class="pp"> 改行文字</span></code></pre></div>
<p><code>#include</code>は指定したファイルパスのファイルの内容をその場所に挿入する。このファイルをヘッダーファイルという。<code>&lt;&gt;</code>によるファイルパスは、標準ライブラリやシステムのヘッダーファイルを格納したディレクトリーからヘッダーファイルを探す。<code>&quot;&quot;</code>によるファイルパスは、システム以外のディレクトリーからもヘッダーファイルを探す。例えばカレントディレクトリーなどだ。</p>
<p>例えば、以下のようなヘッダーファイル<code>foo.h</code>があり、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// foo.h</span>
foo foo foo</code></pre></div>
<p>以下のようなソースファイル<code>bar.cpp</code>がある場合、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// bar.cpp</span>

<span class="pp">#include </span><span class="im">&quot;foo.h&quot;</span>

<span class="co">// end bar.cpp</span></code></pre></div>
<p><code>bar.cpp</code>をCプリプロセッサーにかけると、以下のようなソースファイルが出力される</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// bar.cpp</span>

<span class="co">// foo.h</span>
foo foo foo

<span class="co">// end bar.h</span></code></pre></div>
<p>このソースファイルはC++のソースファイルとしてはエラーとなるが、Cプリプロセッサーは単純にトークン列で分割したテキストファイルとしてソースファイルを処理するため、Cプリプロセッサーとしてはエラーにはならない。</p>
<p>冒頭で述べたように、<code>#include</code>の本質はコンパイラーによるコピペである。あるテキストファイルの内容をその場に挿入するコピペ機能を提供する。</p>
<p><code>#include</code>は、他の言語でモジュール、importなどと呼ばれている機能を簡易的に提供する。C++の標準ライブラリを使うには、<code>&lt;iostream&gt;</code>や<code>&lt;string&gt;</code>や<code>&lt;vector&gt;</code>のようなヘッダーファイルを<code>#include</code>する必要がある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// iostreamライブラリを使う</span>
<span class="pp">#include </span><span class="im">&lt;iostream&gt;</span>
<span class="co">// stringライブラリを使う</span>
<span class="pp">#include </span><span class="im">&lt;string&gt;</span>

<span class="dt">int</span> main()
{
    <span class="co">// &lt;string&gt;のライブラリ</span>
    <span class="bu">std::</span>string s(<span class="st">&quot;hello&quot;</span>) ;
    <span class="co">// iostreamのライブラリ</span>
    <span class="bu">std::</span>cout &lt;&lt; s ;
}</code></pre></div>
<p>すでに述べたように<code>#include</code>はファイルの内容をその場に挿入するだけであり、他の言語にあるモジュールのための高級な機能ではない。本書を執筆時点で規格策定中のC++20では、より高級なモジュール機能を追加する予定がある。</p>
<p>同じヘッダーファイルを複数回<code>#include</code>すると、当然複数回挿入される。</p>
<p>以下のような<code>val.h</code>を、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// val.h</span>
<span class="kw">inline</span> <span class="dt">int</span> val ;</code></pre></div>
<p>以下のように複数回<code>#include</code>すると、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&quot;val.h&quot;</span>
<span class="pp">#include </span><span class="im">&quot;val.h&quot;</span></code></pre></div>
<p>以下のように置換される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// val.h</span>
<span class="kw">inline</span> <span class="dt">int</span> val ;
<span class="co">// val.h</span>
<span class="kw">inline</span> <span class="dt">int</span> val ;</code></pre></div>
<p>これはvalの定義が重複しているためエラーとなる。</p>
<p>しかし、ヘッダーファイルを一度しか<code>#include</code>しないようにするのは困難だ。なぜならば、ヘッダーファイルは他のヘッダーファイルから間接的に<code>#include</code>されることもあるからだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// lib_f.h</span>

<span class="pp">#include </span><span class="im">&quot;val.h&quot;</span>

<span class="dt">int</span> f() ;</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// lib_g.h</span>

<span class="pp">#include </span><span class="im">&quot;val.h&quot;</span>

<span class="dt">int</span> g() ;</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// main.cpp</span>

<span class="pp">#include </span><span class="im">&quot;lib_f.h&quot;</span>
<span class="pp">#include </span><span class="im">&quot;lib_g.h&quot;</span>

<span class="dt">int</span> main()
{
    <span class="dt">int</span> result = f() + g() ;
}</code></pre></div>
<p>この<code>main.cpp</code>をCプリプロセッサーにかけると以下のように置換される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// main.cpp</span>

<span class="co">// lib_f.h</span>

<span class="co">// val.h</span>
<span class="kw">inline</span> <span class="dt">int</span> val ;

<span class="dt">int</span> f() ;

<span class="co">// lib_g.h</span>

<span class="co">// val.h</span>
<span class="kw">inline</span> <span class="dt">int</span> val ;

<span class="dt">int</span> g() ;


<span class="dt">int</span> main()
{
    <span class="dt">int</span> result = f() + g() ;
}</code></pre></div>
<p>これはvalの定義が重複しているためエラーとなる。</p>
<p>この問題に対処するためには、複数回<code>#include</code>されると困るヘッダーファイルでは、インクルードガード(include guard)と呼ばれている方法を使う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// val.h</span>

<span class="pp">#ifdef INCLUDE_GUARD_HEADER_VAL_H</span>
<span class="pp">#define INCLUDE_GUARD_HEADER_VAL_H</span>

<span class="kw">inline</span> <span class="dt">int</span> val ;

<span class="pp">#endif</span></code></pre></div>
<p>このように記述した<code>val.h</code>を複数回<code>#include</code>しても、最初のifdefのみがコンパイル対象になるため、問題は起こらない。</p>
<p>インクルードガードは以下の様式を持つ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#ifdef 十分にユニークなマクロ名</span>
<span class="pp">#define 十分にユニークなマクロ名 </span>

<span class="co">// 重複してコンパイルされたくないコードをここに書く</span>

<span class="pp">#endif</span></code></pre></div>
<p><code>十分にユニークなマクロ名</code>は全ソースファイル中で衝突しないそのヘッダーに固有のマクロ名を使う。慣習的に推奨される方法としてはすべて大文字を使い、十分に長いマクロ名にすることだ。</p>
<h2 id="define">#define</h2>
<p><code>#define</code>はマクロ置換を行う。マクロにはオブジェクト風マクロ(object-like macro)と関数風マクロ(function-like macro)がある。風というのは、マクロはオブジェクトでも関数でもないからだ。ただ、文法上オブジェクトや関数の似ているだけで、実態はトークン列の愚直な置換だ。</p>
<h3 id="オブジェクト風マクロ">オブジェクト風マクロ</h3>
<p>オブジェクト風マクロの文法は以下の通り</p>
<pre><code>#define マクロ名 置換リスト　改行文字</code></pre>
<p><code>#define</code>以降の行では、マクロ名が置換リストに置き換わる</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#define ONE             1</span>
<span class="pp">#define ONE_PLUS_ONE    ONE + ONE</span>
<span class="pp">#define GNU GNU&#39;s is NOT UNIX</span>

ONE
ONE_PLUS_ONE</code></pre></div>
<p>これをプリプロセスすると以下のソースコードになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dv">1</span>
<span class="dv">1</span> + <span class="dv">1</span></code></pre></div>
<p>マクロ名<code>ONE</code>は<code>1</code>に置換される。</p>
<p>マクロ名<code>ONE_PLUS_ONE</code>は<code>ONE + ONE</code>に置換される。置換された結果に別のマクロ名があれば、そのマクロ名も置換される。</p>
<p>あるマクロ名を置換した結果、そのマクロ名が現れても再帰的に置換されることはない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#define GNU GNU&#39;s NOT UNIX!</span>

GNU</code></pre></div>
<p>これは以下のように置換される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">GNU<span class="st">&#39;s NOT UNIX!</span></code></pre></div>
<p>マクロ名<code>GNU</code>を展開するとトークン`GNU'が現れるが、これは置換されたマクロ名と同じなので、再帰的に置換されることはない。</p>
<h3 id="関数風マクロ">関数風マクロ</h3>
<p>関数風マクロの文法は以下の通り。</p>
<pre><code>#define マクロ名( 識別子リスト ) 置換リスト 改行文字</code></pre>
<p>関数風マクロはあたかも関数のように記述できる。関数風マクロに実引数として渡したトークン列は、置換リスト内で仮引数としての識別子で参照できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#define NO_ARGUMENT()           No argument</span>
<span class="pp">#define ONE_ARGUMENT( ARG )     begin ARG end</span>
<span class="pp">#define MAKE_IT_DOUBLE( ARG )   ONE_ARGUMENT( ARG ARG )</span>

NO_ARGUMENT()
ONE_ARGUMENT( foo bar )
MAKE_IT_DOUBLE( foo bar )</code></pre></div>
<p>これは以下のように置換される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">No argument
begin foo bar end
begin foo bar foo bar end</code></pre></div>
<p>複数の引数を取るマクロへの実引数は、カンマで区切られたトークン列を渡す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#define TWO( A, B ) A B</span>
<span class="pp">#define THREE( A, B, C ) C B A</span>

TWO( <span class="dv">1</span> <span class="dv">2</span>, <span class="dv">3</span> <span class="dv">4</span> )
THREE( <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span> )</code></pre></div>
<p>これは以下のように置換される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>
<span class="dv">3</span> <span class="dv">2</span> <span class="dv">1</span></code></pre></div>
<p>ただし、括弧で囲まれたトークン列の中にあるカンマは、マクロの実引数の区切りとはみなされない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#define MACRO( A ) A</span>

MACRO( (a,b) )</code></pre></div>
<p>これは以下のように置換される。</p>
<pre><code>(a,b)</code></pre>
<h3 id="va_args__可変長引数マクロ"><code>__VA_ARGS__</code>(可変長引数マクロ)</h3>
<p><code>#define</code>の識別子リストを<code>...</code>だけにしたマクロは、可変長引数マクロになる。このときマクロの実引数のトークン列は、置換リストのなかで<code>__VA_ARGS__</code>として参照できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#define MACRO(...) </span><span class="ot">__VA_ARGS__</span>

MACRO( You can write , <span class="kw">and</span> ,, <span class="kw">or</span> even ,,,, )</code></pre></div>
<p>これは以下のように置換される。</p>
<pre><code>You can write , and ,, or even ,,,,</code></pre>
<p>カンマも含めてすべてのトークン列がそのまま<code>__VA_ARGS__</code>で参照できる。</p>
<p>可変長引数マクロの識別子リストに仮引数と<code>...</code>を書いたマクロの置換リストでは、仮引数の数だけの実引数は仮引数で参照され、残りが<code>__VA_ARGS__</code>で参照される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#define MACRO( X, Y, Z, ... ) X Y Z and </span><span class="ot">__VA_ARGS__</span>

MACRO( <span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span> )</code></pre></div>
<p>これは以下のように置換される</p>
<pre><code>1 2 3 and 4,5,6</code></pre>
<p>X, Y, Zにそれぞれ1, 2, 3が入り、<code>__VA_ARGS__</code>には<code>4,5,6</code>が入る。</p>
<h3 id="va_opt__"><code>__VA_OPT__</code></h3>
<p><code>__VA_OPT__</code>は可変長引数マクロで<code>__VA_ARGS__</code>にトークン列が渡されたかどうかで置換結果を変えることができる。</p>
<p><code>__VA_OPT__</code>は可変引数マクロの置換リストでのみ使える。<code>__VA_OPT__(content)</code>は<code>__VA_ARGS__</code>にトークンがない場合はトークンなしに置換され、トークンがある場合はトークン列<code>content</code>に置換される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#define MACRO( X, ... ) f( X __VA_OPT__(,) </span><span class="ot">__VA_ARGS__</span><span class="pp"> )</span>

MACRO(<span class="dv">1</span>)
MACRO(<span class="dv">1</span>,<span class="dv">2</span>)</code></pre></div>
<p>これは以下のように置換される。</p>
<pre><code>f( 1 )
f( 1, 2 )</code></pre>
<p><code>MACRO(1)</code>は<code>X</code>が<code>1</code>になり、<code>__VA_ARGS__</code>にはトークンがないので、<code>__VA_OPT__(,)</code>は空に置換される。結果として<code>f(1)</code>となる。</p>
<p><code>MACRO(1,2)</code>は、Xが1になり、<code>__VA_ARGS__'にはトークン</code>2<code>が入るので、</code><strong>VA_OPT</strong>(,)<code>は</code>,<code>に置換される。結果として</code>f(1,2)`となる。</p>
<p><code>__VA_OPT__</code>は<code>__VA_ARGS__</code>に実引数となるトークン列がなければ空に置換されるので、このようにトークン列の有無によってカンマなどの文法上必須のトークン列の有無を切り替えたい場合に使うことができる。</p>
<h3 id="演算子">#演算子</h3>
<p><code>#</code>はマクロ実引数を文字列リテラルにする。</p>
<p><code>#</code>は関数風マクロの置換リストの中のみで使うことができる。<code>#</code>は関数風マクロの仮引数の識別子の直前に書くことができる。<code>#</code>が直前に書かれた識別子は、マクロ実引数のトークン列の文字列リテラルになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#define STRING( X ) # X</span>

STRING( hello )
STRING( hello world )</code></pre></div>
<p>これは以下のように置換される。</p>
<pre><code>&quot;hello&quot;
&quot;hello world&quot;</code></pre>
<p>また、可変長マクロと組み合わせた場合、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#define STRING( ... ) # </span><span class="ot">__VA_ARGS__</span>

STRING()
STRING( hello,world )</code></pre></div>
<p>以下のように置換される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="st">&quot;&quot;</span>
<span class="st">&quot;hello,world&quot;</span></code></pre></div>
<h3 id="演算子-1">##演算子</h3>
<p><code>##</code>はマクロ実引数の結合を行う。</p>
<p><code>##</code>は関数風マクロの置換リストの中にしか書けない。<code>##</code>は両端にマクロの仮引数の識別子を書かなければならない。<code>##</code>は両端の識別子の参照するマクロ実引数のトークン列を結合した置換を行う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#define CONCAT( A, B ) A ## B</span>

CONCAT( foo, bar )
CONCAT( aaa bbb, ccc ddd)</code></pre></div>
<p>これは以下のように置換される。</p>
<pre><code>foobar
aaa bbbccc ddd</code></pre>
<p>結合した結果のトークンは更にマクロ置換の対象となる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#define CONCAT( A, B ) A ## B</span>
<span class="pp">#define FOOBAR hello</span>

CONCAT( FOO, BAR )</code></pre></div>
<p>これは以下のように置換される。</p>
<pre><code>hello</code></pre>
<p><code>CONCAT(FOO,BAR)</code>は<code>FOOBAR</code>に置換され、FOOBARという名前のマクロ名があるためにさらに<code>hello</code>に置換される。</p>
<h3 id="複数行の置換リスト">複数行の置換リスト</h3>
<p><code>#define</code>ディレクティブの置換リストは複数行に渡って書くことができない。これは文法上の制約によるものだ。<code>#define</code>ディレクティブは改行文字で終端される。</p>
<p>しかし、関数やクラスを生成するような複雑なマクロは、複数行に分けて書きたい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#define LIST_NAME2( PREFIX, TYPE ) PREFIX ## TYPE</span>
<span class="pp">#define LIST_NAME( TYPE ) LIST_NAME2( list_, TYPE )</span>

<span class="pp">#define DEFINE_LIST( TYPE ) struct LIST_NAME(TYPE){TYPE value ;LIST_NAME(TYPE) * prev ;LIST_NAME(TYPE) * next ;} ; </span>

DEFINE_LIST(<span class="dt">int</span>)
DEFINE_LIST(<span class="dt">double</span>)</code></pre></div>
<p>この場合、行末にバックスラッシュに続けて改行を書くと、バックスラッシュと改行がプリプロセッサーによって削除される。</p>
<p>上の例は以下のように、プリプロセッサーとしては比較的わかりやすく書くことができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#define LIST_NAME2( PREFIX, TYPE ) PREFIX ## TYPE</span>
<span class="pp">#define LIST_NAME( TYPE ) LIST_NAME2( list_, TYPE )</span>

<span class="pp">#define DEFINE_LIST( TYPE )</span>\
<span class="pp">struct LIST_NAME(TYPE)</span>\
<span class="pp">{</span>\
<span class="pp">    TYPE value ;</span>\
<span class="pp">    LIST_NAME(TYPE) * prev ;</span>\
<span class="pp">    LIST_NAME(TYPE) * next ;</span>\
<span class="pp">} ; </span>

DEFINE_LIST(<span class="dt">int</span>)
DEFINE_LIST(<span class="dt">double</span>)</code></pre></div>
<p>C++ではテンプレートがあるために、このようなマクロを書く必要はない。</p>
<h3 id="undefディレクティブ">#undefディレクティブ</h3>
<p><code>#undef</code>はそれ以前に定義されたマクロを削除する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#define FOO BAR</span>
FOO
<span class="pp">#undef FOO</span>
FOO</code></pre></div>
<p>これは以下のように置換される。</p>
<pre><code>BAR
FOO</code></pre>
<h2 id="条件付きソースファイル選択">条件付きソースファイル選択</h2>
<p><code>#if</code>, <code>#elif</code>, <code>#else</code>, <code>#endif</code>, <code>#ifdef</code>, <code>#ifndef</code>は条件付きのソースファイルの選択(conditinal inclusion)を行う。これは条件付きコンパイルに近い機能を提供する。</p>
<h3 id="プリプロセッサーの定数式">プリプロセッサーの定数式</h3>
<p>プリプロセッサーで使える条件式は、C++の条件式とは比べてだいぶ制限がある。基本的には整数定数式で、<code>true</code>, <code>false</code>が使える他、<code>123</code>, <code>1+1</code>, <code>1 == 1</code>, <code>1 &lt; 1</code>のような式も使える。ただし、識別子はすべてマクロ名として置換できるものは置換され、置換できない識別子は、<code>true</code>, <code>false</code>以外はキーワードも含めてすべて0に置換される。</p>
<p>したがって、プリプロセッサーで以下のように書くと、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#if UNDEFINED</span>
<span class="pp">#endif</span></code></pre></div>
<p>以下のように書いたものと同じになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#if 0</span>
<span class="pp">#endif</span></code></pre></div>
<p>プリプロセッサーであるので、C++としてのconstexpr変数やconstexpr関数も使えない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">constexpr</span> <span class="dt">int</span> x = <span class="dv">1</span> ;

<span class="pp">#if x</span>
hello
<span class="pp">#endif</span></code></pre></div>
<p>これは以下のように置換される。</p>
<pre><code>constexpr int x = 1 ;</code></pre>
<p>プリプロセッサーはC++の文法と意味を理解しない。単にトークン列として処理する。</p>
<p>以下の例はエラーになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">constexpr</span> <span class="dt">int</span> f() { <span class="cf">return</span> <span class="dv">1</span> ; }

<span class="pp">#if f()</span>
<span class="pp">#endif</span></code></pre></div>
<p>なぜならば、<code>0()</code>は整数定数式として合法なコードではないからだ。何度も言うように、プリプロセッサーはC++の文法と意味を理解しない。</p>
<p>プリプロセッサーの定数式では、特殊なマクロ風の式を使うことができる。<code>defined</code>と<code>__has_include</code>だ。</p>
<p><code>defined</code>は以下の文法を持つ</p>
<pre><code>defined 識別子
defined ( 識別子 )</code></pre>
<p><code>defined</code>は識別子がそれ以前の行で<code>#define</code>でマクロとして定義されていて<code>#undef</code>で取り消されていない場合<code>1</code>になり、それ以外の場合0になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// #if 0</span>
<span class="pp">#if defined MACRO</span>
<span class="pp">#endif</span>

<span class="pp">#define MACRO</span>

<span class="co">// #if 1</span>
<span class="pp">#if defined MACRO</span>
<span class="pp">#endif</span>

<span class="pp">#undef MACRO</span>

<span class="co">// #if 0</span>
<span class="pp">#if defined MACRO</span>
<span class="pp">#endif</span></code></pre></div>
<p><code>__has_include</code>は以下の文法を持つ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">__has_include ( &lt; ヘッダーファイル名 &gt; )
__has_include ( <span class="st">&quot; ヘッダーファイル名 &quot;</span> )
__has_include ( 文字列リテラル )
__has_include ( &lt; マクロ &gt; )</code></pre></div>
<p>1番目と2番目は、指定されたヘッダーファイル名がシステムに存在する場合<code>1</code>に、そうでない場合0になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// &lt;filesystem&gt;の存在を確認してから#includeする</span>
<span class="pp">#if __has_include(&lt;filesystem&gt;)</span>
<span class="pp">#   include </span><span class="im">&lt;filesystem&gt;</span>
<span class="pp">#endif</span>

<span class="co">// &quot;mylibrary.h&quot;の存在を確認してから#includeする</span>
<span class="pp">#if __has_include(&quot;mylibrary.h&quot;)</span>
<span class="pp">#   include </span><span class="im">&quot;mylibrary.h&quot;</span>
<span class="pp">#endif</span></code></pre></div>
<p>3番目と4番目は、1番目と2番目が適用できない場合に初めて考慮される。その場合、まず通常通りにプリプロセッサーのマクロ置換が行われる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#define STDIO &quot;stdio.h&quot;</span>

<span class="pp">#if __has_include( STDIO )</span>
<span class="pp">#endif</span>

<span class="pp">#define STDLIB stdlib.h</span>

<span class="pp">#if __has_include( &lt;STDLIB&gt; )</span>
<span class="pp">#endif</span></code></pre></div>
<h3 id="ifディレクティブ">#ifディレクティブ</h3>
<p><code>#if</code>ディレクティブは以下の文法を持つ。</p>
<pre><code>#if 定数式 改行文字

#endif</code></pre>
<p>もし定数式がゼロの場合、<code>#if</code>と<code>#endif</code>で囲まれたトークン列は処理されない。定数式が非ゼロの場合、処理される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#if 0</span>
<span class="co">This line will be skipped.</span>
<span class="pp">#endif</span>

<span class="pp">#if 1</span>
This line will be processed.
<span class="pp">#endif</span></code></pre></div>
<p>これをプリプロセスすると以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">This line will be processed.</code></pre></div>
<p><code>#if 0</code>は処理されないので、<code>#endif</code>までのトークン列は消える。</p>
<h3 id="elifディレクティブ">#elifディレクティブ</h3>
<p><code>#elif</code>ディレクティブは、C++でいう<code>else if</code>に相当する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">
<span class="pp">#elif 定数式 改行文字</span></code></pre></div>
<p><code>#elif</code>ディレクティブは<code>#if</code>ディレクティブと<code>#endif</code>ディレクティブの間に複数書くことができる。<code>#elif</code>のある<code>#if</code>が処理される場合、<code>#if</code>から<code>#elif</code>の間のトークン列が処理される、<code>#if</code>が処理されない場合、<code>#elif</code>が<code>#if</code>と同じように定数式を評価して処理されるかどうかが判断される。<code>#elif</code>が処理される場合、処理されるトークン列は次の<code>#elif</code>もしくは<code>#endif</code>までの間のトークン列になる。</p>
<p>以下の例は、すべてYESのトークンがある行のみ処理される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#if 1</span>
YES
<span class="pp">#elif</span><span class="co"> 1</span>
<span class="co">NO</span>
<span class="pp">#endif</span>

<span class="pp">#if 0</span>
<span class="co">NO</span>
<span class="pp">#elif</span> <span class="dv">1</span>
YES
<span class="pp">#endif</span>

<span class="pp">#if 0</span>
<span class="co">NO</span>
<span class="pp">#elif</span> <span class="dv">1</span>
YES
<span class="pp">#elif 1</span>
NO
<span class="pp">#endif</span>

<span class="pp">#if 0</span>
<span class="co">NO</span>
<span class="pp">#elif</span> <span class="dv">0</span>
NO
<span class="pp">#elif 1</span>
YES
<span class="pp">#endif</span></code></pre></div>
<p>プリプロセスした結果は以下の通り、</p>
<pre><code>YES
YES
YES
YES</code></pre>
<h3 id="elseディレクティブ">#elseディレクティブ</h3>
<p><code>#else</code>ディレクティブはC++でいう<code>else</code>に相当する。</p>
<p><code>#else</code>ディレクティブは<code>#if</code>ディレクティブと<code>#endif</code>ディレクティブの間に書くことができる。もし<code>#if</code>と<code>#elif</code>ディレクティブが処理されない場合で<code>#else</code>ディレクティブがある場合、<code>#else</code>から<code>#endif</code>までのトークン列が処理される。</p>
<p>以下の例は、YESのトークンがある行のみ処理される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#if 1</span>
YES
<span class="pp">#else</span>
<span class="co">NO</span>
<span class="pp">#endif</span>

<span class="pp">#if 0</span>
<span class="co">NO</span>
<span class="pp">#else</span>
YES
<span class="pp">#endif</span>

<span class="pp">#if 0</span>
<span class="co">NO</span>
<span class="pp">#elif</span> <span class="dv">1</span>
YES
<span class="pp">#else</span>
NO
<span class="pp">#endif</span></code></pre></div>
<h3 id="ifdef-ifndefディレクティブ">#ifdef, #ifndefディレクティブ</h3>
<pre><code>#ifdef 識別子
#ifndef 識別子</code></pre>
<p>は、それぞれ以下と同じ意味になる。</p>
<pre><code>#if defined 識別子
#if !defined 識別子</code></pre>
<p>例、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#ifdef MACRO</span>
<span class="pp">#endif</span>

<span class="co">// 上と同じ</span>
<span class="pp">#if defined MACRO</span>
<span class="pp">#endif</span>


<span class="pp">#ifndef MACRO</span>
<span class="pp">#endif</span>

<span class="co">// 上と同じ</span>
<span class="pp">#if !defined MACRO</span>
<span class="pp">#endif</span></code></pre></div>
<h2 id="lineディレクティブ">#lineディレクティブ</h2>
<p><code>#line</code>ディレクティブはディレクティブの次の行の行番号と、ソースファイル名を変更する。これは人間が使うのではなく、ツールによって生成されることを想定した機能だ。</p>
<p>以下の文法の<code>#line</code>ディレクティブは、<code>#line</code>ディレクティブの次の行の行番号をあたかも数値で指定した行番号であるかのように振る舞わせる。</p>
<pre><code>#line 数値 改行文字</code></pre>
<p>数値として0もしくは2147483647より大きい数を指定した場合の挙動は未定義となる。</p>
<p>以下の例はコンパイルエラーになるが、コンパイルエラーメッセージはあたかも102行目に問題があるかのように表示される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 1行目</span>
<span class="co">// 2行目</span>
<span class="pp">#line 100 </span><span class="co">// 3行目</span>
<span class="co">// 100行目</span>
<span class="co">// 101行目</span>
ill-formed line <span class="co">// 102行目</span></code></pre></div>
<p>以下の例は999を出力するコードだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span>
<span class="dt">int</span> main()
{
<span class="pp">#line 999</span>
    <span class="bu">std::</span>cout &lt;&lt; <span class="ot">__LINE__</span> ;
}</code></pre></div>
<p>以下の文法の<code>#line</code>ディレクティブは、次の行の行番号を数値にした上で、ソースファイル名をソースファイル名にする。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#line 数値 &quot;ソースファイル名&quot; 改行文字</span></code></pre></div>
<p>例、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#line 42 &quot;answer.cpp&quot;</span></code></pre></div>
<p>以下の文法の<code>#line</code>ディレクティブは、プリプロセッサートークン列をプリプロセスし、上の2つの文法のいずれかに合致させる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#line プリプロセッサートークン列 改行文字</span></code></pre></div>
<p>例、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#define LINE_NUMBER 123</span>
<span class="pp">#line LINE_NUMBER</span></code></pre></div>
<h2 id="errorディレクティブ">#errorディレクティブ</h2>
<p><code>#error</code>ディレクティブはコンパイルエラーを引き起こす。</p>
<pre><code>#error 改行文字
#error トークン列 改行文字</code></pre>
<p><code>#error</code>によるコンパイラーのエラーメッセージには<code>#error</code>のトークン列を含む。</p>
<p><code>#error</code>の利用例としては、<code>#if</code>と組み合わせるものがある。以下の例はCHAR_BITが8でなければコンパイルエラーになるソースファイルだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&lt;climits&gt;</span>

<span class="pp">#if CHAR_BIT != 8</span>
<span class="pp">#error CHAR_BIT != 8 implementation is not supported.</span>
<span class="pp">#endif</span></code></pre></div>
<p><code>#if</code>が処理されなければ、その中にある<code>#error</code>も処理されないので、コンパイルエラーにはならない。</p>
<h2 id="pragmra">#pragmra</h2>
<p><code>#pragmra</code>ディレクティブは実装依存の処理を行う。<code>#pragma</code>はコンパイラー独自の拡張機能を追加する文法として使われている。</p>
<p>文法は以下の通り。</p>
<pre><code>#pragma プリプロセッサートークン列 改行文字</code></pre>
<p>C++では属性が追加されたために、<code>#pragma</code>を使う必要はほとんどなくなっている。</p>
<h2 id="nullディレクティブ">Nullディレクティブ</h2>
<p><code>Null</code>ディレクティブとは何もしないプリプロセッサーディレクティブだ。</p>
<pre><code># 改行文字</code></pre>
<p>つまり、単に<code>#</code>とだけ書いた行はエラーにはならない。</p>
<h2 id="定義済みマクロ名">定義済みマクロ名</h2>
<p>いくつかのマクロ名がプリプロセッサーによって予め定義されている。</p>
<table>
<colgroup>
<col width="43%" />
<col width="17%" />
<col width="39%" />
</colgroup>
<thead>
<tr class="header">
<th>マクロ名</th>
<th align="left">値</th>
<th align="left">意味</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>__cplusplus</td>
<td align="left">201703L</td>
<td align="left">C++17時点での値<br />
将来の規格で増やされる</td>
</tr>
<tr class="even">
<td>__DATE__</td>
<td align="left">&quot;Mmm dd yyyy&quot;</td>
<td align="left">ソースファイルがプリプロセスされた日付 Mmmは月、ddは日、yyyyは年<br />
月の文字列はasctimeが生成するものと同じ<br />
日が1桁の場合、ddの最初の文字は空白文字</td>
</tr>
<tr class="odd">
<td>__FILE__</td>
<td align="left">文字列リテラル</td>
<td align="left">ソースファイルの名前の文字列リテラル</td>
</tr>
<tr class="even">
<td>__LINE__</td>
<td align="left">整数リテラル</td>
<td align="left">ソースファイルの現在の行番号</td>
</tr>
<tr class="odd">
<td>__STDC_HOSTED__</td>
<td align="left">整数リテラル</td>
<td align="left">ホスト実装の場合1<br />
フリースタンディング実装の場合0</td>
</tr>
<tr class="even">
<td>__STDCPP_DEFAULT_NEW_ALIGNMENT__</td>
<td align="left">整数リテラル</td>
<td align="left">アライメント</td>
</tr>
</tbody>
</table>
</body>
</html>
